/*! O2SOC Theme Build: 2.15.1 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(factory());
}(this, (function () { 'use strict';

/**
 * @this {Promise}
 */
function finallyConstructor(callback) {
  var constructor = this.constructor;
  return this.then(
    function(value) {
      // @ts-ignore
      return constructor.resolve(callback()).then(function() {
        return value;
      });
    },
    function(reason) {
      // @ts-ignore
      return constructor.resolve(callback()).then(function() {
        // @ts-ignore
        return constructor.reject(reason);
      });
    }
  );
}

// Store setTimeout reference so promise-polyfill will be unaffected by
// other code modifying setTimeout (like sinon.useFakeTimers())
var setTimeoutFunc = setTimeout;

function isArray(x) {
  return Boolean(x && typeof x.length !== 'undefined');
}

function noop() {}

// Polyfill for Function.prototype.bind
function bind(fn, thisArg) {
  return function() {
    fn.apply(thisArg, arguments);
  };
}

/**
 * @constructor
 * @param {Function} fn
 */
function Promise(fn) {
  if (!(this instanceof Promise))
    throw new TypeError('Promises must be constructed via new');
  if (typeof fn !== 'function') throw new TypeError('not a function');
  /** @type {!number} */
  this._state = 0;
  /** @type {!boolean} */
  this._handled = false;
  /** @type {Promise|undefined} */
  this._value = undefined;
  /** @type {!Array<!Function>} */
  this._deferreds = [];

  doResolve(fn, this);
}

function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }
  if (self._state === 0) {
    self._deferreds.push(deferred);
    return;
  }
  self._handled = true;
  Promise._immediateFn(function() {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
      return;
    }
    var ret;
    try {
      ret = cb(self._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve(deferred.promise, ret);
  });
}

function resolve(self, newValue) {
  try {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self)
      throw new TypeError('A promise cannot be resolved with itself.');
    if (
      newValue &&
      (typeof newValue === 'object' || typeof newValue === 'function')
    ) {
      var then = newValue.then;
      if (newValue instanceof Promise) {
        self._state = 3;
        self._value = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(bind(then, newValue), self);
        return;
      }
    }
    self._state = 1;
    self._value = newValue;
    finale(self);
  } catch (e) {
    reject(self, e);
  }
}

function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  finale(self);
}

function finale(self) {
  if (self._state === 2 && self._deferreds.length === 0) {
    Promise._immediateFn(function() {
      if (!self._handled) {
        Promise._unhandledRejectionFn(self._value);
      }
    });
  }

  for (var i = 0, len = self._deferreds.length; i < len; i++) {
    handle(self, self._deferreds[i]);
  }
  self._deferreds = null;
}

/**
 * @constructor
 */
function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, self) {
  var done = false;
  try {
    fn(
      function(value) {
        if (done) return;
        done = true;
        resolve(self, value);
      },
      function(reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      }
    );
  } catch (ex) {
    if (done) return;
    done = true;
    reject(self, ex);
  }
}

Promise.prototype['catch'] = function(onRejected) {
  return this.then(null, onRejected);
};

Promise.prototype.then = function(onFulfilled, onRejected) {
  // @ts-ignore
  var prom = new this.constructor(noop);

  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};

Promise.prototype['finally'] = finallyConstructor;

Promise.all = function(arr) {
  return new Promise(function(resolve, reject) {
    if (!isArray(arr)) {
      return reject(new TypeError('Promise.all accepts an array'));
    }

    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then;
          if (typeof then === 'function') {
            then.call(
              val,
              function(val) {
                res(i, val);
              },
              reject
            );
            return;
          }
        }
        args[i] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.resolve = function(value) {
  if (value && typeof value === 'object' && value.constructor === Promise) {
    return value;
  }

  return new Promise(function(resolve) {
    resolve(value);
  });
};

Promise.reject = function(value) {
  return new Promise(function(resolve, reject) {
    reject(value);
  });
};

Promise.race = function(arr) {
  return new Promise(function(resolve, reject) {
    if (!isArray(arr)) {
      return reject(new TypeError('Promise.race accepts an array'));
    }

    for (var i = 0, len = arr.length; i < len; i++) {
      Promise.resolve(arr[i]).then(resolve, reject);
    }
  });
};

// Use polyfill for setImmediate for performance gains
Promise._immediateFn =
  // @ts-ignore
  (typeof setImmediate === 'function' &&
    function(fn) {
      // @ts-ignore
      setImmediate(fn);
    }) ||
  function(fn) {
    setTimeoutFunc(fn, 0);
  };

Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== 'undefined' && console) {
    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
  }
};

/** @suppress {undefinedVars} */
var globalNS = (function() {
  // the only reliable means to get the global object is
  // `Function('return this')()`
  // However, this causes CSP violations in Chrome apps.
  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof global !== 'undefined') {
    return global;
  }
  throw new Error('unable to locate global object');
})();

if (!('Promise' in globalNS)) {
  globalNS['Promise'] = Promise;
} else if (!globalNS.Promise.prototype['finally']) {
  globalNS.Promise.prototype['finally'] = finallyConstructor;
}

})));

window.isIE = !!window.MSInputMethodContext && !!document.documentMode;

// Promise polyfill is in bundle.

// Object.assign as on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
if (typeof Object.assign !== 'function') {
  // Must be writable: true, enumerable: false, configurable: true
  Object.defineProperty(Object, "assign", {
    value: function assign(target, varArgs) { // .length of function is 2
      'use strict';
      if (target === null || target === undefined) {
        throw new TypeError('Cannot convert undefined or null to object');
      }

      var to = Object(target);

      for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];

        if (nextSource !== null && nextSource !== undefined) {
          for (var nextKey in nextSource) {
            // Avoid bugs when hasOwnProperty is shadowed
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    },
    writable: true,
    configurable: true
  });
}

// Array.prototype.find as on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
// https://tc39.github.io/ecma262/#sec-array.prototype.find
if (!Array.prototype.find) {
  Object.defineProperty(Array.prototype, 'find', {
    value: function(predicate) {
      // 1. Let O be ? ToObject(this value).
      if (this == null) {
        throw TypeError('"this" is null or not defined');
      }

      var o = Object(this);

      // 2. Let len be ? ToLength(? Get(O, "length")).
      var len = o.length >>> 0;

      // 3. If IsCallable(predicate) is false, throw a TypeError exception.
      if (typeof predicate !== 'function') {
        throw TypeError('predicate must be a function');
      }

      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
      var thisArg = arguments[1];

      // 5. Let k be 0.
      var k = 0;

      // 6. Repeat, while k < len
      while (k < len) {
        // a. Let Pk be ! ToString(k).
        // b. Let kValue be ? Get(O, Pk).
        // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
        // d. If testResult is true, return kValue.
        var kValue = o[k];
        if (predicate.call(thisArg, kValue, k, o)) {
          return kValue;
        }
        // e. Increase k by 1.
        k++;
      }

      // 7. Return undefined.
      return undefined;
    },
    configurable: true,
    writable: true
  });
}

// Arrayprototype.forEach as on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
// http://es5.github.io/#x15.4.4.18
if (!Array.prototype['forEach']) {

  Array.prototype.forEach = function(callback, thisArg) {

    if (this == null) { throw new TypeError('Array.prototype.forEach called on null or undefined'); }

    var T, k;
    // 1. Let O be the result of calling toObject() passing the
    // |this| value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get() internal
    // method of O with the argument "length".
    // 3. Let len be toUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If isCallable(callback) is false, throw a TypeError exception.
    // See: http://es5.github.com/#x9.11
    if (typeof callback !== "function") { throw new TypeError(callback + ' is not a function'); }

    // 5. If thisArg was supplied, let T be thisArg; else let
    // T be undefined.
    if (arguments.length > 1) { T = thisArg; }

    // 6. Let k be 0
    k = 0;

    // 7. Repeat, while k < len
    while (k < len) {

      var kValue;

      // a. Let Pk be ToString(k).
      //    This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty
      //    internal method of O with argument Pk.
      //    This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal
        // method of O with argument Pk.
        kValue = O[k];

        // ii. Call the Call internal method of callback with T as
        // the this value and argument list containing kValue, k, and O.
        callback.call(T, kValue, k, O);
      }
      // d. Increase k by 1.
      k++;
    }
    // 8. return undefined
  };
}

// SVG for IE11
if (!SVGElement.prototype.contains) {
  SVGElement.prototype.contains = HTMLDivElement.prototype.contains;
}

// Array.prototype.includes as on https://tc39.github.io/ecma262/#sec-array.prototype.includes
if (!Array.prototype.includes) {
  Object.defineProperty(Array.prototype, 'includes', {
    value: function(searchElement, fromIndex) {

      if (this == null) {
        throw new TypeError('"this" is null or not defined');
      }

      // 1. Let O be ? ToObject(this value).
      var o = Object(this);

      // 2. Let len be ? ToLength(? Get(O, "length")).
      var len = o.length >>> 0;

      // 3. If len is 0, return false.
      if (len === 0) {
        return false;
      }

      // 4. Let n be ? ToInteger(fromIndex).
      //    (If fromIndex is undefined, this step produces the value 0.)
      var n = fromIndex | 0;

      // 5. If n ≥ 0, then
      //  a. Let k be n.
      // 6. Else n < 0,
      //  a. Let k be len + n.
      //  b. If k < 0, let k be 0.
      var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

      function sameValueZero(x, y) {
        return x === y || (typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y));
      }

      // 7. Repeat, while k < len
      while (k < len) {
        // a. Let elementK be the result of ? Get(O, ! ToString(k)).
        // b. If SameValueZero(searchElement, elementK) is true, return true.
        if (sameValueZero(o[k], searchElement)) {
          return true;
        }
        // c. Increase k by 1.
        k++;
      }

      // 8. Return false
      return false;
    }
  });
}

// String.prototype.includes as on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
if (!String.prototype.includes) {
  String.prototype.includes = function(search, start) {
    'use strict';

    if (search instanceof RegExp) {
      throw TypeError('first argument must not be a RegExp');
    }
    if (start === undefined) { start = 0; }
    return this.indexOf(search, start) !== -1;
  };
}
(function($, w){
	var O2config = w.O2config || {};

	var defaults = {
		language: 'cs',
		lang: {
			sysmsgErrorLink: 'detail chyby',
			sysmsgHeading:   'Detail chyby',
			sysmsgCopyBtn:   'Zkopírovat do schránky',
			sysmsgReportBtn: 'Nahlásit chybu',
			sysmsgReportUrl: 'http://www.o2.cz/',
			sysmsg400Error:  'Chyba 400 ve widgetu sysmsg.',
			sysmsg404Error:  'Chyba 404 ve widgetu sysmsg.',
			appErrorMsg:     'V aplikaci došlo k chybě. Vyzkoušejte zopakovat akci později.'
		},
		getInformationMessagesURL: undefined,
		getInformationMessagesCreds: undefined,
		getInformationMessagesScopeId: undefined,
		getInformationMessagesLanguage: undefined
	};

	$.extend(true, defaults, O2config);
	defaults.templates = {}; // Není definovatelné uživatelem.
	w.O2config = defaults;
})(jQuery, window);
O2config.templates.field = {"addtplPreview":"<div class=\"o2-indent\"><div class=\"o2-box\"><div class=\"o2-box__container\"><div class=\"o2-box__inner\"><div class=\"o2-box__content\"><span class=\"o2-loader\"><span class=\"o2-loader__element\"></span><span class=\"o2-loader__text\">{constant}</span></span></div></div></div></div></div>","addfilePreview":"<li class=\"o2-list__item\"><span class=\"o2-list__item-content\"><span class=\"o2-loader\"><span class=\"o2-loader__element\"></span><span class=\"o2-loader__text\">{constant} {value}</span></span></span></li>","simplelistAdd":"<li class=\"o2-list__item\"><span class=\"o2-list__item-content\"><input type=\"hidden\" name=\"{{options.hiddenName}}\" value=\"{{#arrays}}{{#simpleListVal}}{{.}}{{^last}}{{options.joiner}}{{/last}}{{/simpleListVal}}{{/arrays}}\">{{#arrays}}{{#simpleListVal}}{{.}}{{^last}}{{options.joiner}}{{/last}}{{/simpleListVal}}{{/arrays}}</span><a class=\"o2-btn o2-btn--small o2-btn--transparent o2-btn--icon js-field-remove\"><span class=\"o2-icon o2-icon--cross\"></span><span class=\"o2-btn__text\"></span></a></li>","dialogSimplelistAdd":"{{#arrays}}{{#simpleListVal}}<li class=\"o2-list__item\"><span class=\"o2-list__item-content\"><input type=\"hidden\" name=\"{{options.hiddenName}}\" value=\"{{.}}\">{{.}}</span><a class=\"o2-btn o2-btn--small o2-btn--transparent o2-btn--icon js-field-remove\"><span class=\"o2-icon o2-icon--cross\"></span><span class=\"o2-btn__text\"></span></a></li>{{/simpleListVal}}{{/arrays}}"};
O2config.templates.sysmsg = {"mustacheItem":"<div class=\"o2-popup-message__item o2-popup-message__item--{{ severity }}{{#isInternal}} js-internal{{/isInternal}} js-message-container\"><div class=\"o2-flag\"><div class=\"o2-flag__pane o2-flag__pane--indent\"><span class=\"o2-icon o2-icon--{{ icon }}\"></span></div><div class=\"o2-flag__content\"><div class=\"o2-indent\">{{{ content }}}</div>{{#contentInternal}}<div class=\"o2-indent js-internal\"><div class=\"o2-pane o2-pane--internal\"><div class=\"o2-typo__color--internal\">{{{ contentInternal }}}</div></div></div>{{/contentInternal}}</div></div>{{#showClose}}<div class=\"o2-popup-message__close\"><a href=\"#\" class=\"o2-btn o2-btn--small o2-btn--icon o2-btn--transparent js-remove\" data-remove-profile=\"sysmessage\"><span class=\"o2-icon o2-icon--cross o2-icon--color-white\"></span></a></div>{{/showClose}}{{#timeoutMs}}<a href=\"#\" class=\"js-remove js-autorun\" data-remove-profile=\"sysmessage\" data-autorun-timeout=\"{{ timeoutMs }}\"></a>{{/timeoutMs}}{{#stacktrace}}{{> stacktraceModal }}{{/stacktrace}}</div>","mustacheModal":"<div class=\"o2-modal o2-modal--lg o2-modal--content-left mfp-hide\" id=\"{{ stacktraceHash }}\"><div class=\"o2-modal__header\"><h2 class=\"o2-modal__heading\">{{ lang.sysmsgHeading }}</h2></div><div class=\"o2-modal__body\"><div class=\"o2-section\"><div class=\"o2-control__wrapper\"><div class=\"o2-control__inner-container\"><textarea id=\"o2-2-46-5\" name=\"o2-2-46-5\" class=\"o2-control__textarea o2-control--full-width\" rows=\"12\">{{ stacktrace }}</textarea></div></div></div><!-- end o2-section --><div class=\"o2-section o2-modal--left\"><div class=\"o2-g o2-g--separate-rows o2-g--indent\"><div class=\"o2-g__1-1 o2-g__md-16-24\"><a href=\"#\" class=\"o2-btn o2-btn--primary js-clipboard\" data-clipboard-source=\"#o2-2-46-5\"><span class=\"o2-btn__text\">{{ lang.sysmsgCopyBtn }}</span></a></div><div class=\"o2-g__1-1 o2-g__md-8-24 o2-typo__align--right\"><a href=\"{{ lang.sysmsgReportUrl }}\" class=\" o2-btn o2-btn--transparent\"><span class=\"o2-icon o2-icon--megaphone-fill o2-icon--indent-right\"></span><span class=\"o2-btn__text\">{{ lang.sysmsgReportBtn }}</span></a></div></div></div><!-- end o2-section --></div><div class=\"o2-modal__close\"><button class=\"o2-btn o2-btn--transparent o2-btn--icon js-modal-close\"><span class=\"o2-icon o2-icon--cross\"></span></button></div></div>"};
jQuery.fn.scrollParent = function() {
	var overflowRegex = /(auto|scroll)/,
	position = this.css( "position" ),
	excludeStaticParent = position === "absolute",
	scrollParent = this.parents().filter( function() {
		var parent = $( this );
		if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
			return false;
		}
		var overflowState = parent.css(["overflow", "overflowX", "overflowY"]);
		return (overflowRegex).test( overflowState.overflow + overflowState.overflowX + overflowState.overflowY );
	}).eq( 0 );

	return position === "fixed" || !scrollParent.length ? $( this[ 0 ].ownerDocument || document ) : scrollParent;
};
/**
* jquery-match-height 0.7.2 by @liabru
* http://brm.io/jquery-match-height/
* License: MIT
*/

;(function(factory) { // eslint-disable-line no-extra-semi
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery'], factory);
    } else if (typeof module !== 'undefined' && module.exports) {
        // CommonJS
        module.exports = factory(require('jquery'));
    } else {
        // Global
        factory(jQuery);
    }
})(function($) {
    /*
    *  internal
    */

    var _previousResizeWidth = -1,
        _updateTimeout = -1;

    /*
    *  _parse
    *  value parse utility function
    */

    var _parse = function(value) {
        // parse value and convert NaN to 0
        return parseFloat(value) || 0;
    };

    /*
    *  _rows
    *  utility function returns array of jQuery selections representing each row
    *  (as displayed after float wrapping applied by browser)
    */

    var _rows = function(elements) {
        var tolerance = 1,
            $elements = $(elements),
            lastTop = null,
            rows = [];

        // group elements by their top position
        $elements.each(function(){
            var $that = $(this),
                top = $that.offset().top - _parse($that.css('margin-top')),
                lastRow = rows.length > 0 ? rows[rows.length - 1] : null;

            if (lastRow === null) {
                // first item on the row, so just push it
                rows.push($that);
            } else {
                // if the row top is the same, add to the row group
                if (Math.floor(Math.abs(lastTop - top)) <= tolerance) {
                    rows[rows.length - 1] = lastRow.add($that);
                } else {
                    // otherwise start a new row group
                    rows.push($that);
                }
            }

            // keep track of the last row top
            lastTop = top;
        });

        return rows;
    };

    /*
    *  _parseOptions
    *  handle plugin options
    */

    var _parseOptions = function(options) {
        var opts = {
            byRow: true,
            property: 'height',
            target: null,
            remove: false
        };

        if (typeof options === 'object') {
            return $.extend(opts, options);
        }

        if (typeof options === 'boolean') {
            opts.byRow = options;
        } else if (options === 'remove') {
            opts.remove = true;
        }

        return opts;
    };

    /*
    *  matchHeight
    *  plugin definition
    */

    var matchHeight = $.fn.matchHeight = function(options) {
        var opts = _parseOptions(options);

        // handle remove
        if (opts.remove) {
            var that = this;

            // remove fixed height from all selected elements
            this.css(opts.property, '');

            // remove selected elements from all groups
            $.each(matchHeight._groups, function(key, group) {
                group.elements = group.elements.not(that);
            });

            // TODO: cleanup empty groups

            return this;
        }

        if (this.length <= 1 && !opts.target) {
            return this;
        }

        // keep track of this group so we can re-apply later on load and resize events
        matchHeight._groups.push({
            elements: this,
            options: opts
        });

        // match each element's height to the tallest element in the selection
        matchHeight._apply(this, opts);

        return this;
    };

    /*
    *  plugin global options
    */

    matchHeight.version = '0.7.2';
    matchHeight._groups = [];
    matchHeight._throttle = 80;
    matchHeight._maintainScroll = false;
    matchHeight._beforeUpdate = null;
    matchHeight._afterUpdate = null;
    matchHeight._rows = _rows;
    matchHeight._parse = _parse;
    matchHeight._parseOptions = _parseOptions;

    /*
    *  matchHeight._apply
    *  apply matchHeight to given elements
    */

    matchHeight._apply = function(elements, options) {
        var opts = _parseOptions(options),
            $elements = $(elements),
            rows = [$elements];

        // take note of scroll position
        var scrollTop = $(window).scrollTop(),
            htmlHeight = $('html').outerHeight(true);

        // get hidden parents
        var $hiddenParents = $elements.parents().filter(':hidden');

        // cache the original inline style
        $hiddenParents.each(function() {
            var $that = $(this);
            $that.data('style-cache', $that.attr('style'));
        });

        // temporarily must force hidden parents visible
        $hiddenParents.css('display', 'block');

        // get rows if using byRow, otherwise assume one row
        if (opts.byRow && !opts.target) {

            // must first force an arbitrary equal height so floating elements break evenly
            $elements.each(function() {
                var $that = $(this),
                    display = $that.css('display');

                // temporarily force a usable display value
                if (display !== 'inline-block' && display !== 'flex' && display !== 'inline-flex') {
                    display = 'block';
                }

                // cache the original inline style
                $that.data('style-cache', $that.attr('style'));

                $that.css({
                    'display': display,
                    'padding-top': '0',
                    'padding-bottom': '0',
                    'margin-top': '0',
                    'margin-bottom': '0',
                    'border-top-width': '0',
                    'border-bottom-width': '0',
                    'height': '100px',
                    'overflow': 'hidden'
                });
            });

            // get the array of rows (based on element top position)
            rows = _rows($elements);

            // revert original inline styles
            $elements.each(function() {
                var $that = $(this);
                $that.attr('style', $that.data('style-cache') || '');
            });
        }

        $.each(rows, function(key, row) {
            var $row = $(row),
                targetHeight = 0;

            if (!opts.target) {
                // skip apply to rows with only one item
                if (opts.byRow && $row.length <= 1) {
                    $row.css(opts.property, '');
                    return;
                }

                // iterate the row and find the max height
                $row.each(function(){
                    var $that = $(this),
                        style = $that.attr('style'),
                        display = $that.css('display');

                    // temporarily force a usable display value
                    if (display !== 'inline-block' && display !== 'flex' && display !== 'inline-flex') {
                        display = 'block';
                    }

                    // ensure we get the correct actual height (and not a previously set height value)
                    var css = { 'display': display };
                    css[opts.property] = '';
                    $that.css(css);

                    // find the max height (including padding, but not margin)
                    if ($that.outerHeight(false) > targetHeight) {
                        targetHeight = $that.outerHeight(false);
                    }

                    // revert styles
                    if (style) {
                        $that.attr('style', style);
                    } else {
                        $that.css('display', '');
                    }
                });
            } else {
                // if target set, use the height of the target element
                targetHeight = opts.target.outerHeight(false);
            }

            // iterate the row and apply the height to all elements
            $row.each(function(){
                var $that = $(this),
                    verticalPadding = 0;

                // don't apply to a target
                if (opts.target && $that.is(opts.target)) {
                    return;
                }

                // handle padding and border correctly (required when not using border-box)
                if ($that.css('box-sizing') !== 'border-box') {
                    verticalPadding += _parse($that.css('border-top-width')) + _parse($that.css('border-bottom-width'));
                    verticalPadding += _parse($that.css('padding-top')) + _parse($that.css('padding-bottom'));
                }

                // set the height (accounting for padding and border)
                $that.css(opts.property, (targetHeight - verticalPadding) + 'px');
            });
        });

        // revert hidden parents
        $hiddenParents.each(function() {
            var $that = $(this);
            $that.attr('style', $that.data('style-cache') || null);
        });

        // restore scroll position if enabled
        if (matchHeight._maintainScroll) {
            $(window).scrollTop((scrollTop / htmlHeight) * $('html').outerHeight(true));
        }

        return this;
    };

    /*
    *  matchHeight._applyDataApi
    *  applies matchHeight to all elements with a data-match-height attribute
    */

    matchHeight._applyDataApi = function() {
        var groups = {};

        // generate groups by their groupId set by elements using data-match-height
        $('[data-match-height], [data-mh]').each(function() {
            var $this = $(this),
                groupId = $this.attr('data-mh') || $this.attr('data-match-height');

            if (groupId in groups) {
                groups[groupId] = groups[groupId].add($this);
            } else {
                groups[groupId] = $this;
            }
        });

        // apply matchHeight to each group
        $.each(groups, function() {
            this.matchHeight(true);
        });
    };

    /*
    *  matchHeight._update
    *  updates matchHeight on all current groups with their correct options
    */

    var _update = function(event) {
        if (matchHeight._beforeUpdate) {
            matchHeight._beforeUpdate(event, matchHeight._groups);
        }

        $.each(matchHeight._groups, function() {
            matchHeight._apply(this.elements, this.options);
        });

        if (matchHeight._afterUpdate) {
            matchHeight._afterUpdate(event, matchHeight._groups);
        }
    };

    matchHeight._update = function(throttle, event) {
        // prevent update if fired from a resize event
        // where the viewport width hasn't actually changed
        // fixes an event looping bug in IE8
        if (event && event.type === 'resize') {
            var windowWidth = $(window).width();
            if (windowWidth === _previousResizeWidth) {
                return;
            }
            _previousResizeWidth = windowWidth;
        }

        // throttle updates
        if (!throttle) {
            _update(event);
        } else if (_updateTimeout === -1) {
            _updateTimeout = setTimeout(function() {
                _update(event);
                _updateTimeout = -1;
            }, matchHeight._throttle);
        }
    };

    /*
    *  bind events
    */

    // apply on DOM ready event
    $(matchHeight._applyDataApi);

    // use on or bind where supported
    var on = $.fn.on ? 'on' : 'bind';

    // update heights on load and resize events
    $(window)[on]('load', function(event) {
        matchHeight._update(false, event);
    });

    // throttled update heights on resize events
    $(window)[on]('resize orientationchange', function(event) {
        matchHeight._update(true, event);
    });

});

/*! Magnific Popup - v1.1.0 - 2016-02-20
* http://dimsemenov.com/plugins/magnific-popup/
* Copyright (c) 2016 Dmitry Semenov; */
;(function (factory) { 
if (typeof define === 'function' && define.amd) { 
 // AMD. Register as an anonymous module. 
 define(['jquery'], factory); 
 } else if (typeof exports === 'object') { 
 // Node/CommonJS 
 factory(require('jquery')); 
 } else { 
 // Browser globals 
 factory(window.jQuery || window.Zepto); 
 } 
 }(function($) { 

/*>>core*/
/**
 * 
 * Magnific Popup Core JS file
 * 
 */


/**
 * Private static constants
 */
var CLOSE_EVENT = 'Close',
	BEFORE_CLOSE_EVENT = 'BeforeClose',
	AFTER_CLOSE_EVENT = 'AfterClose',
	BEFORE_APPEND_EVENT = 'BeforeAppend',
	MARKUP_PARSE_EVENT = 'MarkupParse',
	OPEN_EVENT = 'Open',
	CHANGE_EVENT = 'Change',
	NS = 'mfp',
	EVENT_NS = '.' + NS,
	READY_CLASS = 'mfp-ready',
	REMOVING_CLASS = 'mfp-removing',
	PREVENT_CLOSE_CLASS = 'mfp-prevent-close';


/**
 * Private vars 
 */
/*jshint -W079 */
var mfp, // As we have only one instance of MagnificPopup object, we define it locally to not to use 'this'
	MagnificPopup = function(){},
	_isJQ = !!(window.jQuery),
	_prevStatus,
	_window = $(window),
	_document,
	_prevContentType,
	_wrapClasses,
	_currPopupType;


/**
 * Private functions
 */
var _mfpOn = function(name, f) {
		mfp.ev.on(NS + name + EVENT_NS, f);
	},
	_getEl = function(className, appendTo, html, raw) {
		var el = document.createElement('div');
		el.className = 'mfp-'+className;
		if(html) {
			el.innerHTML = html;
		}
		if(!raw) {
			el = $(el);
			if(appendTo) {
				el.appendTo(appendTo);
			}
		} else if(appendTo) {
			appendTo.appendChild(el);
		}
		return el;
	},
	_mfpTrigger = function(e, data) {
		mfp.ev.triggerHandler(NS + e, data);

		if(mfp.st.callbacks) {
			// converts "mfpEventName" to "eventName" callback and triggers it if it's present
			e = e.charAt(0).toLowerCase() + e.slice(1);
			if(mfp.st.callbacks[e]) {
				mfp.st.callbacks[e].apply(mfp, $.isArray(data) ? data : [data]);
			}
		}
	},
	_getCloseBtn = function(type) {
		if(type !== _currPopupType || !mfp.currTemplate.closeBtn) {
			mfp.currTemplate.closeBtn = $( mfp.st.closeMarkup.replace('%title%', mfp.st.tClose ) );
			_currPopupType = type;
		}
		return mfp.currTemplate.closeBtn;
	},
	// Initialize Magnific Popup only when called at least once
	_checkInstance = function() {
		if(!$.magnificPopup.instance) {
			/*jshint -W020 */
			mfp = new MagnificPopup();
			mfp.init();
			$.magnificPopup.instance = mfp;
		}
	},
	// CSS transition detection, http://stackoverflow.com/questions/7264899/detect-css-transitions-using-javascript-and-without-modernizr
	supportsTransitions = function() {
		var s = document.createElement('p').style, // 's' for style. better to create an element if body yet to exist
			v = ['ms','O','Moz','Webkit']; // 'v' for vendor

		if( s['transition'] !== undefined ) {
			return true; 
		}
			
		while( v.length ) {
			if( v.pop() + 'Transition' in s ) {
				return true;
			}
		}
				
		return false;
	};



/**
 * Public functions
 */
MagnificPopup.prototype = {

	constructor: MagnificPopup,

	/**
	 * Initializes Magnific Popup plugin. 
	 * This function is triggered only once when $.fn.magnificPopup or $.magnificPopup is executed
	 */
	init: function() {
		var appVersion = navigator.appVersion;
		mfp.isLowIE = mfp.isIE8 = document.all && !document.addEventListener;
		mfp.isAndroid = (/android/gi).test(appVersion);
		mfp.isIOS = (/iphone|ipad|ipod/gi).test(appVersion);
		mfp.supportsTransition = supportsTransitions();

		// We disable fixed positioned lightbox on devices that don't handle it nicely.
		// If you know a better way of detecting this - let me know.
		mfp.probablyMobile = (mfp.isAndroid || mfp.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent) );
		_document = $(document);

		mfp.popupsCache = {};
	},

	/**
	 * Opens popup
	 * @param  data [description]
	 */
	open: function(data) {

		var i;

		if(data.isObj === false) { 
			// convert jQuery collection to array to avoid conflicts later
			mfp.items = data.items.toArray();

			mfp.index = 0;
			var items = data.items,
				item;
			for(i = 0; i < items.length; i++) {
				item = items[i];
				if(item.parsed) {
					item = item.el[0];
				}
				if(item === data.el[0]) {
					mfp.index = i;
					break;
				}
			}
		} else {
			mfp.items = $.isArray(data.items) ? data.items : [data.items];
			mfp.index = data.index || 0;
		}

		// if popup is already opened - we just update the content
		if(mfp.isOpen) {
			mfp.updateItemHTML();
			return;
		}
		
		mfp.types = []; 
		_wrapClasses = '';
		if(data.mainEl && data.mainEl.length) {
			mfp.ev = data.mainEl.eq(0);
		} else {
			mfp.ev = _document;
		}

		if(data.key) {
			if(!mfp.popupsCache[data.key]) {
				mfp.popupsCache[data.key] = {};
			}
			mfp.currTemplate = mfp.popupsCache[data.key];
		} else {
			mfp.currTemplate = {};
		}



		mfp.st = $.extend(true, {}, $.magnificPopup.defaults, data ); 
		mfp.fixedContentPos = mfp.st.fixedContentPos === 'auto' ? !mfp.probablyMobile : mfp.st.fixedContentPos;

		if(mfp.st.modal) {
			mfp.st.closeOnContentClick = false;
			mfp.st.closeOnBgClick = false;
			mfp.st.showCloseBtn = false;
			mfp.st.enableEscapeKey = false;
		}
		

		// Building markup
		// main containers are created only once
		if(!mfp.bgOverlay) {

			// Dark overlay
			mfp.bgOverlay = _getEl('bg').on('click'+EVENT_NS, function() {
				mfp.close();
			});

			mfp.wrap = _getEl('wrap').attr('tabindex', -1).on('click'+EVENT_NS, function(e) {
				if(mfp._checkIfClose(e.target)) {
					mfp.close();
				}
			});

			mfp.container = _getEl('container', mfp.wrap);
		}

		mfp.contentContainer = _getEl('content');
		if(mfp.st.preloader) {
			mfp.preloader = _getEl('preloader', mfp.container, mfp.st.tLoading);
		}


		// Initializing modules
		var modules = $.magnificPopup.modules;
		for(i = 0; i < modules.length; i++) {
			var n = modules[i];
			n = n.charAt(0).toUpperCase() + n.slice(1);
			mfp['init'+n].call(mfp);
		}
		_mfpTrigger('BeforeOpen');


		if(mfp.st.showCloseBtn) {
			// Close button
			if(!mfp.st.closeBtnInside) {
				mfp.wrap.append( _getCloseBtn() );
			} else {
				_mfpOn(MARKUP_PARSE_EVENT, function(e, template, values, item) {
					values.close_replaceWith = _getCloseBtn(item.type);
				});
				_wrapClasses += ' mfp-close-btn-in';
			}
		}

		if(mfp.st.alignTop) {
			_wrapClasses += ' mfp-align-top';
		}

	

		if(mfp.fixedContentPos) {
			mfp.wrap.css({
				overflow: mfp.st.overflowY,
				overflowX: 'hidden',
				overflowY: mfp.st.overflowY
			});
		} else {
			mfp.wrap.css({ 
				top: _window.scrollTop(),
				position: 'absolute'
			});
		}
		if( mfp.st.fixedBgPos === false || (mfp.st.fixedBgPos === 'auto' && !mfp.fixedContentPos) ) {
			mfp.bgOverlay.css({
				height: _document.height(),
				position: 'absolute'
			});
		}

		

		if(mfp.st.enableEscapeKey) {
			// Close on ESC key
			_document.on('keyup' + EVENT_NS, function(e) {
				if(e.keyCode === 27) {
					mfp.close();
				}
			});
		}

		_window.on('resize' + EVENT_NS, function() {
			mfp.updateSize();
		});


		if(!mfp.st.closeOnContentClick) {
			_wrapClasses += ' mfp-auto-cursor';
		}
		
		if(_wrapClasses)
			mfp.wrap.addClass(_wrapClasses);


		// this triggers recalculation of layout, so we get it once to not to trigger twice
		var windowHeight = mfp.wH = _window.height();

		
		var windowStyles = {};

		if( mfp.fixedContentPos ) {
            if(mfp._hasScrollBar(windowHeight)){
                var s = mfp._getScrollbarSize();
                if(s) {
                    windowStyles.marginRight = s;
                }
            }
        }

		if(mfp.fixedContentPos) {
			if(!mfp.isIE7) {
				windowStyles.overflow = 'hidden';
			} else {
				// ie7 double-scroll bug
				$('body, html').css('overflow', 'hidden');
			}
		}

		
		
		var classesToadd = mfp.st.mainClass;
		if(mfp.isIE7) {
			classesToadd += ' mfp-ie7';
		}
		if(classesToadd) {
			mfp._addClassToMFP( classesToadd );
		}

		// add content
		mfp.updateItemHTML();

		_mfpTrigger('BuildControls');

		// remove scrollbar, add margin e.t.c
		$('html').css(windowStyles);
		
		// add everything to DOM
		mfp.bgOverlay.add(mfp.wrap).prependTo( mfp.st.prependTo || $(document.body) );

		// Save last focused element
		mfp._lastFocusedEl = document.activeElement;
		
		// Wait for next cycle to allow CSS transition
		setTimeout(function() {
			
			if(mfp.content) {
				mfp._addClassToMFP(READY_CLASS);
				mfp._setFocus();
			} else {
				// if content is not defined (not loaded e.t.c) we add class only for BG
				mfp.bgOverlay.addClass(READY_CLASS);
			}
			
			// Trap the focus in popup
			_document.on('focusin' + EVENT_NS, mfp._onFocusIn);

		}, 16);

		mfp.isOpen = true;
		mfp.updateSize(windowHeight);
		_mfpTrigger(OPEN_EVENT);

		return data;
	},

	/**
	 * Closes the popup
	 */
	close: function() {
		if(!mfp.isOpen) return;
		_mfpTrigger(BEFORE_CLOSE_EVENT);

		mfp.isOpen = false;
		// for CSS3 animation
		if(mfp.st.removalDelay && !mfp.isLowIE && mfp.supportsTransition )  {
			mfp._addClassToMFP(REMOVING_CLASS);
			setTimeout(function() {
				mfp._close();
			}, mfp.st.removalDelay);
		} else {
			mfp._close();
		}
	},

	/**
	 * Helper for close() function
	 */
	_close: function() {
		_mfpTrigger(CLOSE_EVENT);

		var classesToRemove = REMOVING_CLASS + ' ' + READY_CLASS + ' ';

		mfp.bgOverlay.detach();
		mfp.wrap.detach();
		mfp.container.empty();

		if(mfp.st.mainClass) {
			classesToRemove += mfp.st.mainClass + ' ';
		}

		mfp._removeClassFromMFP(classesToRemove);

		if(mfp.fixedContentPos) {
			var windowStyles = {marginRight: ''};
			if(mfp.isIE7) {
				$('body, html').css('overflow', '');
			} else {
				windowStyles.overflow = '';
			}
			$('html').css(windowStyles);
		}
		
		_document.off('keyup' + EVENT_NS + ' focusin' + EVENT_NS);
		mfp.ev.off(EVENT_NS);

		// clean up DOM elements that aren't removed
		mfp.wrap.attr('class', 'mfp-wrap').removeAttr('style');
		mfp.bgOverlay.attr('class', 'mfp-bg');
		mfp.container.attr('class', 'mfp-container');

		// remove close button from target element
		if(mfp.st.showCloseBtn &&
		(!mfp.st.closeBtnInside || mfp.currTemplate[mfp.currItem.type] === true)) {
			if(mfp.currTemplate.closeBtn)
				mfp.currTemplate.closeBtn.detach();
		}


		if(mfp.st.autoFocusLast && mfp._lastFocusedEl) {
			$(mfp._lastFocusedEl).focus(); // put tab focus back
		}
		mfp.currItem = null;	
		mfp.content = null;
		mfp.currTemplate = null;
		mfp.prevHeight = 0;

		_mfpTrigger(AFTER_CLOSE_EVENT);
	},
	
	updateSize: function(winHeight) {

		if(mfp.isIOS) {
			// fixes iOS nav bars https://github.com/dimsemenov/Magnific-Popup/issues/2
			var zoomLevel = document.documentElement.clientWidth / window.innerWidth;
			var height = window.innerHeight * zoomLevel;
			mfp.wrap.css('height', height);
			mfp.wH = height;
		} else {
			mfp.wH = winHeight || _window.height();
		}
		// Fixes #84: popup incorrectly positioned with position:relative on body
		if(!mfp.fixedContentPos) {
			mfp.wrap.css('height', mfp.wH);
		}

		_mfpTrigger('Resize');

	},

	/**
	 * Set content of popup based on current index
	 */
	updateItemHTML: function() {
		var item = mfp.items[mfp.index];

		// Detach and perform modifications
		mfp.contentContainer.detach();

		if(mfp.content)
			mfp.content.detach();

		if(!item.parsed) {
			item = mfp.parseEl( mfp.index );
		}

		var type = item.type;

		_mfpTrigger('BeforeChange', [mfp.currItem ? mfp.currItem.type : '', type]);
		// BeforeChange event works like so:
		// _mfpOn('BeforeChange', function(e, prevType, newType) { });

		mfp.currItem = item;

		if(!mfp.currTemplate[type]) {
			var markup = mfp.st[type] ? mfp.st[type].markup : false;

			// allows to modify markup
			_mfpTrigger('FirstMarkupParse', markup);

			if(markup) {
				mfp.currTemplate[type] = $(markup);
			} else {
				// if there is no markup found we just define that template is parsed
				mfp.currTemplate[type] = true;
			}
		}

		if(_prevContentType && _prevContentType !== item.type) {
			mfp.container.removeClass('mfp-'+_prevContentType+'-holder');
		}

		var newContent = mfp['get' + type.charAt(0).toUpperCase() + type.slice(1)](item, mfp.currTemplate[type]);
		mfp.appendContent(newContent, type);

		item.preloaded = true;

		_mfpTrigger(CHANGE_EVENT, item);
		_prevContentType = item.type;

		// Append container back after its content changed
		mfp.container.prepend(mfp.contentContainer);

		_mfpTrigger('AfterChange');
	},


	/**
	 * Set HTML content of popup
	 */
	appendContent: function(newContent, type) {
		mfp.content = newContent;

		if(newContent) {
			if(mfp.st.showCloseBtn && mfp.st.closeBtnInside &&
				mfp.currTemplate[type] === true) {
				// if there is no markup, we just append close button element inside
				if(!mfp.content.find('.mfp-close').length) {
					mfp.content.append(_getCloseBtn());
				}
			} else {
				mfp.content = newContent;
			}
		} else {
			mfp.content = '';
		}

		_mfpTrigger(BEFORE_APPEND_EVENT);
		mfp.container.addClass('mfp-'+type+'-holder');

		mfp.contentContainer.append(mfp.content);
	},


	/**
	 * Creates Magnific Popup data object based on given data
	 * @param  {int} index Index of item to parse
	 */
	parseEl: function(index) {
		var item = mfp.items[index],
			type;

		if(item.tagName) {
			item = { el: $(item) };
		} else {
			type = item.type;
			item = { data: item, src: item.src };
		}

		if(item.el) {
			var types = mfp.types;

			// check for 'mfp-TYPE' class
			for(var i = 0; i < types.length; i++) {
				if( item.el.hasClass('mfp-'+types[i]) ) {
					type = types[i];
					break;
				}
			}

			item.src = item.el.attr('data-mfp-src');
			if(!item.src) {
				item.src = item.el.attr('href');
			}
		}

		item.type = type || mfp.st.type || 'inline';
		item.index = index;
		item.parsed = true;
		mfp.items[index] = item;
		_mfpTrigger('ElementParse', item);

		return mfp.items[index];
	},


	/**
	 * Initializes single popup or a group of popups
	 */
	addGroup: function(el, options) {
		var eHandler = function(e) {
			e.mfpEl = this;
			mfp._openClick(e, el, options);
		};

		if(!options) {
			options = {};
		}

		var eName = 'click.magnificPopup';
		options.mainEl = el;

		if(options.items) {
			options.isObj = true;
			el.off(eName).on(eName, eHandler);
		} else {
			options.isObj = false;
			if(options.delegate) {
				el.off(eName).on(eName, options.delegate , eHandler);
			} else {
				options.items = el;
				el.off(eName).on(eName, eHandler);
			}
		}
	},
	_openClick: function(e, el, options) {
		var midClick = options.midClick !== undefined ? options.midClick : $.magnificPopup.defaults.midClick;


		if(!midClick && ( e.which === 2 || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey ) ) {
			return;
		}

		var disableOn = options.disableOn !== undefined ? options.disableOn : $.magnificPopup.defaults.disableOn;

		if(disableOn) {
			if($.isFunction(disableOn)) {
				if( !disableOn.call(mfp) ) {
					return true;
				}
			} else { // else it's number
				if( _window.width() < disableOn ) {
					return true;
				}
			}
		}

		if(e.type) {
			e.preventDefault();

			// This will prevent popup from closing if element is inside and popup is already opened
			if(mfp.isOpen) {
				e.stopPropagation();
			}
		}

		options.el = $(e.mfpEl);
		if(options.delegate) {
			options.items = el.find(options.delegate);
		}
		mfp.open(options);
	},


	/**
	 * Updates text on preloader
	 */
	updateStatus: function(status, text) {

		if(mfp.preloader) {
			if(_prevStatus !== status) {
				mfp.container.removeClass('mfp-s-'+_prevStatus);
			}

			if(!text && status === 'loading') {
				text = mfp.st.tLoading;
			}

			var data = {
				status: status,
				text: text
			};
			// allows to modify status
			_mfpTrigger('UpdateStatus', data);

			status = data.status;
			text = data.text;

			mfp.preloader.html(text);

			mfp.preloader.find('a').on('click', function(e) {
				e.stopImmediatePropagation();
			});

			mfp.container.addClass('mfp-s-'+status);
			_prevStatus = status;
		}
	},


	/*
		"Private" helpers that aren't private at all
	 */
	// Check to close popup or not
	// "target" is an element that was clicked
	_checkIfClose: function(target) {

		if($(target).hasClass(PREVENT_CLOSE_CLASS)) {
			return;
		}

		var closeOnContent = mfp.st.closeOnContentClick;
		var closeOnBg = mfp.st.closeOnBgClick;

		if(closeOnContent && closeOnBg) {
			return true;
		} else {

			// We close the popup if click is on close button or on preloader. Or if there is no content.
			if(!mfp.content || $(target).hasClass('mfp-close') || (mfp.preloader && target === mfp.preloader[0]) ) {
				return true;
			}

			// if click is outside the content
			if(  (target !== mfp.content[0] && !$.contains(mfp.content[0], target))  ) {
				if(closeOnBg) {
					// last check, if the clicked element is in DOM, (in case it's removed onclick)
					if( $.contains(document, target) ) {
						return true;
					}
				}
			} else if(closeOnContent) {
				return true;
			}

		}
		return false;
	},
	_addClassToMFP: function(cName) {
		mfp.bgOverlay.addClass(cName);
		mfp.wrap.addClass(cName);
	},
	_removeClassFromMFP: function(cName) {
		this.bgOverlay.removeClass(cName);
		mfp.wrap.removeClass(cName);
	},
	_hasScrollBar: function(winHeight) {
		return (  (mfp.isIE7 ? _document.height() : document.body.scrollHeight) > (winHeight || _window.height()) );
	},
	_setFocus: function() {
		(mfp.st.focus ? mfp.content.find(mfp.st.focus).eq(0) : mfp.wrap).focus();
	},
	_onFocusIn: function(e) {
		if( e.target !== mfp.wrap[0] && !$.contains(mfp.wrap[0], e.target) ) {
			mfp._setFocus();
			return false;
		}
	},
	_parseMarkup: function(template, values, item) {
		var arr;
		if(item.data) {
			values = $.extend(item.data, values);
		}
		_mfpTrigger(MARKUP_PARSE_EVENT, [template, values, item] );

		$.each(values, function(key, value) {
			if(value === undefined || value === false) {
				return true;
			}
			arr = key.split('_');
			if(arr.length > 1) {
				var el = template.find(EVENT_NS + '-'+arr[0]);

				if(el.length > 0) {
					var attr = arr[1];
					if(attr === 'replaceWith') {
						if(el[0] !== value[0]) {
							el.replaceWith(value);
						}
					} else if(attr === 'img') {
						if(el.is('img')) {
							el.attr('src', value);
						} else {
							el.replaceWith( $('<img>').attr('src', value).attr('class', el.attr('class')) );
						}
					} else {
						el.attr(arr[1], value);
					}
				}

			} else {
				template.find(EVENT_NS + '-'+key).html(value);
			}
		});
	},

	_getScrollbarSize: function() {
		// thx David
		if(mfp.scrollbarSize === undefined) {
			var scrollDiv = document.createElement("div");
			scrollDiv.style.cssText = 'width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;';
			document.body.appendChild(scrollDiv);
			mfp.scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
			document.body.removeChild(scrollDiv);
		}
		return mfp.scrollbarSize;
	}

}; /* MagnificPopup core prototype end */




/**
 * Public static functions
 */
$.magnificPopup = {
	instance: null,
	proto: MagnificPopup.prototype,
	modules: [],

	open: function(options, index) {
		_checkInstance();

		if(!options) {
			options = {};
		} else {
			options = $.extend(true, {}, options);
		}

		options.isObj = true;
		options.index = index || 0;
		return this.instance.open(options);
	},

	close: function() {
		return $.magnificPopup.instance && $.magnificPopup.instance.close();
	},

	registerModule: function(name, module) {
		if(module.options) {
			$.magnificPopup.defaults[name] = module.options;
		}
		$.extend(this.proto, module.proto);
		this.modules.push(name);
	},

	defaults: {

		// Info about options is in docs:
		// http://dimsemenov.com/plugins/magnific-popup/documentation.html#options

		disableOn: 0,

		key: null,

		midClick: false,

		mainClass: '',

		preloader: true,

		focus: '', // CSS selector of input to focus after popup is opened

		closeOnContentClick: false,

		closeOnBgClick: true,

		closeBtnInside: true,

		showCloseBtn: true,

		enableEscapeKey: true,

		modal: false,

		alignTop: false,

		removalDelay: 0,

		prependTo: null,

		fixedContentPos: 'auto',

		fixedBgPos: 'auto',

		overflowY: 'auto',

		closeMarkup: '<button title="%title%" type="button" class="mfp-close">&#215;</button>',

		tClose: 'Close (Esc)',

		tLoading: 'Loading...',

		autoFocusLast: true

	}
};



$.fn.magnificPopup = function(options) {
	_checkInstance();

	var jqEl = $(this);

	// We call some API method of first param is a string
	if (typeof options === "string" ) {

		if(options === 'open') {
			var items,
				itemOpts = _isJQ ? jqEl.data('magnificPopup') : jqEl[0].magnificPopup,
				index = parseInt(arguments[1], 10) || 0;

			if(itemOpts.items) {
				items = itemOpts.items[index];
			} else {
				items = jqEl;
				if(itemOpts.delegate) {
					items = items.find(itemOpts.delegate);
				}
				items = items.eq( index );
			}
			mfp._openClick({mfpEl:items}, jqEl, itemOpts);
		} else {
			if(mfp.isOpen)
				mfp[options].apply(mfp, Array.prototype.slice.call(arguments, 1));
		}

	} else {
		// clone options obj
		options = $.extend(true, {}, options);

		/*
		 * As Zepto doesn't support .data() method for objects
		 * and it works only in normal browsers
		 * we assign "options" object directly to the DOM element. FTW!
		 */
		if(_isJQ) {
			jqEl.data('magnificPopup', options);
		} else {
			jqEl[0].magnificPopup = options;
		}

		mfp.addGroup(jqEl, options);

	}
	return jqEl;
};

/*>>core*/

/*>>inline*/

var INLINE_NS = 'inline',
	_hiddenClass,
	_inlinePlaceholder,
	_lastInlineElement,
	_putInlineElementsBack = function() {
		if(_lastInlineElement) {
			_inlinePlaceholder.after( _lastInlineElement.addClass(_hiddenClass) ).detach();
			_lastInlineElement = null;
		}
	};

$.magnificPopup.registerModule(INLINE_NS, {
	options: {
		hiddenClass: 'hide', // will be appended with `mfp-` prefix
		markup: '',
		tNotFound: 'Content not found'
	},
	proto: {

		initInline: function() {
			mfp.types.push(INLINE_NS);

			_mfpOn(CLOSE_EVENT+'.'+INLINE_NS, function() {
				_putInlineElementsBack();
			});
		},

		getInline: function(item, template) {

			_putInlineElementsBack();

			if(item.src) {
				var inlineSt = mfp.st.inline,
					el = $(item.src);

				if(el.length) {

					// If target element has parent - we replace it with placeholder and put it back after popup is closed
					var parent = el[0].parentNode;
					if(parent && parent.tagName) {
						if(!_inlinePlaceholder) {
							_hiddenClass = inlineSt.hiddenClass;
							_inlinePlaceholder = _getEl(_hiddenClass);
							_hiddenClass = 'mfp-'+_hiddenClass;
						}
						// replace target inline element with placeholder
						_lastInlineElement = el.after(_inlinePlaceholder).detach().removeClass(_hiddenClass);
					}

					mfp.updateStatus('ready');
				} else {
					mfp.updateStatus('error', inlineSt.tNotFound);
					el = $('<div>');
				}

				item.inlineElement = el;
				return el;
			}

			mfp.updateStatus('ready');
			mfp._parseMarkup(template, {}, item);
			return template;
		}
	}
});

/*>>inline*/

/*>>ajax*/
var AJAX_NS = 'ajax',
	_ajaxCur,
	_removeAjaxCursor = function() {
		if(_ajaxCur) {
			$(document.body).removeClass(_ajaxCur);
		}
	},
	_destroyAjaxRequest = function() {
		_removeAjaxCursor();
		if(mfp.req) {
			mfp.req.abort();
		}
	};

$.magnificPopup.registerModule(AJAX_NS, {

	options: {
		settings: null,
		cursor: 'mfp-ajax-cur',
		tError: '<a href="%url%">The content</a> could not be loaded.'
	},

	proto: {
		initAjax: function() {
			mfp.types.push(AJAX_NS);
			_ajaxCur = mfp.st.ajax.cursor;

			_mfpOn(CLOSE_EVENT+'.'+AJAX_NS, _destroyAjaxRequest);
			_mfpOn('BeforeChange.' + AJAX_NS, _destroyAjaxRequest);
		},
		getAjax: function(item) {

			if(_ajaxCur) {
				$(document.body).addClass(_ajaxCur);
			}

			mfp.updateStatus('loading');

			var opts = $.extend({
				url: item.src,
				success: function(data, textStatus, jqXHR) {
					var temp = {
						data:data,
						xhr:jqXHR
					};

					_mfpTrigger('ParseAjax', temp);

					mfp.appendContent( $(temp.data), AJAX_NS );

					item.finished = true;

					_removeAjaxCursor();

					mfp._setFocus();

					setTimeout(function() {
						mfp.wrap.addClass(READY_CLASS);
					}, 16);

					mfp.updateStatus('ready');

					_mfpTrigger('AjaxContentAdded');
				},
				error: function() {
					_removeAjaxCursor();
					item.finished = item.loadError = true;
					mfp.updateStatus('error', mfp.st.ajax.tError.replace('%url%', item.src));
				}
			}, mfp.st.ajax.settings);

			mfp.req = $.ajax(opts);

			return '';
		}
	}
});

/*>>ajax*/

/*>>image*/
var _imgInterval,
	_getTitle = function(item) {
		if(item.data && item.data.title !== undefined)
			return item.data.title;

		var src = mfp.st.image.titleSrc;

		if(src) {
			if($.isFunction(src)) {
				return src.call(mfp, item);
			} else if(item.el) {
				return item.el.attr(src) || '';
			}
		}
		return '';
	};

$.magnificPopup.registerModule('image', {

	options: {
		markup: '<div class="mfp-figure">'+
					'<div class="mfp-close"></div>'+
					'<figure>'+
						'<div class="mfp-img"></div>'+
						'<figcaption>'+
							'<div class="mfp-bottom-bar">'+
								'<div class="mfp-title"></div>'+
								'<div class="mfp-counter"></div>'+
							'</div>'+
						'</figcaption>'+
					'</figure>'+
				'</div>',
		cursor: 'mfp-zoom-out-cur',
		titleSrc: 'title',
		verticalFit: true,
		tError: '<a href="%url%">The image</a> could not be loaded.'
	},

	proto: {
		initImage: function() {
			var imgSt = mfp.st.image,
				ns = '.image';

			mfp.types.push('image');

			_mfpOn(OPEN_EVENT+ns, function() {
				if(mfp.currItem.type === 'image' && imgSt.cursor) {
					$(document.body).addClass(imgSt.cursor);
				}
			});

			_mfpOn(CLOSE_EVENT+ns, function() {
				if(imgSt.cursor) {
					$(document.body).removeClass(imgSt.cursor);
				}
				_window.off('resize' + EVENT_NS);
			});

			_mfpOn('Resize'+ns, mfp.resizeImage);
			if(mfp.isLowIE) {
				_mfpOn('AfterChange', mfp.resizeImage);
			}
		},
		resizeImage: function() {
			var item = mfp.currItem;
			if(!item || !item.img) return;

			if(mfp.st.image.verticalFit) {
				var decr = 0;
				// fix box-sizing in ie7/8
				if(mfp.isLowIE) {
					decr = parseInt(item.img.css('padding-top'), 10) + parseInt(item.img.css('padding-bottom'),10);
				}
				item.img.css('max-height', mfp.wH-decr);
			}
		},
		_onImageHasSize: function(item) {
			if(item.img) {

				item.hasSize = true;

				if(_imgInterval) {
					clearInterval(_imgInterval);
				}

				item.isCheckingImgSize = false;

				_mfpTrigger('ImageHasSize', item);

				if(item.imgHidden) {
					if(mfp.content)
						mfp.content.removeClass('mfp-loading');

					item.imgHidden = false;
				}

			}
		},

		/**
		 * Function that loops until the image has size to display elements that rely on it asap
		 */
		findImageSize: function(item) {

			var counter = 0,
				img = item.img[0],
				mfpSetInterval = function(delay) {

					if(_imgInterval) {
						clearInterval(_imgInterval);
					}
					// decelerating interval that checks for size of an image
					_imgInterval = setInterval(function() {
						if(img.naturalWidth > 0) {
							mfp._onImageHasSize(item);
							return;
						}

						if(counter > 200) {
							clearInterval(_imgInterval);
						}

						counter++;
						if(counter === 3) {
							mfpSetInterval(10);
						} else if(counter === 40) {
							mfpSetInterval(50);
						} else if(counter === 100) {
							mfpSetInterval(500);
						}
					}, delay);
				};

			mfpSetInterval(1);
		},

		getImage: function(item, template) {

			var guard = 0,

				// image load complete handler
				onLoadComplete = function() {
					if(item) {
						if (item.img[0].complete) {
							item.img.off('.mfploader');

							if(item === mfp.currItem){
								mfp._onImageHasSize(item);

								mfp.updateStatus('ready');
							}

							item.hasSize = true;
							item.loaded = true;

							_mfpTrigger('ImageLoadComplete');

						}
						else {
							// if image complete check fails 200 times (20 sec), we assume that there was an error.
							guard++;
							if(guard < 200) {
								setTimeout(onLoadComplete,100);
							} else {
								onLoadError();
							}
						}
					}
				},

				// image error handler
				onLoadError = function() {
					if(item) {
						item.img.off('.mfploader');
						if(item === mfp.currItem){
							mfp._onImageHasSize(item);
							mfp.updateStatus('error', imgSt.tError.replace('%url%', item.src) );
						}

						item.hasSize = true;
						item.loaded = true;
						item.loadError = true;
					}
				},
				imgSt = mfp.st.image;


			var el = template.find('.mfp-img');
			if(el.length) {
				var img = document.createElement('img');
				img.className = 'mfp-img';
				if(item.el && item.el.find('img').length) {
					img.alt = item.el.find('img').attr('alt');
				}
				item.img = $(img).on('load.mfploader', onLoadComplete).on('error.mfploader', onLoadError);
				img.src = item.src;

				// without clone() "error" event is not firing when IMG is replaced by new IMG
				// TODO: find a way to avoid such cloning
				if(el.is('img')) {
					item.img = item.img.clone();
				}

				img = item.img[0];
				if(img.naturalWidth > 0) {
					item.hasSize = true;
				} else if(!img.width) {
					item.hasSize = false;
				}
			}

			mfp._parseMarkup(template, {
				title: _getTitle(item),
				img_replaceWith: item.img
			}, item);

			mfp.resizeImage();

			if(item.hasSize) {
				if(_imgInterval) clearInterval(_imgInterval);

				if(item.loadError) {
					template.addClass('mfp-loading');
					mfp.updateStatus('error', imgSt.tError.replace('%url%', item.src) );
				} else {
					template.removeClass('mfp-loading');
					mfp.updateStatus('ready');
				}
				return template;
			}

			mfp.updateStatus('loading');
			item.loading = true;

			if(!item.hasSize) {
				item.imgHidden = true;
				template.addClass('mfp-loading');
				mfp.findImageSize(item);
			}

			return template;
		}
	}
});

/*>>image*/

/*>>zoom*/
var hasMozTransform,
	getHasMozTransform = function() {
		if(hasMozTransform === undefined) {
			hasMozTransform = document.createElement('p').style.MozTransform !== undefined;
		}
		return hasMozTransform;
	};

$.magnificPopup.registerModule('zoom', {

	options: {
		enabled: false,
		easing: 'ease-in-out',
		duration: 300,
		opener: function(element) {
			return element.is('img') ? element : element.find('img');
		}
	},

	proto: {

		initZoom: function() {
			var zoomSt = mfp.st.zoom,
				ns = '.zoom',
				image;

			if(!zoomSt.enabled || !mfp.supportsTransition) {
				return;
			}

			var duration = zoomSt.duration,
				getElToAnimate = function(image) {
					var newImg = image.clone().removeAttr('style').removeAttr('class').addClass('mfp-animated-image'),
						transition = 'all '+(zoomSt.duration/1000)+'s ' + zoomSt.easing,
						cssObj = {
							position: 'fixed',
							zIndex: 9999,
							left: 0,
							top: 0,
							'-webkit-backface-visibility': 'hidden'
						},
						t = 'transition';

					cssObj['-webkit-'+t] = cssObj['-moz-'+t] = cssObj['-o-'+t] = cssObj[t] = transition;

					newImg.css(cssObj);
					return newImg;
				},
				showMainContent = function() {
					mfp.content.css('visibility', 'visible');
				},
				openTimeout,
				animatedImg;

			_mfpOn('BuildControls'+ns, function() {
				if(mfp._allowZoom()) {

					clearTimeout(openTimeout);
					mfp.content.css('visibility', 'hidden');

					// Basically, all code below does is clones existing image, puts in on top of the current one and animated it

					image = mfp._getItemToZoom();

					if(!image) {
						showMainContent();
						return;
					}

					animatedImg = getElToAnimate(image);

					animatedImg.css( mfp._getOffset() );

					mfp.wrap.append(animatedImg);

					openTimeout = setTimeout(function() {
						animatedImg.css( mfp._getOffset( true ) );
						openTimeout = setTimeout(function() {

							showMainContent();

							setTimeout(function() {
								animatedImg.remove();
								image = animatedImg = null;
								_mfpTrigger('ZoomAnimationEnded');
							}, 16); // avoid blink when switching images

						}, duration); // this timeout equals animation duration

					}, 16); // by adding this timeout we avoid short glitch at the beginning of animation


					// Lots of timeouts...
				}
			});
			_mfpOn(BEFORE_CLOSE_EVENT+ns, function() {
				if(mfp._allowZoom()) {

					clearTimeout(openTimeout);

					mfp.st.removalDelay = duration;

					if(!image) {
						image = mfp._getItemToZoom();
						if(!image) {
							return;
						}
						animatedImg = getElToAnimate(image);
					}

					animatedImg.css( mfp._getOffset(true) );
					mfp.wrap.append(animatedImg);
					mfp.content.css('visibility', 'hidden');

					setTimeout(function() {
						animatedImg.css( mfp._getOffset() );
					}, 16);
				}

			});

			_mfpOn(CLOSE_EVENT+ns, function() {
				if(mfp._allowZoom()) {
					showMainContent();
					if(animatedImg) {
						animatedImg.remove();
					}
					image = null;
				}
			});
		},

		_allowZoom: function() {
			return mfp.currItem.type === 'image';
		},

		_getItemToZoom: function() {
			if(mfp.currItem.hasSize) {
				return mfp.currItem.img;
			} else {
				return false;
			}
		},

		// Get element postion relative to viewport
		_getOffset: function(isLarge) {
			var el;
			if(isLarge) {
				el = mfp.currItem.img;
			} else {
				el = mfp.st.zoom.opener(mfp.currItem.el || mfp.currItem);
			}

			var offset = el.offset();
			var paddingTop = parseInt(el.css('padding-top'),10);
			var paddingBottom = parseInt(el.css('padding-bottom'),10);
			offset.top -= ( $(window).scrollTop() - paddingTop );


			/*

			Animating left + top + width/height looks glitchy in Firefox, but perfect in Chrome. And vice-versa.

			 */
			var obj = {
				width: el.width(),
				// fix Zepto height+padding issue
				height: (_isJQ ? el.innerHeight() : el[0].offsetHeight) - paddingBottom - paddingTop
			};

			// I hate to do this, but there is no another option
			if( getHasMozTransform() ) {
				obj['-moz-transform'] = obj['transform'] = 'translate(' + offset.left + 'px,' + offset.top + 'px)';
			} else {
				obj.left = offset.left;
				obj.top = offset.top;
			}
			return obj;
		}

	}
});



/*>>zoom*/

/*>>iframe*/

var IFRAME_NS = 'iframe',
	_emptyPage = '//about:blank',

	_fixIframeBugs = function(isShowing) {
		if(mfp.currTemplate[IFRAME_NS]) {
			var el = mfp.currTemplate[IFRAME_NS].find('iframe');
			if(el.length) {
				// reset src after the popup is closed to avoid "video keeps playing after popup is closed" bug
				if(!isShowing) {
					el[0].src = _emptyPage;
				}

				// IE8 black screen bug fix
				if(mfp.isIE8) {
					el.css('display', isShowing ? 'block' : 'none');
				}
			}
		}
	};

$.magnificPopup.registerModule(IFRAME_NS, {

	options: {
		markup: '<div class="mfp-iframe-scaler">'+
					'<div class="mfp-close"></div>'+
					'<iframe class="mfp-iframe" src="//about:blank" frameborder="0" allowfullscreen></iframe>'+
				'</div>',

		srcAction: 'iframe_src',

		// we don't care and support only one default type of URL by default
		patterns: {
			youtube: {
				index: 'youtube.com',
				id: 'v=',
				src: '//www.youtube.com/embed/%id%?autoplay=1'
			},
			vimeo: {
				index: 'vimeo.com/',
				id: '/',
				src: '//player.vimeo.com/video/%id%?autoplay=1'
			},
			gmaps: {
				index: '//maps.google.',
				src: '%id%&output=embed'
			}
		}
	},

	proto: {
		initIframe: function() {
			mfp.types.push(IFRAME_NS);

			_mfpOn('BeforeChange', function(e, prevType, newType) {
				if(prevType !== newType) {
					if(prevType === IFRAME_NS) {
						_fixIframeBugs(); // iframe if removed
					} else if(newType === IFRAME_NS) {
						_fixIframeBugs(true); // iframe is showing
					}
				}// else {
					// iframe source is switched, don't do anything
				//}
			});

			_mfpOn(CLOSE_EVENT + '.' + IFRAME_NS, function() {
				_fixIframeBugs();
			});
		},

		getIframe: function(item, template) {
			var embedSrc = item.src;
			var iframeSt = mfp.st.iframe;

			$.each(iframeSt.patterns, function() {
				if(embedSrc.indexOf( this.index ) > -1) {
					if(this.id) {
						if(typeof this.id === 'string') {
							embedSrc = embedSrc.substr(embedSrc.lastIndexOf(this.id)+this.id.length, embedSrc.length);
						} else {
							embedSrc = this.id.call( this, embedSrc );
						}
					}
					embedSrc = this.src.replace('%id%', embedSrc );
					return false; // break;
				}
			});

			var dataObj = {};
			if(iframeSt.srcAction) {
				dataObj[iframeSt.srcAction] = embedSrc;
			}
			mfp._parseMarkup(template, dataObj, item);

			mfp.updateStatus('ready');

			return template;
		}
	}
});



/*>>iframe*/

/*>>gallery*/
/**
 * Get looped index depending on number of slides
 */
var _getLoopedId = function(index) {
		var numSlides = mfp.items.length;
		if(index > numSlides - 1) {
			return index - numSlides;
		} else  if(index < 0) {
			return numSlides + index;
		}
		return index;
	},
	_replaceCurrTotal = function(text, curr, total) {
		return text.replace(/%curr%/gi, curr + 1).replace(/%total%/gi, total);
	};

$.magnificPopup.registerModule('gallery', {

	options: {
		enabled: false,
		arrowMarkup: '<button title="%title%" type="button" class="mfp-arrow mfp-arrow-%dir%"></button>',
		preload: [0,2],
		navigateByImgClick: true,
		arrows: true,

		tPrev: 'Previous (Left arrow key)',
		tNext: 'Next (Right arrow key)',
		tCounter: '%curr% of %total%'
	},

	proto: {
		initGallery: function() {

			var gSt = mfp.st.gallery,
				ns = '.mfp-gallery';

			mfp.direction = true; // true - next, false - prev

			if(!gSt || !gSt.enabled ) return false;

			_wrapClasses += ' mfp-gallery';

			_mfpOn(OPEN_EVENT+ns, function() {

				if(gSt.navigateByImgClick) {
					mfp.wrap.on('click'+ns, '.mfp-img', function() {
						if(mfp.items.length > 1) {
							mfp.next();
							return false;
						}
					});
				}

				_document.on('keydown'+ns, function(e) {
					if (e.keyCode === 37) {
						mfp.prev();
					} else if (e.keyCode === 39) {
						mfp.next();
					}
				});
			});

			_mfpOn('UpdateStatus'+ns, function(e, data) {
				if(data.text) {
					data.text = _replaceCurrTotal(data.text, mfp.currItem.index, mfp.items.length);
				}
			});

			_mfpOn(MARKUP_PARSE_EVENT+ns, function(e, element, values, item) {
				var l = mfp.items.length;
				values.counter = l > 1 ? _replaceCurrTotal(gSt.tCounter, item.index, l) : '';
			});

			_mfpOn('BuildControls' + ns, function() {
				if(mfp.items.length > 1 && gSt.arrows && !mfp.arrowLeft) {
					var markup = gSt.arrowMarkup,
						arrowLeft = mfp.arrowLeft = $( markup.replace(/%title%/gi, gSt.tPrev).replace(/%dir%/gi, 'left') ).addClass(PREVENT_CLOSE_CLASS),
						arrowRight = mfp.arrowRight = $( markup.replace(/%title%/gi, gSt.tNext).replace(/%dir%/gi, 'right') ).addClass(PREVENT_CLOSE_CLASS);

					arrowLeft.click(function() {
						mfp.prev();
					});
					arrowRight.click(function() {
						mfp.next();
					});

					mfp.container.append(arrowLeft.add(arrowRight));
				}
			});

			_mfpOn(CHANGE_EVENT+ns, function() {
				if(mfp._preloadTimeout) clearTimeout(mfp._preloadTimeout);

				mfp._preloadTimeout = setTimeout(function() {
					mfp.preloadNearbyImages();
					mfp._preloadTimeout = null;
				}, 16);
			});


			_mfpOn(CLOSE_EVENT+ns, function() {
				_document.off(ns);
				mfp.wrap.off('click'+ns);
				mfp.arrowRight = mfp.arrowLeft = null;
			});

		},
		next: function() {
			mfp.direction = true;
			mfp.index = _getLoopedId(mfp.index + 1);
			mfp.updateItemHTML();
		},
		prev: function() {
			mfp.direction = false;
			mfp.index = _getLoopedId(mfp.index - 1);
			mfp.updateItemHTML();
		},
		goTo: function(newIndex) {
			mfp.direction = (newIndex >= mfp.index);
			mfp.index = newIndex;
			mfp.updateItemHTML();
		},
		preloadNearbyImages: function() {
			var p = mfp.st.gallery.preload,
				preloadBefore = Math.min(p[0], mfp.items.length),
				preloadAfter = Math.min(p[1], mfp.items.length),
				i;

			for(i = 1; i <= (mfp.direction ? preloadAfter : preloadBefore); i++) {
				mfp._preloadItem(mfp.index+i);
			}
			for(i = 1; i <= (mfp.direction ? preloadBefore : preloadAfter); i++) {
				mfp._preloadItem(mfp.index-i);
			}
		},
		_preloadItem: function(index) {
			index = _getLoopedId(index);

			if(mfp.items[index].preloaded) {
				return;
			}

			var item = mfp.items[index];
			if(!item.parsed) {
				item = mfp.parseEl( index );
			}

			_mfpTrigger('LazyLoad', item);

			if(item.type === 'image') {
				item.img = $('<img class="mfp-img" />').on('load.mfploader', function() {
					item.hasSize = true;
				}).on('error.mfploader', function() {
					item.hasSize = true;
					item.loadError = true;
					_mfpTrigger('LazyLoadError', item);
				}).attr('src', item.src);
			}


			item.preloaded = true;
		}
	}
});

/*>>gallery*/

/*>>retina*/

var RETINA_NS = 'retina';

$.magnificPopup.registerModule(RETINA_NS, {
	options: {
		replaceSrc: function(item) {
			return item.src.replace(/\.\w+$/, function(m) { return '@2x' + m; });
		},
		ratio: 1 // Function or number.  Set to 1 to disable.
	},
	proto: {
		initRetina: function() {
			if(window.devicePixelRatio > 1) {

				var st = mfp.st.retina,
					ratio = st.ratio;

				ratio = !isNaN(ratio) ? ratio : ratio();

				if(ratio > 1) {
					_mfpOn('ImageHasSize' + '.' + RETINA_NS, function(e, item) {
						item.img.css({
							'max-width': item.img[0].naturalWidth / ratio,
							'width': '100%'
						});
					});
					_mfpOn('ElementParse' + '.' + RETINA_NS, function(e, item) {
						item.src = st.replaceSrc(item, ratio);
					});
				}
			}

		}
	}
});

/*>>retina*/
 _checkInstance(); }));
/*!
 * tipso - A Lightweight Responsive jQuery Tooltip Plugin v1.0.8
 * Copyright (c) 2014-2015 Bojan Petkovski
 * http://tipso.object505.com
 * Licensed under the MIT license
 * http://object505.mit-license.org/
 */
 // CommonJS, AMD or browser globals
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS
        module.exports = factory(require('jquery'));
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function($) {
  var pluginName = "tipso",
    defaults = {
      speed             : 400,          //Animation speed
      background        : '#55b555',
      titleBackground   : '#333333',
      color             : '#ffffff',
      titleColor        : '#ffffff',
      titleContent      : '',           //Content of the title bar
      showArrow         : true,
      position          : 'top',
      width             : 200,
      maxWidth          : '',
      delay             : 200,
      hideDelay         : 0,
      animationIn       : '',
      animationOut      : '',
      offsetX           : 0,
      offsetY           : 0,
      arrowWidth        : 8,
      tooltipHover      : false,
      content           : null,
      ajaxContentUrl    : null,
      ajaxContentBuffer : 0,
      contentElementId  : null,         //Normally used for picking template scripts
      useTitle          : false,        //Use the title tag as tooptip or not
      templateEngineFunc: null,         //A function that compiles and renders the content
      onBeforeShow      : null,
      onShow            : null,
      onHide            : null
    };

  function Plugin(element, options) {
    this.element = element;
    this.$element = $(this.element);
    this.doc = $(document);
    this.win = $(window);
    this.settings = $.extend({}, defaults, options);

    /*
     * Process and add data-attrs to settings as well for ease of use. Also, if
     * data-tipso is an object then use it as extra settings and if it's not
     * then use it as a title.
     */
    if (typeof(this.$element.data("tipso")) === "object")
    {
      $.extend(this.settings, this.$element.data("tipso"));
    }

    var data_keys = Object.keys(this.$element.data());
    var data_attrs = {};
    for (var i = 0; i < data_keys.length; i++)
    {
      var key = data_keys[i].replace(pluginName, "");
      if (key === "")
      {
        continue;
      }
      //lowercase first letter
      key = key.charAt(0).toLowerCase() + key.slice(1);
      data_attrs[key] = this.$element.data(data_keys[i]);

      //We cannot use extend for data_attrs because they are automatically
      //lowercased. We need to do this manually and extend this.settings with
      //data_attrs
      for (var settings_key in this.settings)
      {
        if (settings_key.toLowerCase() == key)
        {
          this.settings[settings_key] = data_attrs[key];
        }
      }
    }

    this._defaults = defaults;
    this._name = pluginName;
    this._title = this.$element.attr('title');
    this.mode = 'hide';
    this.ieFade = !supportsTransitions;

    //By keeping the original prefered position and repositioning by calling
    //the reposition function we can make for more smart and easier positioning
    //in complex scenarios!
    this.settings.preferedPosition = this.settings.position;

    this.init();
  }

  $.extend(Plugin.prototype, {
    init: function() {
      var obj = this,
        $e = this.$element,
        $doc = this.doc;
      $e.addClass('tipso_style').removeAttr('title');

      if (obj.settings.tooltipHover) {
        var waitForHover = null,
            hoverHelper = null;
        $e.on('mouseover' + '.' + pluginName, function() {
          clearTimeout(waitForHover);
          clearTimeout(hoverHelper);
          hoverHelper = setTimeout(function(){
            obj.show();
          }, 150);
        });
        $e.on('mouseout' + '.' + pluginName, function() {
          clearTimeout(waitForHover);
          clearTimeout(hoverHelper);
          waitForHover = setTimeout(function(){
            obj.hide();
          }, 200);

          obj.tooltip()
            .on('mouseover' + '.' + pluginName, function() {
              obj.mode = 'tooltipHover';
            })
            .on('mouseout' + '.' + pluginName, function() {
              obj.mode = 'show';
              clearTimeout(waitForHover);
              waitForHover = setTimeout(function(){
                obj.hide();
              }, 200);
            })
        ;
        });
      } else {
        $e.on('mouseover' + '.' + pluginName, function() {
          obj.show();
        });
        $e.on('mouseout' + '.' + pluginName, function() {
          obj.hide();
        });
      }
	  if(obj.settings.ajaxContentUrl)
	  {
		obj.ajaxContent = null;
	  }
    },
    tooltip: function() {
      if (!this.tipso_bubble) {
        this.tipso_bubble = $(
          '<div class="tipso_bubble"><div class="tipso_title"></div><div class="tipso_content"></div><div class="tipso_arrow"></div></div>'
        );
      }
      return this.tipso_bubble;
    },
    show: function() {
      var tipso_bubble = this.tooltip(),
        obj = this,
        $win = this.win;

      if (obj.settings.showArrow === false) {
          tipso_bubble.find(".tipso_arrow").hide();
      }
      else {
          tipso_bubble.find(".tipso_arrow").show();
      }

      if (obj.mode === 'hide') {
        if ($.isFunction(obj.settings.onBeforeShow)) {
          obj.settings.onBeforeShow(obj.$element, obj.element, obj);
        }
        if (obj.settings.size) {
            tipso_bubble.addClass(obj.settings.size);
        }
        if (obj.settings.width) {
          tipso_bubble.css({
            background: obj.settings.background,
            color: obj.settings.color,
            width: obj.settings.width
          }).hide();
        } else if (obj.settings.maxWidth){
          tipso_bubble.css({
            background: obj.settings.background,
            color: obj.settings.color,
            maxWidth: obj.settings.maxWidth
          }).hide();
        } else {
          tipso_bubble.css({
            background: obj.settings.background,
            color: obj.settings.color,
            width: 200
          }).hide();
        }
        tipso_bubble.find('.tipso_title').css({
            background: obj.settings.titleBackground,
            color: obj.settings.titleColor
        });
        tipso_bubble.find('.tipso_content').html(obj.content());
        tipso_bubble.find('.tipso_title').html(obj.titleContent());
        reposition(obj);

        $win.on('resize' + '.' + pluginName, function tipsoResizeHandler () {
            obj.settings.position = obj.settings.preferedPosition;
            reposition(obj);
        });

        window.clearTimeout(obj.timeout);
        obj.timeout = null;
        obj.timeout = window.setTimeout(function() {
          if (obj.ieFade || obj.settings.animationIn === '' || obj.settings.animationOut === ''){
            tipso_bubble.appendTo('body').stop(true, true).fadeIn(obj.settings
            .speed, function() {
              obj.mode = 'show';
              if ($.isFunction(obj.settings.onShow)) {
                obj.settings.onShow(obj.$element, obj.element, obj);
              }
            });
          } else {
            tipso_bubble.remove().appendTo('body')
            .stop(true, true)
            .removeClass('animated ' + obj.settings.animationOut)
            .addClass('noAnimation')
            .removeClass('noAnimation')
            .addClass('animated ' + obj.settings.animationIn).fadeIn(obj.settings.speed, function() {
              $(this).one('webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend', function(){
                $(this).removeClass('animated ' + obj.settings.animationIn);
              });
              obj.mode = 'show';
              if ($.isFunction(obj.settings.onShow)) {
                obj.settings.onShow(obj.$element, obj.element, obj);
              }
              $win.off('resize' + '.' + pluginName, null, 'tipsoResizeHandler');
            });
          }
        }, obj.settings.delay);
      }
    },
    hide: function(force) {
      var obj = this,
        $win = this.win,
        tipso_bubble = this.tooltip(),
        hideDelay = obj.settings.hideDelay;

      if (force) {
        hideDelay = 0;
        obj.mode = 'show';
      }

      window.clearTimeout(obj.timeout);
      obj.timeout = null;
      obj.timeout = window.setTimeout(function() {
        if (obj.mode !== 'tooltipHover') {
          if (obj.ieFade || obj.settings.animationIn === '' || obj.settings.animationOut === ''){
            tipso_bubble.stop(true, true).fadeOut(obj.settings.speed,
            function() {
              $(this).remove();
              if ($.isFunction(obj.settings.onHide) && obj.mode === 'show') {
                obj.settings.onHide(obj.$element, obj.element, obj);
              }
              obj.mode = 'hide';
              $win.off('resize' + '.' + pluginName, null, 'tipsoResizeHandler');
            });
          } else {
            tipso_bubble.stop(true, true)
            .removeClass('animated ' + obj.settings.animationIn)
            .addClass('noAnimation').removeClass('noAnimation')
            .addClass('animated ' + obj.settings.animationOut)
            .one('webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend', function(){
              $(this).removeClass('animated ' + obj.settings.animationOut).remove();
              if ($.isFunction(obj.settings.onHide) && obj.mode === 'show') {
                obj.settings.onHide(obj.$element, obj.element, obj);
              }
              obj.mode = 'hide';
              $win.off('resize' + '.' + pluginName, null, 'tipsoResizeHandler');
            });
          }
        }
      }, hideDelay);
    },
    close: function() {
      this.hide(true);
    },
    destroy: function() {
      var $e = this.$element,
        $win = this.win,
        $doc = this.doc;
      $e.off('.' + pluginName);
      $win.off('resize' + '.' + pluginName, null, 'tipsoResizeHandler');
      $e.removeData(pluginName);
      $e.removeClass('tipso_style').attr('title', this._title);
    },
    titleContent: function() {
        var content,
          $e = this.$element,
          obj = this;
        if (obj.settings.titleContent)
        {
            content = obj.settings.titleContent;
        }
        else
        {
            content = $e.data('tipso-title');
        }
        return content;
    },
    content: function() {
      var content,
        $e = this.$element,
        obj = this,
        title = this._title;
      if (obj.settings.ajaxContentUrl)
      {
		if(obj._ajaxContent)
		{
			content = obj._ajaxContent;
		}
		else 
		{
			obj._ajaxContent = content = $.ajax({
			  type: "GET",
			  url: obj.settings.ajaxContentUrl,
			  async: false
			}).responseText;
			if(obj.settings.ajaxContentBuffer > 0)
			{
				setTimeout(function(){ 
					obj._ajaxContent = null;
				}, obj.settings.ajaxContentBuffer);
			}
			else 
			{
				obj._ajaxContent = null;
			}
		}
      }
      else if (obj.settings.contentElementId)
      {
        content = $("#" + obj.settings.contentElementId).text();
      }
      else if (obj.settings.content)
      {
        content = obj.settings.content;
      }
      else
      {
        if (obj.settings.useTitle === true)
        {
          content = title;
        }
        else
        {
          // Only use data-tipso as content if it's not being used for settings
          if (typeof($e.data("tipso")) === "string")
          {
            content = $e.data('tipso');
          }
        }
      }
      if (obj.settings.templateEngineFunc !== null)
      {
          content = obj.settings.templateEngineFunc(content);
      }
      return content;
    },
    update: function(key, value) {
      var obj = this;
      if (value) {
        obj.settings[key] = value;
      } else {
        return obj.settings[key];
      }
    }
  });

  function realHeight(obj) {
    var clone = obj.clone();
    clone.css("visibility", "hidden");
    $('body').append(clone);
    var height = clone.outerHeight();
    var width = clone.outerWidth();
    clone.remove();
    return {
      'width' : width,
      'height' : height
    };
  }

  var supportsTransitions = (function() {
    var s = document.createElement('p').style,
        v = ['ms','O','Moz','Webkit'];
    if( s['transition'] === '' ) return true;
    while( v.length )
        if( v.pop() + 'Transition' in s )
            return true;
    return false;
  })();

  function removeCornerClasses(obj) {
    obj.removeClass("top_right_corner bottom_right_corner top_left_corner bottom_left_corner");
    obj.find(".tipso_title").removeClass("top_right_corner bottom_right_corner top_left_corner bottom_left_corner");
  }

  function reposition(thisthat) {
    var tipso_bubble = thisthat.tooltip(),
      $e = thisthat.$element,
      obj = thisthat,
      $win = $(window),
      arrow = 10,
      pos_top, pos_left, diff;

    var arrow_color = obj.settings.background;
    var title_content = obj.titleContent();
    if (title_content !== undefined && title_content !== '') {
        arrow_color = obj.settings.titleBackground;
    }

    if ($e.parent().outerWidth() > $win.outerWidth()) {
      $win = $e.parent();
    }

    switch (obj.settings.position)
    {
      case 'top-right':
        pos_left = $e.offset().left + ($e.outerWidth());
        pos_top = $e.offset().top - realHeight(tipso_bubble).height - arrow;
        tipso_bubble.find('.tipso_arrow').css({
          marginLeft: -obj.settings.arrowWidth,
          marginTop: '',
        });
        if (pos_top < $win.scrollTop())
        {
          pos_top = $e.offset().top + $e.outerHeight() + arrow;

          tipso_bubble.find('.tipso_arrow').css({
            'border-bottom-color': arrow_color,
            'border-top-color': 'transparent',
            'border-left-color': 'transparent',
            'border-right-color': 'transparent'
          });

          /*
           * Hide and show the appropriate rounded corners
           */
          removeCornerClasses(tipso_bubble);
          tipso_bubble.addClass("bottom_right_corner");
          tipso_bubble.find(".tipso_title").addClass("bottom_right_corner");
          tipso_bubble.find('.tipso_arrow').css({
            'border-left-color': arrow_color,
          });

          tipso_bubble.removeClass('top-right top bottom left right');
          tipso_bubble.addClass('bottom');
        }
        else
        {
          tipso_bubble.find('.tipso_arrow').css({
            'border-top-color': obj.settings.background,
            'border-bottom-color': 'transparent ',
            'border-left-color': 'transparent',
            'border-right-color': 'transparent'
          });

          /*
           * Hide and show the appropriate rounded corners
           */
          removeCornerClasses(tipso_bubble);
          tipso_bubble.addClass("top_right_corner");
          tipso_bubble.find('.tipso_arrow').css({
            'border-left-color': obj.settings.background,
          });

          tipso_bubble.removeClass('top bottom left right');
          tipso_bubble.addClass('top');
        }
        break;
      case 'top-left':
        pos_left = $e.offset().left - (realHeight(tipso_bubble).width);
        pos_top = $e.offset().top - realHeight(tipso_bubble).height - arrow;
        tipso_bubble.find('.tipso_arrow').css({
          marginLeft: -obj.settings.arrowWidth,
          marginTop: '',
        });
        if (pos_top < $win.scrollTop())
        {
          pos_top = $e.offset().top + $e.outerHeight() + arrow;

          tipso_bubble.find('.tipso_arrow').css({
            'border-bottom-color': arrow_color,
            'border-top-color': 'transparent',
            'border-left-color': 'transparent',
            'border-right-color': 'transparent'
          });

          /*
           * Hide and show the appropriate rounded corners
           */
          removeCornerClasses(tipso_bubble);
          tipso_bubble.addClass("bottom_left_corner");
          tipso_bubble.find(".tipso_title").addClass("bottom_left_corner");
          tipso_bubble.find('.tipso_arrow').css({
            'border-right-color': arrow_color,
          });

          tipso_bubble.removeClass('top-right top bottom left right');
          tipso_bubble.addClass('bottom');
        }
        else
        {
          tipso_bubble.find('.tipso_arrow').css({
            'border-top-color': obj.settings.background,
            'border-bottom-color': 'transparent ',
            'border-left-color': 'transparent',
            'border-right-color': 'transparent'
          });

          /*
           * Hide and show the appropriate rounded corners
           */
          removeCornerClasses(tipso_bubble);
          tipso_bubble.addClass("top_left_corner");
          tipso_bubble.find('.tipso_arrow').css({
            'border-right-color': obj.settings.background,
          });

          tipso_bubble.removeClass('top bottom left right');
          tipso_bubble.addClass('top');
        }
        break;

      /*
       * Bottom right position
       */
      case 'bottom-right':
       pos_left = $e.offset().left + ($e.outerWidth());
       pos_top = $e.offset().top + $e.outerHeight() + arrow;
       tipso_bubble.find('.tipso_arrow').css({
         marginLeft: -obj.settings.arrowWidth,
         marginTop: '',
       });
       if (pos_top + realHeight(tipso_bubble).height > $win.scrollTop() + $win.outerHeight())
       {
         pos_top = $e.offset().top - realHeight(tipso_bubble).height - arrow;

         tipso_bubble.find('.tipso_arrow').css({
           'border-bottom-color': 'transparent',
           'border-top-color': obj.settings.background,
           'border-left-color': 'transparent',
           'border-right-color': 'transparent'
         });

         /*
          * Hide and show the appropriate rounded corners
          */
         removeCornerClasses(tipso_bubble);
         tipso_bubble.addClass("top_right_corner");
         tipso_bubble.find(".tipso_title").addClass("top_left_corner");
         tipso_bubble.find('.tipso_arrow').css({
           'border-left-color': obj.settings.background,
         });

         tipso_bubble.removeClass('top-right top bottom left right');
         tipso_bubble.addClass('top');
       }
       else
       {
         tipso_bubble.find('.tipso_arrow').css({
           'border-top-color': 'transparent',
           'border-bottom-color': arrow_color,
           'border-left-color': 'transparent',
           'border-right-color': 'transparent'
         });

         /*
          * Hide and show the appropriate rounded corners
          */
         removeCornerClasses(tipso_bubble);
         tipso_bubble.addClass("bottom_right_corner");
         tipso_bubble.find(".tipso_title").addClass("bottom_right_corner");
         tipso_bubble.find('.tipso_arrow').css({
           'border-left-color': arrow_color,
         });

         tipso_bubble.removeClass('top bottom left right');
         tipso_bubble.addClass('bottom');
       }
       break;

       /*
        * Bottom left position
        */
       case 'bottom-left':
        pos_left = $e.offset().left - (realHeight(tipso_bubble).width);
        pos_top = $e.offset().top + $e.outerHeight() + arrow;
        tipso_bubble.find('.tipso_arrow').css({
          marginLeft: -obj.settings.arrowWidth,
          marginTop: '',
        });
        if (pos_top + realHeight(tipso_bubble).height > $win.scrollTop() + $win.outerHeight())
        {
          pos_top = $e.offset().top - realHeight(tipso_bubble).height - arrow;

          tipso_bubble.find('.tipso_arrow').css({
            'border-bottom-color': 'transparent',
            'border-top-color': obj.settings.background,
            'border-left-color': 'transparent',
            'border-right-color': 'transparent'
          });

          /*
           * Hide and show the appropriate rounded corners
           */
          removeCornerClasses(tipso_bubble);
          tipso_bubble.addClass("top_left_corner");
          tipso_bubble.find(".tipso_title").addClass("top_left_corner");
          tipso_bubble.find('.tipso_arrow').css({
            'border-right-color': obj.settings.background,
          });

          tipso_bubble.removeClass('top-right top bottom left right');
          tipso_bubble.addClass('top');
        }
        else
        {
          tipso_bubble.find('.tipso_arrow').css({
            'border-top-color': 'transparent',
            'border-bottom-color': arrow_color,
            'border-left-color': 'transparent',
            'border-right-color': 'transparent'
          });

          /*
           * Hide and show the appropriate rounded corners
           */
          removeCornerClasses(tipso_bubble);
          tipso_bubble.addClass("bottom_left_corner");
          tipso_bubble.find(".tipso_title").addClass("bottom_left_corner");
          tipso_bubble.find('.tipso_arrow').css({
            'border-right-color': arrow_color,
          });

          tipso_bubble.removeClass('top bottom left right');
          tipso_bubble.addClass('bottom');
        }
        break;
      /*
       * Top position
       */
      case 'top':
        pos_left = $e.offset().left + ($e.outerWidth() / 2) - (realHeight(tipso_bubble).width / 2);
        pos_top = $e.offset().top - realHeight(tipso_bubble).height - arrow;
        tipso_bubble.find('.tipso_arrow').css({
          marginLeft: -obj.settings.arrowWidth,
          marginTop: '',
        });
        if (pos_top < $win.scrollTop())
        {
          pos_top = $e.offset().top + $e.outerHeight() + arrow;

          tipso_bubble.find('.tipso_arrow').css({
            'border-bottom-color': arrow_color,
            'border-top-color': 'transparent',
            'border-left-color': 'transparent',
            'border-right-color': 'transparent'
          });

          tipso_bubble.removeClass('top bottom left right');
          tipso_bubble.addClass('bottom');
        }
        else
        {
          tipso_bubble.find('.tipso_arrow').css({
            'border-top-color': obj.settings.background,
            'border-bottom-color': 'transparent',
            'border-left-color': 'transparent',
            'border-right-color': 'transparent'
          });
          tipso_bubble.removeClass('top bottom left right');
          tipso_bubble.addClass('top');
        }
        break;
      case 'bottom':
        pos_left = $e.offset().left + ($e.outerWidth() / 2) - (realHeight(tipso_bubble).width / 2);
        pos_top = $e.offset().top + $e.outerHeight() + arrow;
        tipso_bubble.find('.tipso_arrow').css({
          marginLeft: -obj.settings.arrowWidth,
          marginTop: '',
        });
        if (pos_top + realHeight(tipso_bubble).height > $win.scrollTop() + $win.outerHeight())
        {
          pos_top = $e.offset().top - realHeight(tipso_bubble).height - arrow;
          tipso_bubble.find('.tipso_arrow').css({
            'border-top-color': obj.settings.background,
            'border-bottom-color': 'transparent',
            'border-left-color': 'transparent',
            'border-right-color': 'transparent'
          });
          tipso_bubble.removeClass('top bottom left right');
          tipso_bubble.addClass('top');
        }
        else
        {
          tipso_bubble.find('.tipso_arrow').css({
            'border-bottom-color': arrow_color,
            'border-top-color': 'transparent',
            'border-left-color': 'transparent',
            'border-right-color': 'transparent'
          });
          tipso_bubble.removeClass('top bottom left right');
          tipso_bubble.addClass(obj.settings.position);
        }
        break;
      case 'left':
        pos_left = $e.offset().left - realHeight(tipso_bubble).width - arrow;
        pos_top = $e.offset().top + ($e.outerHeight() / 2) - (realHeight(tipso_bubble).height / 2);
        tipso_bubble.find('.tipso_arrow').css({
          marginTop: -obj.settings.arrowWidth,
          marginLeft: ''
        });
        if (pos_left < $win.scrollLeft())
        {
          pos_left = $e.offset().left + $e.outerWidth() + arrow;
          tipso_bubble.find('.tipso_arrow').css({
            'border-right-color': obj.settings.background,
            'border-left-color': 'transparent',
            'border-top-color': 'transparent',
            'border-bottom-color': 'transparent'
          });
          tipso_bubble.removeClass('top bottom left right');
          tipso_bubble.addClass('right');
        }
        else
        {
          tipso_bubble.find('.tipso_arrow').css({
            'border-left-color': obj.settings.background,
            'border-right-color': 'transparent',
            'border-top-color': 'transparent',
            'border-bottom-color': 'transparent'
          });
          tipso_bubble.removeClass('top bottom left right');
          tipso_bubble.addClass(obj.settings.position);
        }
        break;
      case 'right':
        pos_left = $e.offset().left + $e.outerWidth() + arrow;
        pos_top = $e.offset().top + ($e.outerHeight() / 2) - (realHeight(tipso_bubble).height / 2);
        tipso_bubble.find('.tipso_arrow').css({
          marginTop: -obj.settings.arrowWidth,
          marginLeft: ''
        });
        if (pos_left + arrow + obj.settings.width > $win.scrollLeft() + $win.outerWidth())
        {
          pos_left = $e.offset().left - realHeight(tipso_bubble).width - arrow;
          tipso_bubble.find('.tipso_arrow').css({
            'border-left-color': obj.settings.background,
            'border-right-color': 'transparent',
            'border-top-color': 'transparent',
            'border-bottom-color': 'transparent'
          });
          tipso_bubble.removeClass('top bottom left right');
          tipso_bubble.addClass('left');
        }
        else
        {
          tipso_bubble.find('.tipso_arrow').css({
            'border-right-color': obj.settings.background,
            'border-left-color': 'transparent',
            'border-top-color': 'transparent',
            'border-bottom-color': 'transparent'
          });
          tipso_bubble.removeClass('top bottom left right');
          tipso_bubble.addClass(obj.settings.position);
        }
        break;
    }
    /*
     * Set the position of the arrow for the corner positions
     */
    if (obj.settings.position === 'top-right')
    {
      tipso_bubble.find('.tipso_arrow').css({
        'margin-left': -obj.settings.width / 2
      });
    }
    if (obj.settings.position === 'top-left')
    {
      var tipso_arrow = tipso_bubble.find(".tipso_arrow").eq(0);
      tipso_arrow.css({
        'margin-left': obj.settings.width / 2 - 2 * obj.settings.arrowWidth
      });
    }
    if (obj.settings.position === 'bottom-right')
    {
      var tipso_arrow = tipso_bubble.find(".tipso_arrow").eq(0);
      tipso_arrow.css({
        'margin-left': -obj.settings.width / 2,
        'margin-top': ''
      });
    }
    if (obj.settings.position === 'bottom-left')
    {
      var tipso_arrow = tipso_bubble.find(".tipso_arrow").eq(0);
      tipso_arrow.css({
        'margin-left': obj.settings.width / 2 - 2 * obj.settings.arrowWidth,
        'margin-top': ''
      });
    }

    /*
     * Check out of boundness
     */
    if (pos_left < $win.scrollLeft() && (obj.settings.position === 'bottom' || obj.settings.position === 'top'))
    {
      tipso_bubble.find('.tipso_arrow').css({
        marginLeft: pos_left - obj.settings.arrowWidth
      });
      pos_left = 0;
    }
    if (pos_left + obj.settings.width > $win.outerWidth() && (obj.settings.position === 'bottom' || obj.settings.position === 'top'))
    {
      diff = $win.outerWidth() - (pos_left + obj.settings.width);
      tipso_bubble.find('.tipso_arrow').css({
        marginLeft: -diff - obj.settings.arrowWidth,
        marginTop: ''
      });
      pos_left = pos_left + diff;
    }
    if (pos_left < $win.scrollLeft() &&
       (obj.settings.position === 'left' ||
        obj.settings.position === 'right' ||
        obj.settings.position === 'top-right' ||
        obj.settings.position === 'top-left' ||
        obj.settings.position === 'bottom-right' ||
        obj.settings.position === 'bottom-left'))
    {
      pos_left = $e.offset().left + ($e.outerWidth() / 2) - (realHeight(tipso_bubble).width / 2);
      tipso_bubble.find('.tipso_arrow').css({
        marginLeft: -obj.settings.arrowWidth,
        marginTop: ''
      });
      pos_top = $e.offset().top - realHeight(tipso_bubble).height - arrow;
      if (pos_top < $win.scrollTop())
      {
        pos_top = $e.offset().top + $e.outerHeight() + arrow;
        tipso_bubble.find('.tipso_arrow').css({
          'border-bottom-color': arrow_color,
          'border-top-color': 'transparent',
          'border-left-color': 'transparent',
          'border-right-color': 'transparent'
        });
        tipso_bubble.removeClass('top bottom left right');
        removeCornerClasses(tipso_bubble);
        tipso_bubble.addClass('bottom');
      }
      else
      {
        tipso_bubble.find('.tipso_arrow').css({
          'border-top-color': obj.settings.background,
          'border-bottom-color': 'transparent',
          'border-left-color': 'transparent',
          'border-right-color': 'transparent'
        });
        tipso_bubble.removeClass('top bottom left right');
        removeCornerClasses(tipso_bubble);
        tipso_bubble.addClass('top');
      }
      if (pos_left + obj.settings.width > $win.outerWidth())
      {
        diff = $win.outerWidth() - (pos_left + obj.settings.width);
        tipso_bubble.find('.tipso_arrow').css({
          marginLeft: -diff - obj.settings.arrowWidth,
          marginTop: ''
        });
        pos_left = pos_left + diff;
      }
      if (pos_left < $win.scrollLeft())
      {
        tipso_bubble.find('.tipso_arrow').css({
          marginLeft: pos_left - obj.settings.arrowWidth
        });
        pos_left = 0;
      }
    }

    /*
     * If out of bounds from the right hand side
     */
    if (pos_left + obj.settings.width > $win.outerWidth() &&
       (obj.settings.position === 'left' ||
        obj.settings.position === 'right' ||
        obj.settings.position === 'top-right' ||
        obj.settings.position === 'top-left' ||
        obj.settings.position === 'bottom-right' ||
        obj.settings.position === 'bottom-right'))
    {
      pos_left = $e.offset().left + ($e.outerWidth() / 2) - (realHeight(tipso_bubble).width / 2);
      tipso_bubble.find('.tipso_arrow').css({
        marginLeft: -obj.settings.arrowWidth,
        marginTop: ''
      });
      pos_top = $e.offset().top - realHeight(tipso_bubble).height - arrow;
      if (pos_top < $win.scrollTop())
      {
        pos_top = $e.offset().top + $e.outerHeight() + arrow;
        tipso_bubble.find('.tipso_arrow').css({
          'border-bottom-color': arrow_color,
          'border-top-color': 'transparent',
          'border-left-color': 'transparent',
          'border-right-color': 'transparent'
        });

        removeCornerClasses(tipso_bubble);
        tipso_bubble.removeClass('top bottom left right');
        tipso_bubble.addClass('bottom');
      }
      else
      {
        tipso_bubble.find('.tipso_arrow').css({
          'border-top-color': obj.settings.background,
          'border-bottom-color': 'transparent',
          'border-left-color': 'transparent',
          'border-right-color': 'transparent'
        });

        /*
         * Hide and show the appropriate rounded corners
         */
        removeCornerClasses(tipso_bubble);
        tipso_bubble.removeClass('top bottom left right');
        tipso_bubble.addClass('top');
      }
      if (pos_left + obj.settings.width > $win.outerWidth())
      {
        diff = $win.outerWidth() - (pos_left + obj.settings.width);
        tipso_bubble.find('.tipso_arrow').css({
          marginLeft: -diff - obj.settings.arrowWidth,
          marginTop: ''
        });
        pos_left = pos_left + diff;
      }
      if (pos_left < $win.scrollLeft())
      {
        tipso_bubble.find('.tipso_arrow').css({
          marginLeft: pos_left - obj.settings.arrowWidth
        });
        pos_left = 0;
      }
    }
    tipso_bubble.css({
      left: pos_left + obj.settings.offsetX,
      top: pos_top + obj.settings.offsetY
    });

    // If positioned right or left and tooltip is out of bounds change position
    // This position change will be temporary, because preferedPosition is there
    // to help!!
    if (pos_top < $win.scrollTop() && (obj.settings.position === 'right' || obj.settings.position === 'left'))
    {
      $e.tipso('update', 'position', 'bottom');
      reposition(obj);
    }
    if (pos_top + realHeight(tipso_bubble).height > $win.scrollTop() + $win.outerHeight() &&
        (obj.settings.position === 'right' || obj.settings.position === 'left'))
    {
      $e.tipso('update', 'position', 'top');
      reposition(obj);
    }

  }
  $[pluginName] = $.fn[pluginName] = function(options) {
    var args = arguments;
    if (options === undefined || typeof options === 'object') {
      if (!(this instanceof $)) {
        $.extend(defaults, options);
      }
      return this.each(function() {
        if (!$.data(this, 'plugin_' + pluginName)) {
          $.data(this, 'plugin_' + pluginName, new Plugin(this, options));
        }
      });
    } else if (typeof options === 'string' && options[0] !== '_' && options !==
      'init') {
      var returns;
      this.each(function() {
        var instance = $.data(this, 'plugin_' + pluginName);
        if (!instance) {
          instance = $.data(this, 'plugin_' + pluginName, new Plugin(
            this, options));
        }
        if (instance instanceof Plugin && typeof instance[options] ===
          'function') {
          returns = instance[options].apply(instance, Array.prototype.slice
            .call(args, 1));
        }
        if (options === 'destroy') {
          $.data(this, 'plugin_' + pluginName, null);
        }
      });
      return returns !== undefined ? returns : this;
    }
  };
}));

/*
	jQuery autoComplete v1.0.7-MODIFIED-FOR-O2
	Copyright (c) 2014 Simon Steinberger / Pixabay
	GitHub: https://github.com/Pixabay/jQuery-autoComplete
	License: http://www.opensource.org/licenses/mit-license.php
	WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
	WARNING: This is modified version for O2!
	WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
*/

(function($){
	$.fn.autoComplete = function(options){
		var o = $.extend({}, $.fn.autoComplete.defaults, options);

		// public methods
		if (typeof options == 'string') {
			this.each(function(){
				var that = $(this);
				if (options == 'destroy') {
					$(window).off('resize.autocomplete', that.updateSC);
					that.off('blur.autocomplete focus.autocomplete keydown.autocomplete keyup.autocomplete refresh.autocomplete');
					if (that.data('autocomplete'))
						that.attr('autocomplete', that.data('autocomplete'));
					else
						that.removeAttr('autocomplete');
					$(that.data('sc')).remove();
					that.removeData('sc').removeData('autocomplete');
				}
			});
			return this;
		}

		return this.each(function(){
			var that = $(this);
			// sc = 'suggestions container'
			that.sc = $('<div class="autocomplete-suggestions '+o.menuClass+'"></div>');
			that.data('sc', that.sc).data('autocomplete', that.attr('autocomplete'));
			that.attr('autocomplete', 'off');
			that.cache = {};
			that.last_val = '';

			that.updateSC = function(resize, next){
				that.sc.css({
					top: that.offset().top + that.outerHeight(),
					left: that.offset().left,
					width: that.outerWidth()
				});
				if (!resize) {
					that.sc.show();
					if (!that.sc.maxHeight) that.sc.maxHeight = parseInt(that.sc.css('max-height'));
					if (!that.sc.suggestionHeight) that.sc.suggestionHeight = $('.autocomplete-suggestion', that.sc).first().outerHeight();
					if (that.sc.suggestionHeight)
						if (!next) that.sc.scrollTop(0);
						else {
							var scrTop = that.sc.scrollTop(), selTop = next.offset().top - that.sc.offset().top;
							if (selTop + that.sc.suggestionHeight - that.sc.maxHeight > 0)
								that.sc.scrollTop(selTop + that.sc.suggestionHeight + scrTop - that.sc.maxHeight);
							else if (selTop < 0)
								that.sc.scrollTop(selTop + scrTop);
						}
				}
			}
			$(window).on('resize.autocomplete', that.updateSC);

			that.sc.appendTo('body');

			that.sc.on('mouseleave', '.autocomplete-suggestion', function (){
				$('.autocomplete-suggestion.selected').removeClass('selected');
			});

			that.sc.on('mouseenter', '.autocomplete-suggestion', function (){
				$('.autocomplete-suggestion.selected').removeClass('selected');
				$(this).addClass('selected');
			});

			that.sc.on('mousedown click', '.autocomplete-suggestion', function (e){
				var item = $(this), v = item.data('val');
				if (v || item.hasClass('autocomplete-suggestion')) { // else outside click
					that.val(v);
					o.onSelect(e, v, item);
					that.sc.hide();
				}
				return false;
			});

			that.on('blur.autocomplete', function(){
				try { over_sb = $('.autocomplete-suggestions:hover').length; } catch(e){ over_sb = 0; } // IE7 fix :hover
				if (!over_sb) {
					that.last_val = that.val();
					that.sc.hide();
					setTimeout(function(){ that.sc.hide(); }, 350); // hide suggestions on fast input
				} else if (!that.is(':focus')) setTimeout(function(){ that.focus(); }, 20);
			});

			if (!o.minChars) that.on('focus.autocomplete', function(){ that.last_val = '\n'; that.trigger('keyup.autocomplete'); });

			function suggest(data){
				var val = that.val();
				that.cache[val] = data;
				if (data.length && val.length >= o.minChars) {
					var s = '';
					for (var i=0;i<data.length;i++) s += o.renderItem(data[i], val);
					that.sc.html(s);
					that.updateSC(0);
				}
				else
					that.sc.hide();
			}

			that.on('keydown.autocomplete', function(e){
				// down (40), up (38)
				if ((e.which == 40 || e.which == 38) && that.sc.html()) {
					var next, sel = $('.autocomplete-suggestion.selected', that.sc);
					if (!sel.length) {
						next = (e.which == 40) ? $('.autocomplete-suggestion', that.sc).first() : $('.autocomplete-suggestion', that.sc).last();
						next.addClass('selected').data('val');
					} else {
						next = (e.which == 40) ? sel.next('.autocomplete-suggestion') : sel.prev('.autocomplete-suggestion');
						if (next.length) {
							sel.removeClass('selected');
							next.addClass('selected').data('val');
						}
						else {
							sel.removeClass('selected');
							next = 0;
						}
					}
					that.updateSC(0, next);
					return false;
				}
				// esc
				else if (e.which == 27) that.val(that.last_val).sc.hide();
				// enter or tab
				else if (e.which == 13 || e.which == 9) {
					var sel = $('.autocomplete-suggestion.selected', that.sc);
					if (sel.length && that.sc.is(':visible')) {
						var val = sel.data('val');
						that.val(val);
						that.last_val = val;
						o.onSelect(e, sel.data('val'), sel); setTimeout(function(){ that.sc.hide(); }, 20);
					}
				}
			});

			that.on('keyup.autocomplete', function(e){
				if (!~$.inArray(e.which, [13, 27, 35, 36, 37, 38, 39, 40])) {
					var val = that.val();
					if (val.length >= o.minChars) {
						if (val != that.last_val) {
							that.last_val = val;
							clearTimeout(that.timer);
							if (o.cache) {
								if (val in that.cache) { suggest(that.cache[val]); return; }
								// no requests if previous suggestions were empty
								for (var i=1; i<val.length-o.minChars; i++) {
									var part = val.slice(0, val.length-i);
									if (part in that.cache && !that.cache[part].length) { suggest([]); return; }
								}
							}
							that.timer = setTimeout(function(){ o.source(val, suggest) }, o.delay);
						}
					} else {
						that.last_val = val;
						that.sc.hide();
					}
				}
			});

			that.on('refresh.autocomplete', function(e){
				that.last_val = '';
				that.trigger('keyup.autocomplete');
			});
		});
	}

	$.fn.autoComplete.defaults = {
		source: 0,
		minChars: 3,
		delay: 150,
		cache: 1,
		menuClass: '',
		renderItem: function (item, search){
			// escape special characters
			search = search.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
			var re = new RegExp("(" + search.split(' ').join('|') + ")", "gi");
			return '<div class="autocomplete-suggestion" data-val="' + item + '">' + item.replace(re, "<b>$1</b>") + '</div>';
		},
		onSelect: function(e, term, item){}
	};
}(jQuery));

/* Simple JavaScript Inheritance
 * By John Resig http://ejohn.org/
 * MIT Licensed.
 */
// Inspired by base2 and Prototype
(function(){
	var initializing = false;

	// The base JQClass implementation (does nothing)
	window.JQClass = function(){};

	// Collection of derived classes
	JQClass.classes = {};
 
	// Create a new JQClass that inherits from this class
	JQClass.extend = function extender(prop) {
		var base = this.prototype;

		// Instantiate a base class (but only create the instance,
		// don't run the init constructor)
		initializing = true;
		var prototype = new this();
		initializing = false;

		// Copy the properties over onto the new prototype
		for (var name in prop) {
			// Check if we're overwriting an existing function
			prototype[name] = typeof prop[name] == 'function' &&
				typeof base[name] == 'function' ?
				(function(name, fn){
					return function() {
						var __super = this._super;

						// Add a new ._super() method that is the same method
						// but on the super-class
						this._super = function(args) {
							return base[name].apply(this, args || []);
						};

						var ret = fn.apply(this, arguments);				

						// The method only need to be bound temporarily, so we
						// remove it when we're done executing
						this._super = __super;

						return ret;
					};
				})(name, prop[name]) :
				prop[name];
		}

		// The dummy class constructor
		function JQClass() {
			// All construction is actually done in the init method
			if (!initializing && this._init) {
				this._init.apply(this, arguments);
			}
		}

		// Populate our constructed prototype object
		JQClass.prototype = prototype;

		// Enforce the constructor to be what we expect
		JQClass.prototype.constructor = JQClass;

		// And make this class extendable
		JQClass.extend = extender;

		return JQClass;
	};
})();

(function($) { // Ensure $, encapsulate

	/** Abstract base class for collection plugins v1.0.1.
		Written by Keith Wood (kbwood{at}iinet.com.au) December 2013.
		Licensed under the MIT (https://github.com/jquery/jquery/blob/master/MIT-LICENSE.txt) license.
		@module $.JQPlugin
		@abstract */
	JQClass.classes.JQPlugin = JQClass.extend({

		/** Name to identify this plugin.
			@example name: 'tabs' */
		name: 'plugin',

		/** Default options for instances of this plugin (default: {}).
			@example defaultOptions: {
 	selectedClass: 'selected',
 	triggers: 'click'
 } */
		defaultOptions: {},
		
		/** Options dependent on the locale.
			Indexed by language and (optional) country code, with '' denoting the default language (English/US).
			@example regionalOptions: {
	'': {
		greeting: 'Hi'
	}
 } */
		regionalOptions: {},
		
		/** Names of getter methods - those that can't be chained (default: []).
			@example _getters: ['activeTab'] */
		_getters: [],

		/** Retrieve a marker class for affected elements.
			@private
			@return {string} The marker class. */
		_getMarker: function() {
			return 'is-' + this.name;
		},
		
		/** Initialise the plugin.
			Create the jQuery bridge - plugin name <code>xyz</code>
			produces <code>$.xyz</code> and <code>$.fn.xyz</code>. */
		_init: function() {
			// Apply default localisations
			$.extend(this.defaultOptions, (this.regionalOptions && this.regionalOptions['']) || {});
			// Camel-case the name
			var jqName = camelCase(this.name);
			// Expose jQuery singleton manager
			$[jqName] = this;
			// Expose jQuery collection plugin
			$.fn[jqName] = function(options) {
				var otherArgs = Array.prototype.slice.call(arguments, 1);
				if ($[jqName]._isNotChained(options, otherArgs)) {
					return $[jqName][options].apply($[jqName], [this[0]].concat(otherArgs));
				}
				return this.each(function() {
					if (typeof options === 'string') {
						if (options[0] === '_' || !$[jqName][options]) {
							throw 'Unknown method: ' + options;
						}
						$[jqName][options].apply($[jqName], [this].concat(otherArgs));
					}
					else {
						$[jqName]._attach(this, options);
					}
				});
			};
		},

		/** Set default values for all subsequent instances.
			@param options {object} The new default options.
			@example $.plugin.setDefauls({name: value}) */
		setDefaults: function(options) {
			$.extend(this.defaultOptions, options || {});
		},
		
		/** Determine whether a method is a getter and doesn't permit chaining.
			@private
			@param name {string} The method name.
			@param otherArgs {any[]} Any other arguments for the method.
			@return {boolean} True if this method is a getter, false otherwise. */
		_isNotChained: function(name, otherArgs) {
			if (name === 'option' && (otherArgs.length === 0 ||
					(otherArgs.length === 1 && typeof otherArgs[0] === 'string'))) {
				return true;
			}
			return $.inArray(name, this._getters) > -1;
		},
		
		/** Initialise an element. Called internally only.
			Adds an instance object as data named for the plugin.
			@param elem {Element} The element to enhance.
			@param options {object} Overriding settings. */
		_attach: function(elem, options) {
			elem = $(elem);
			if (elem.hasClass(this._getMarker())) {
				return;
			}
			elem.addClass(this._getMarker());
			options = $.extend({}, this.defaultOptions, this._getMetadata(elem), options || {});
			var inst = $.extend({name: this.name, elem: elem, options: options},
				this._instSettings(elem, options));
			elem.data(this.name, inst); // Save instance against element
			this._postAttach(elem, inst);
			this.option(elem, options);
		},

		/** Retrieve additional instance settings.
			Override this in a sub-class to provide extra settings.
			@param elem {jQuery} The current jQuery element.
			@param options {object} The instance options.
			@return {object} Any extra instance values.
			@example _instSettings: function(elem, options) {
 	return {nav: elem.find(options.navSelector)};
 } */
		_instSettings: function(elem, options) {
			return {};
		},

		/** Plugin specific post initialisation.
			Override this in a sub-class to perform extra activities.
			@param elem {jQuery} The current jQuery element.
			@param inst {object} The instance settings.
			@example _postAttach: function(elem, inst) {
 	elem.on('click.' + this.name, function() {
 		...
 	});
 } */
		_postAttach: function(elem, inst) {
		},

		/** Retrieve metadata configuration from the element.
			Metadata is specified as an attribute:
			<code>data-&lt;plugin name>="&lt;setting name>: '&lt;value>', ..."</code>.
			Dates should be specified as strings in this format: 'new Date(y, m-1, d)'.
			@private
			@param elem {jQuery} The source element.
			@return {object} The inline configuration or {}. */
		_getMetadata: function(elem) {
			try {
				var data = elem.data(this.name.toLowerCase()) || '';
				data = data.replace(/'/g, '"');
				data = data.replace(/([a-zA-Z0-9]+):/g, function(match, group, i) { 
					var count = data.substring(0, i).match(/"/g); // Handle embedded ':'
					return (!count || count.length % 2 === 0 ? '"' + group + '":' : group + ':');
				});
				data = $.parseJSON('{' + data + '}');
				for (var name in data) { // Convert dates
					var value = data[name];
					if (typeof value === 'string' && value.match(/^new Date\((.*)\)$/)) {
						data[name] = eval(value);
					}
				}
				return data;
			}
			catch (e) {
				return {};
			}
		},

		/** Retrieve the instance data for element.
			@param elem {Element} The source element.
			@return {object} The instance data or {}. */
		_getInst: function(elem) {
			return $(elem).data(this.name) || {};
		},
		
		/** Retrieve or reconfigure the settings for a plugin.
			@param elem {Element} The source element.
			@param name {object|string} The collection of new option values or the name of a single option.
			@param [value] {any} The value for a single named option.
			@return {any|object} If retrieving a single value or all options.
			@example $(selector).plugin('option', 'name', value)
 $(selector).plugin('option', {name: value, ...})
 var value = $(selector).plugin('option', 'name')
 var options = $(selector).plugin('option') */
		option: function(elem, name, value) {
			elem = $(elem);
			var inst = elem.data(this.name);
			if  (!name || (typeof name === 'string' && value == null)) {
				var options = (inst || {}).options;
				return (options && name ? options[name] : options);
			}
			if (!elem.hasClass(this._getMarker())) {
				return;
			}
			var options = name || {};
			if (typeof name === 'string') {
				options = {};
				options[name] = value;
			}
			this._optionsChanged(elem, inst, options);
			$.extend(inst.options, options);
		},
		
		/** Plugin specific options processing.
			Old value available in <code>inst.options[name]</code>, new value in <code>options[name]</code>.
			Override this in a sub-class to perform extra activities.
			@param elem {jQuery} The current jQuery element.
			@param inst {object} The instance settings.
			@param options {object} The new options.
			@example _optionsChanged: function(elem, inst, options) {
 	if (options.name != inst.options.name) {
 		elem.removeClass(inst.options.name).addClass(options.name);
 	}
 } */
		_optionsChanged: function(elem, inst, options) {
		},
		
		/** Remove all trace of the plugin.
			Override <code>_preDestroy</code> for plugin-specific processing.
			@param elem {Element} The source element.
			@example $(selector).plugin('destroy') */
		destroy: function(elem) {
			elem = $(elem);
			if (!elem.hasClass(this._getMarker())) {
				return;
			}
			this._preDestroy(elem, this._getInst(elem));
			elem.removeData(this.name).removeClass(this._getMarker());
		},

		/** Plugin specific pre destruction.
			Override this in a sub-class to perform extra activities and undo everything that was
			done in the <code>_postAttach</code> or <code>_optionsChanged</code> functions.
			@param elem {jQuery} The current jQuery element.
			@param inst {object} The instance settings.
			@example _preDestroy: function(elem, inst) {
 	elem.off('.' + this.name);
 } */
		_preDestroy: function(elem, inst) {
		}
	});
	
	/** Convert names from hyphenated to camel-case.
		@private
		@param value {string} The original hyphenated name.
		@return {string} The camel-case version. */
	function camelCase(name) {
		return name.replace(/-([a-z])/g, function(match, group) {
			return group.toUpperCase();
		});
	}
	
	/** Expose the plugin base.
		@namespace "$.JQPlugin" */
	$.JQPlugin = {
	
		/** Create a new collection plugin.
			@memberof "$.JQPlugin"
			@param [superClass='JQPlugin'] {string} The name of the parent class to inherit from.
			@param overrides {object} The property/function overrides for the new class.
			@example $.JQPlugin.createPlugin({
 	name: 'tabs',
 	defaultOptions: {selectedClass: 'selected'},
 	_initSettings: function(elem, options) { return {...}; },
 	_postAttach: function(elem, inst) { ... }
 }); */
		createPlugin: function(superClass, overrides) {
			if (typeof superClass === 'object') {
				overrides = superClass;
				superClass = 'JQPlugin';
			}
			superClass = camelCase(superClass);
			var className = camelCase(overrides.name);
			JQClass.classes[className] = JQClass.classes[superClass].extend(overrides);
			new JQClass.classes[className]();
		}
	};

})(jQuery);
/* http://keith-wood.name/more.html
   Text truncation and show more for jQuery v2.0.1.
   Written by Keith Wood (kwood{at}iinet.com.au) May 2010.
   Available under the MIT (https://github.com/jquery/jquery/blob/master/LICENSE.txt) license. 
   Please attribute the author if you use it. */

(function($) { // Hide scope, no $ conflict

	var pluginName = 'more';

	/** Create the more plugin.
		<p>Sets an element to hide/show additional text.</p>
		<p>Expects HTML like:</p>
		<pre>&lt;p>...&lt;/p></pre>
		<p>Provide inline configuration like:</p>
		<pre>&lt;p data-more="name: 'value'">...&lt;/p></pre>
	 	@module More
		@augments JQPlugin
		@example $(selector).more()
 $(selector).more({length: 200, toggle: false}) */
	$.JQPlugin.createPlugin({
	
		/** The name of the plugin. */
		name: pluginName,

		/** More/less change callback.
			Triggered when the more/less button is clicked.
			@callback changeCallback
			@param expanding {boolean} True if expanding the text, false if collapsing. */
			
		/** Default settings for the plugin.
			@property [length=100] {number} Truncation length.
			@property [leeway=5] {number} Overrun allowed without truncation.
			@property [wordBreak=false] {boolean} True to break between words, false to break anywhere.
			@property [ignoreTags=['br','hr','img']] {string[]} Non-terminated tags to ignore.
			@property [toggle=true] {boolean} True to toggle, false to display and exit.
			@property [ellipsisText='...'] {string} Display text for ellipsis.
			@property [moreText='Show more'] {string} Display text for more link.
			@property [lessText='Show less'] {string} Display text for less link.
			@property [andNext=''] {string} Selector for any following tags to include in the collapse.
			@property [onChange=null] {changeCallback} Callback function when expanded/collapsed.
			@example onChange: function(expanding) {
 	console.log('Showing ' + (expanding ? 'more' : 'less'));
 } */
		defaultOptions: {
			length: 100,
			leeway: 5,
			wordBreak: false,
			ignoreTags: ['br', 'hr', 'img'],
			toggle: true,
			ellipsisText: '...',
			moreText: 'Show more',
			lessText: 'Show less',
			andNext: '',
			onChange: null
		},

		_ellipsisClass: pluginName + '-ellipsis', // The ellipsis marker class
		_linkClass: pluginName + '-link', // The link marker class
		_hiddenClass: pluginName + '-hidden', // The text hidden marker class
		
		_tagName: /^<(\w+).*>$/, // Extract a tag name

		_instSettings: function(elem, options) {
			return {html: elem.html()};
		},
		
		_optionsChanged: function(elem, inst, options) {
			var self = this;
			$.extend(inst.options, options);
			this._preDestroy(elem, inst); // Reset
			var html = '';
			if (elem.text().length > inst.options.length + inst.options.leeway) { // If text is longer
				var matches = elem.html().match(/(<[^>]+>)|([^<]+)/g); // Extract text and tags
				var i = 0;
				var pos = 0;
				var tags = [];
				for (; i < matches.length; i++) {
					if (matches[i][0] === '<') { // A tag
						if (matches[i][1] === '/' || matches[i][matches[i].length - 2] === '/') {
							tags.pop(); // Closing
						}
						else if ($.inArray(matches[i].toLowerCase().replace(this._tagName, '$1'),
								inst.options.ignoreTags) === -1) {
							tags.push(matches[i]); // Opening
						}
					}
					else if (pos + matches[i].length > inst.options.length) { // Found truncation point
						break;
					}
					else { // Count text
						pos += matches[i].length;
					}
				}
				pos = inst.options.length - pos; // Split point
				if (inst.options.wordBreak) { // Move back to start of word
					var matched = matches[i].substring(0, pos + 1).replace('\n', ' ').match(/^.*\W/m);
					pos = (matched ? matched[0].length - 1 : pos);
				}
				var closeTags = function(tags) { // Close any opened tags
					var html = '';
					for (var i = tags.length - 1; i >= 0; i--) {
						html += '</' + tags[i].replace(self._tagName, '$1') + '>';
					}
					return html;
				};
				// Generate new content
				html = matches.slice(0, i).join('') + matches[i].substring(0, pos) + closeTags(tags) +
					'<span class="' + this._ellipsisClass + '">' + inst.options.ellipsisText + '</span>' +
					'<span class="' + this._hiddenClass + '">' + tags.join('') + 
					matches[i].substring(pos) + closeTags(tags) + matches.slice(i + 1).join('') + '</span>';
			}
			else if (options.andNext && elem.nextAll(options.andNext).length) {
				html = elem.html();
			}
			if (html) {
				html += '<a href="#" class="' + this._linkClass + '">' + inst.options.moreText + '</a>';
				elem.html(html).find('a.' + this._linkClass).click(function(event) {
					var link = $(this);
					var expanding = link.html() === inst.options.moreText;
					link.html(expanding ? inst.options.lessText : inst.options.moreText).
						siblings('span.' + self._ellipsisClass + ',span.' + self._hiddenClass).toggle();
					if (options.andNext) {
						link.parent().nextAll(options.andNext).toggle();
					}
					if (!inst.options.toggle) { // Once only
						link.remove();
					}
					if ($.isFunction(inst.options.onChange)) { // Callback
						inst.options.onChange.apply(elem, [expanding]);
					}
					event.stopPropagation();
					return false;
				});
				if (options.andNext) {
					elem.nextAll(options.andNext).hide();
				}
			}
		},

		_preDestroy: function(elem, inst) {
			elem.html(inst.html);
			if (inst.options.andNext) {
				elem.nextAll(inst.options.andNext).show();
			}
		}
	});

})(jQuery);

/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */

/*global define: false Mustache: true*/

(function defineMustache (global, factory) {
  if (typeof exports === 'object' && exports && typeof exports.nodeName !== 'string') {
    factory(exports); // CommonJS
  } else if (typeof define === 'function' && define.amd) {
    define(['exports'], factory); // AMD
  } else {
    global.Mustache = {};
    factory(global.Mustache); // script, wsh, asp
  }
}(this, function mustacheFactory (mustache) {

  var objectToString = Object.prototype.toString;
  var isArray = Array.isArray || function isArrayPolyfill (object) {
    return objectToString.call(object) === '[object Array]';
  };

  function isFunction (object) {
    return typeof object === 'function';
  }

  /**
   * More correct typeof string handling array
   * which normally returns typeof 'object'
   */
  function typeStr (obj) {
    return isArray(obj) ? 'array' : typeof obj;
  }

  function escapeRegExp (string) {
    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
  }

  /**
   * Null safe way of checking whether or not an object,
   * including its prototype, has a given property
   */
  function hasProperty (obj, propName) {
    return obj != null && typeof obj === 'object' && (propName in obj);
  }

  /**
   * Safe way of detecting whether or not the given thing is a primitive and
   * whether it has the given property
   */
  function primitiveHasOwnProperty (primitive, propName) {  
    return (
      primitive != null
      && typeof primitive !== 'object'
      && primitive.hasOwnProperty
      && primitive.hasOwnProperty(propName)
    );
  }

  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
  // See https://github.com/janl/mustache.js/issues/189
  var regExpTest = RegExp.prototype.test;
  function testRegExp (re, string) {
    return regExpTest.call(re, string);
  }

  var nonSpaceRe = /\S/;
  function isWhitespace (string) {
    return !testRegExp(nonSpaceRe, string);
  }

  var entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;',
    '`': '&#x60;',
    '=': '&#x3D;'
  };

  function escapeHtml (string) {
    return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap (s) {
      return entityMap[s];
    });
  }

  var whiteRe = /\s*/;
  var spaceRe = /\s+/;
  var equalsRe = /\s*=/;
  var curlyRe = /\s*\}/;
  var tagRe = /#|\^|\/|>|\{|&|=|!/;

  /**
   * Breaks up the given `template` string into a tree of tokens. If the `tags`
   * argument is given here it must be an array with two string values: the
   * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
   * course, the default is to use mustaches (i.e. mustache.tags).
   *
   * A token is an array with at least 4 elements. The first element is the
   * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
   * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
   * all text that appears outside a symbol this element is "text".
   *
   * The second element of a token is its "value". For mustache tags this is
   * whatever else was inside the tag besides the opening symbol. For text tokens
   * this is the text itself.
   *
   * The third and fourth elements of the token are the start and end indices,
   * respectively, of the token in the original template.
   *
   * Tokens that are the root node of a subtree contain two more elements: 1) an
   * array of tokens in the subtree and 2) the index in the original template at
   * which the closing tag for that section begins.
   */
  function parseTemplate (template, tags) {
    if (!template)
      return [];

    var sections = [];     // Stack to hold section tokens
    var tokens = [];       // Buffer to hold the tokens
    var spaces = [];       // Indices of whitespace tokens on the current line
    var hasTag = false;    // Is there a {{tag}} on the current line?
    var nonSpace = false;  // Is there a non-space char on the current line?

    // Strips all whitespace tokens array for the current line
    // if there was a {{#tag}} on it and otherwise only space.
    function stripSpace () {
      if (hasTag && !nonSpace) {
        while (spaces.length)
          delete tokens[spaces.pop()];
      } else {
        spaces = [];
      }

      hasTag = false;
      nonSpace = false;
    }

    var openingTagRe, closingTagRe, closingCurlyRe;
    function compileTags (tagsToCompile) {
      if (typeof tagsToCompile === 'string')
        tagsToCompile = tagsToCompile.split(spaceRe, 2);

      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
        throw new Error('Invalid tags: ' + tagsToCompile);

      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\s*');
      closingTagRe = new RegExp('\\s*' + escapeRegExp(tagsToCompile[1]));
      closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tagsToCompile[1]));
    }

    compileTags(tags || mustache.tags);

    var scanner = new Scanner(template);

    var start, type, value, chr, token, openSection;
    while (!scanner.eos()) {
      start = scanner.pos;

      // Match any text between tags.
      value = scanner.scanUntil(openingTagRe);

      if (value) {
        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
          chr = value.charAt(i);

          if (isWhitespace(chr)) {
            spaces.push(tokens.length);
          } else {
            nonSpace = true;
          }

          tokens.push([ 'text', chr, start, start + 1 ]);
          start += 1;

          // Check for whitespace on the current line.
          if (chr === '\n')
            stripSpace();
        }
      }

      // Match the opening tag.
      if (!scanner.scan(openingTagRe))
        break;

      hasTag = true;

      // Get the tag type.
      type = scanner.scan(tagRe) || 'name';
      scanner.scan(whiteRe);

      // Get the tag value.
      if (type === '=') {
        value = scanner.scanUntil(equalsRe);
        scanner.scan(equalsRe);
        scanner.scanUntil(closingTagRe);
      } else if (type === '{') {
        value = scanner.scanUntil(closingCurlyRe);
        scanner.scan(curlyRe);
        scanner.scanUntil(closingTagRe);
        type = '&';
      } else {
        value = scanner.scanUntil(closingTagRe);
      }

      // Match the closing tag.
      if (!scanner.scan(closingTagRe))
        throw new Error('Unclosed tag at ' + scanner.pos);

      token = [ type, value, start, scanner.pos ];
      tokens.push(token);

      if (type === '#' || type === '^') {
        sections.push(token);
      } else if (type === '/') {
        // Check section nesting.
        openSection = sections.pop();

        if (!openSection)
          throw new Error('Unopened section "' + value + '" at ' + start);

        if (openSection[1] !== value)
          throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
      } else if (type === 'name' || type === '{' || type === '&') {
        nonSpace = true;
      } else if (type === '=') {
        // Set the tags for the next time around.
        compileTags(value);
      }
    }

    // Make sure there are no open sections when we're done.
    openSection = sections.pop();

    if (openSection)
      throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);

    return nestTokens(squashTokens(tokens));
  }

  /**
   * Combines the values of consecutive text tokens in the given `tokens` array
   * to a single token.
   */
  function squashTokens (tokens) {
    var squashedTokens = [];

    var token, lastToken;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      if (token) {
        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
          lastToken[1] += token[1];
          lastToken[3] = token[3];
        } else {
          squashedTokens.push(token);
          lastToken = token;
        }
      }
    }

    return squashedTokens;
  }

  /**
   * Forms the given array of `tokens` into a nested tree structure where
   * tokens that represent a section have two additional items: 1) an array of
   * all tokens that appear in that section and 2) the index in the original
   * template that represents the end of that section.
   */
  function nestTokens (tokens) {
    var nestedTokens = [];
    var collector = nestedTokens;
    var sections = [];

    var token, section;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      switch (token[0]) {
        case '#':
        case '^':
          collector.push(token);
          sections.push(token);
          collector = token[4] = [];
          break;
        case '/':
          section = sections.pop();
          section[5] = token[2];
          collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
          break;
        default:
          collector.push(token);
      }
    }

    return nestedTokens;
  }

  /**
   * A simple string scanner that is used by the template parser to find
   * tokens in template strings.
   */
  function Scanner (string) {
    this.string = string;
    this.tail = string;
    this.pos = 0;
  }

  /**
   * Returns `true` if the tail is empty (end of string).
   */
  Scanner.prototype.eos = function eos () {
    return this.tail === '';
  };

  /**
   * Tries to match the given regular expression at the current position.
   * Returns the matched text if it can match, the empty string otherwise.
   */
  Scanner.prototype.scan = function scan (re) {
    var match = this.tail.match(re);

    if (!match || match.index !== 0)
      return '';

    var string = match[0];

    this.tail = this.tail.substring(string.length);
    this.pos += string.length;

    return string;
  };

  /**
   * Skips all text until the given regular expression can be matched. Returns
   * the skipped string, which is the entire tail if no match can be made.
   */
  Scanner.prototype.scanUntil = function scanUntil (re) {
    var index = this.tail.search(re), match;

    switch (index) {
      case -1:
        match = this.tail;
        this.tail = '';
        break;
      case 0:
        match = '';
        break;
      default:
        match = this.tail.substring(0, index);
        this.tail = this.tail.substring(index);
    }

    this.pos += match.length;

    return match;
  };

  /**
   * Represents a rendering context by wrapping a view object and
   * maintaining a reference to the parent context.
   */
  function Context (view, parentContext) {
    this.view = view;
    this.cache = { '.': this.view };
    this.parent = parentContext;
  }

  /**
   * Creates a new context using the given view with this context
   * as the parent.
   */
  Context.prototype.push = function push (view) {
    return new Context(view, this);
  };

  /**
   * Returns the value of the given name in this context, traversing
   * up the context hierarchy if the value is absent in this context's view.
   */
  Context.prototype.lookup = function lookup (name) {
    var cache = this.cache;

    var value;
    if (cache.hasOwnProperty(name)) {
      value = cache[name];
    } else {
      var context = this, intermediateValue, names, index, lookupHit = false;

      while (context) {
        if (name.indexOf('.') > 0) {
          intermediateValue = context.view;
          names = name.split('.');
          index = 0;

          /**
           * Using the dot notion path in `name`, we descend through the
           * nested objects.
           *
           * To be certain that the lookup has been successful, we have to
           * check if the last object in the path actually has the property
           * we are looking for. We store the result in `lookupHit`.
           *
           * This is specially necessary for when the value has been set to
           * `undefined` and we want to avoid looking up parent contexts.
           *
           * In the case where dot notation is used, we consider the lookup
           * to be successful even if the last "object" in the path is
           * not actually an object but a primitive (e.g., a string, or an
           * integer), because it is sometimes useful to access a property
           * of an autoboxed primitive, such as the length of a string.
           **/
          while (intermediateValue != null && index < names.length) {
            if (index === names.length - 1)
              lookupHit = (
                hasProperty(intermediateValue, names[index]) 
                || primitiveHasOwnProperty(intermediateValue, names[index])
              );

            intermediateValue = intermediateValue[names[index++]];
          }
        } else {
          intermediateValue = context.view[name];

          /**
           * Only checking against `hasProperty`, which always returns `false` if
           * `context.view` is not an object. Deliberately omitting the check
           * against `primitiveHasOwnProperty` if dot notation is not used.
           *
           * Consider this example:
           * ```
           * Mustache.render("The length of a football field is {{#length}}{{length}}{{/length}}.", {length: "100 yards"})
           * ```
           *
           * If we were to check also against `primitiveHasOwnProperty`, as we do
           * in the dot notation case, then render call would return:
           *
           * "The length of a football field is 9."
           *
           * rather than the expected:
           *
           * "The length of a football field is 100 yards."
           **/
          lookupHit = hasProperty(context.view, name);
        }

        if (lookupHit) {
          value = intermediateValue;
          break;
        }

        context = context.parent;
      }

      cache[name] = value;
    }

    if (isFunction(value))
      value = value.call(this.view);

    return value;
  };

  /**
   * A Writer knows how to take a stream of tokens and render them to a
   * string, given a context. It also maintains a cache of templates to
   * avoid the need to parse the same template twice.
   */
  function Writer () {
    this.cache = {};
  }

  /**
   * Clears all cached templates in this writer.
   */
  Writer.prototype.clearCache = function clearCache () {
    this.cache = {};
  };

  /**
   * Parses and caches the given `template` according to the given `tags` or
   * `mustache.tags` if `tags` is omitted,  and returns the array of tokens
   * that is generated from the parse.
   */
  Writer.prototype.parse = function parse (template, tags) {
    var cache = this.cache;
    var cacheKey = template + ':' + (tags || mustache.tags).join(':');
    var tokens = cache[cacheKey];

    if (tokens == null)
      tokens = cache[cacheKey] = parseTemplate(template, tags);

    return tokens;
  };

  /**
   * High-level method that is used to render the given `template` with
   * the given `view`.
   *
   * The optional `partials` argument may be an object that contains the
   * names and templates of partials that are used in the template. It may
   * also be a function that is used to load partial templates on the fly
   * that takes a single argument: the name of the partial.
   *
   * If the optional `tags` argument is given here it must be an array with two
   * string values: the opening and closing tags used in the template (e.g.
   * [ "<%", "%>" ]). The default is to mustache.tags.
   */
  Writer.prototype.render = function render (template, view, partials, tags) {
    var tokens = this.parse(template, tags);
    var context = (view instanceof Context) ? view : new Context(view);
    return this.renderTokens(tokens, context, partials, template, tags);
  };

  /**
   * Low-level method that renders the given array of `tokens` using
   * the given `context` and `partials`.
   *
   * Note: The `originalTemplate` is only ever used to extract the portion
   * of the original template that was contained in a higher-order section.
   * If the template doesn't use higher-order sections, this argument may
   * be omitted.
   */
  Writer.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate, tags) {
    var buffer = '';

    var token, symbol, value;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      value = undefined;
      token = tokens[i];
      symbol = token[0];

      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);
      else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);
      else if (symbol === '>') value = this.renderPartial(token, context, partials, tags);
      else if (symbol === '&') value = this.unescapedValue(token, context);
      else if (symbol === 'name') value = this.escapedValue(token, context);
      else if (symbol === 'text') value = this.rawValue(token);

      if (value !== undefined)
        buffer += value;
    }

    return buffer;
  };

  Writer.prototype.renderSection = function renderSection (token, context, partials, originalTemplate) {
    var self = this;
    var buffer = '';
    var value = context.lookup(token[1]);

    // This function is used to render an arbitrary template
    // in the current context by higher-order sections.
    function subRender (template) {
      return self.render(template, context, partials);
    }

    if (!value) return;

    if (isArray(value)) {
      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);
      }
    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {
      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);
    } else if (isFunction(value)) {
      if (typeof originalTemplate !== 'string')
        throw new Error('Cannot use higher-order sections without the original template');

      // Extract the portion of the original template that the section contains.
      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);

      if (value != null)
        buffer += value;
    } else {
      buffer += this.renderTokens(token[4], context, partials, originalTemplate);
    }
    return buffer;
  };

  Writer.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate) {
    var value = context.lookup(token[1]);

    // Use JavaScript's definition of falsy. Include empty arrays.
    // See https://github.com/janl/mustache.js/issues/186
    if (!value || (isArray(value) && value.length === 0))
      return this.renderTokens(token[4], context, partials, originalTemplate);
  };

  Writer.prototype.renderPartial = function renderPartial (token, context, partials, tags) {
    if (!partials) return;

    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
    if (value != null)
      return this.renderTokens(this.parse(value, tags), context, partials, value);
  };

  Writer.prototype.unescapedValue = function unescapedValue (token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return value;
  };

  Writer.prototype.escapedValue = function escapedValue (token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return mustache.escape(value);
  };

  Writer.prototype.rawValue = function rawValue (token) {
    return token[1];
  };

  mustache.name = 'mustache.js';
  mustache.version = '3.0.1';
  mustache.tags = [ '{{', '}}' ];

  // All high-level mustache.* functions use this writer.
  var defaultWriter = new Writer();

  /**
   * Clears all cached templates in the default writer.
   */
  mustache.clearCache = function clearCache () {
    return defaultWriter.clearCache();
  };

  /**
   * Parses and caches the given template in the default writer and returns the
   * array of tokens it contains. Doing this ahead of time avoids the need to
   * parse templates on the fly as they are rendered.
   */
  mustache.parse = function parse (template, tags) {
    return defaultWriter.parse(template, tags);
  };

  /**
   * Renders the `template` with the given `view` and `partials` using the
   * default writer. If the optional `tags` argument is given here it must be an
   * array with two string values: the opening and closing tags used in the
   * template (e.g. [ "<%", "%>" ]). The default is to mustache.tags.
   */
  mustache.render = function render (template, view, partials, tags) {
    if (typeof template !== 'string') {
      throw new TypeError('Invalid template! Template should be a "string" ' +
                          'but "' + typeStr(template) + '" was given as the first ' +
                          'argument for mustache#render(template, view, partials)');
    }

    return defaultWriter.render(template, view, partials, tags);
  };

  // This is here for backwards compatibility with 0.4.x.,
  /*eslint-disable */ // eslint wants camel cased function name
  mustache.to_html = function to_html (template, view, partials, send) {
    /*eslint-enable*/

    var result = mustache.render(template, view, partials);

    if (isFunction(send)) {
      send(result);
    } else {
      return result;
    }
  };

  // Export the escaping function so that the user may override it.
  // See https://github.com/janl/mustache.js/issues/244
  mustache.escape = escapeHtml;

  // Export these mainly for testing, but also for advanced usage.
  mustache.Scanner = Scanner;
  mustache.Context = Context;
  mustache.Writer = Writer;

  return mustache;
}));

/*!
 * clipboard.js v2.0.6
 * https://clipboardjs.com/
 * 
 * Licensed MIT © Zeno Rocha
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ClipboardJS"] = factory();
	else
		root["ClipboardJS"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

function select(element) {
    var selectedText;

    if (element.nodeName === 'SELECT') {
        element.focus();

        selectedText = element.value;
    }
    else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {
        var isReadOnly = element.hasAttribute('readonly');

        if (!isReadOnly) {
            element.setAttribute('readonly', '');
        }

        element.select();
        element.setSelectionRange(0, element.value.length);

        if (!isReadOnly) {
            element.removeAttribute('readonly');
        }

        selectedText = element.value;
    }
    else {
        if (element.hasAttribute('contenteditable')) {
            element.focus();
        }

        var selection = window.getSelection();
        var range = document.createRange();

        range.selectNodeContents(element);
        selection.removeAllRanges();
        selection.addRange(range);

        selectedText = selection.toString();
    }

    return selectedText;
}

module.exports = select;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

function E () {
  // Keep this empty so it's easier to inherit from
  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
}

E.prototype = {
  on: function (name, callback, ctx) {
    var e = this.e || (this.e = {});

    (e[name] || (e[name] = [])).push({
      fn: callback,
      ctx: ctx
    });

    return this;
  },

  once: function (name, callback, ctx) {
    var self = this;
    function listener () {
      self.off(name, listener);
      callback.apply(ctx, arguments);
    };

    listener._ = callback
    return this.on(name, listener, ctx);
  },

  emit: function (name) {
    var data = [].slice.call(arguments, 1);
    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
    var i = 0;
    var len = evtArr.length;

    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }

    return this;
  },

  off: function (name, callback) {
    var e = this.e || (this.e = {});
    var evts = e[name];
    var liveEvents = [];

    if (evts && callback) {
      for (var i = 0, len = evts.length; i < len; i++) {
        if (evts[i].fn !== callback && evts[i].fn._ !== callback)
          liveEvents.push(evts[i]);
      }
    }

    // Remove event from queue to prevent memory leak
    // Suggested by https://github.com/lazd
    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

    (liveEvents.length)
      ? e[name] = liveEvents
      : delete e[name];

    return this;
  }
};

module.exports = E;
module.exports.TinyEmitter = E;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var is = __webpack_require__(3);
var delegate = __webpack_require__(4);

/**
 * Validates all params and calls the right
 * listener function based on its target type.
 *
 * @param {String|HTMLElement|HTMLCollection|NodeList} target
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listen(target, type, callback) {
    if (!target && !type && !callback) {
        throw new Error('Missing required arguments');
    }

    if (!is.string(type)) {
        throw new TypeError('Second argument must be a String');
    }

    if (!is.fn(callback)) {
        throw new TypeError('Third argument must be a Function');
    }

    if (is.node(target)) {
        return listenNode(target, type, callback);
    }
    else if (is.nodeList(target)) {
        return listenNodeList(target, type, callback);
    }
    else if (is.string(target)) {
        return listenSelector(target, type, callback);
    }
    else {
        throw new TypeError('First argument must be a String, HTMLElement, HTMLCollection, or NodeList');
    }
}

/**
 * Adds an event listener to a HTML element
 * and returns a remove listener function.
 *
 * @param {HTMLElement} node
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listenNode(node, type, callback) {
    node.addEventListener(type, callback);

    return {
        destroy: function() {
            node.removeEventListener(type, callback);
        }
    }
}

/**
 * Add an event listener to a list of HTML elements
 * and returns a remove listener function.
 *
 * @param {NodeList|HTMLCollection} nodeList
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listenNodeList(nodeList, type, callback) {
    Array.prototype.forEach.call(nodeList, function(node) {
        node.addEventListener(type, callback);
    });

    return {
        destroy: function() {
            Array.prototype.forEach.call(nodeList, function(node) {
                node.removeEventListener(type, callback);
            });
        }
    }
}

/**
 * Add an event listener to a selector
 * and returns a remove listener function.
 *
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listenSelector(selector, type, callback) {
    return delegate(document.body, selector, type, callback);
}

module.exports = listen;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

/**
 * Check if argument is a HTML element.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.node = function(value) {
    return value !== undefined
        && value instanceof HTMLElement
        && value.nodeType === 1;
};

/**
 * Check if argument is a list of HTML elements.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.nodeList = function(value) {
    var type = Object.prototype.toString.call(value);

    return value !== undefined
        && (type === '[object NodeList]' || type === '[object HTMLCollection]')
        && ('length' in value)
        && (value.length === 0 || exports.node(value[0]));
};

/**
 * Check if argument is a string.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.string = function(value) {
    return typeof value === 'string'
        || value instanceof String;
};

/**
 * Check if argument is a function.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.fn = function(value) {
    var type = Object.prototype.toString.call(value);

    return type === '[object Function]';
};


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var closest = __webpack_require__(5);

/**
 * Delegates event to a selector.
 *
 * @param {Element} element
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @param {Boolean} useCapture
 * @return {Object}
 */
function _delegate(element, selector, type, callback, useCapture) {
    var listenerFn = listener.apply(this, arguments);

    element.addEventListener(type, listenerFn, useCapture);

    return {
        destroy: function() {
            element.removeEventListener(type, listenerFn, useCapture);
        }
    }
}

/**
 * Delegates event to a selector.
 *
 * @param {Element|String|Array} [elements]
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @param {Boolean} useCapture
 * @return {Object}
 */
function delegate(elements, selector, type, callback, useCapture) {
    // Handle the regular Element usage
    if (typeof elements.addEventListener === 'function') {
        return _delegate.apply(null, arguments);
    }

    // Handle Element-less usage, it defaults to global delegation
    if (typeof type === 'function') {
        // Use `document` as the first parameter, then apply arguments
        // This is a short way to .unshift `arguments` without running into deoptimizations
        return _delegate.bind(null, document).apply(null, arguments);
    }

    // Handle Selector-based usage
    if (typeof elements === 'string') {
        elements = document.querySelectorAll(elements);
    }

    // Handle Array-like based usage
    return Array.prototype.map.call(elements, function (element) {
        return _delegate(element, selector, type, callback, useCapture);
    });
}

/**
 * Finds closest match and invokes callback.
 *
 * @param {Element} element
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @return {Function}
 */
function listener(element, selector, type, callback) {
    return function(e) {
        e.delegateTarget = closest(e.target, selector);

        if (e.delegateTarget) {
            callback.call(element, e);
        }
    }
}

module.exports = delegate;


/***/ }),
/* 5 */
/***/ (function(module, exports) {

var DOCUMENT_NODE_TYPE = 9;

/**
 * A polyfill for Element.matches()
 */
if (typeof Element !== 'undefined' && !Element.prototype.matches) {
    var proto = Element.prototype;

    proto.matches = proto.matchesSelector ||
                    proto.mozMatchesSelector ||
                    proto.msMatchesSelector ||
                    proto.oMatchesSelector ||
                    proto.webkitMatchesSelector;
}

/**
 * Finds the closest parent that matches a selector.
 *
 * @param {Element} element
 * @param {String} selector
 * @return {Function}
 */
function closest (element, selector) {
    while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
        if (typeof element.matches === 'function' &&
            element.matches(selector)) {
          return element;
        }
        element = element.parentNode;
    }
}

module.exports = closest;


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/select/src/select.js
var src_select = __webpack_require__(0);
var select_default = /*#__PURE__*/__webpack_require__.n(src_select);

// CONCATENATED MODULE: ./src/clipboard-action.js
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }



/**
 * Inner class which performs selection from either `text` or `target`
 * properties and then executes copy or cut operations.
 */

var clipboard_action_ClipboardAction = function () {
    /**
     * @param {Object} options
     */
    function ClipboardAction(options) {
        _classCallCheck(this, ClipboardAction);

        this.resolveOptions(options);
        this.initSelection();
    }

    /**
     * Defines base properties passed from constructor.
     * @param {Object} options
     */


    _createClass(ClipboardAction, [{
        key: 'resolveOptions',
        value: function resolveOptions() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            this.action = options.action;
            this.container = options.container;
            this.emitter = options.emitter;
            this.target = options.target;
            this.text = options.text;
            this.trigger = options.trigger;

            this.selectedText = '';
        }

        /**
         * Decides which selection strategy is going to be applied based
         * on the existence of `text` and `target` properties.
         */

    }, {
        key: 'initSelection',
        value: function initSelection() {
            if (this.text) {
                this.selectFake();
            } else if (this.target) {
                this.selectTarget();
            }
        }

        /**
         * Creates a fake textarea element, sets its value from `text` property,
         * and makes a selection on it.
         */

    }, {
        key: 'selectFake',
        value: function selectFake() {
            var _this = this;

            var isRTL = document.documentElement.getAttribute('dir') == 'rtl';

            this.removeFake();

            this.fakeHandlerCallback = function () {
                return _this.removeFake();
            };
            this.fakeHandler = this.container.addEventListener('click', this.fakeHandlerCallback) || true;

            this.fakeElem = document.createElement('textarea');
            // Prevent zooming on iOS
            this.fakeElem.style.fontSize = '12pt';
            // Reset box model
            this.fakeElem.style.border = '0';
            this.fakeElem.style.padding = '0';
            this.fakeElem.style.margin = '0';
            // Move element out of screen horizontally
            this.fakeElem.style.position = 'absolute';
            this.fakeElem.style[isRTL ? 'right' : 'left'] = '-9999px';
            // Move element to the same position vertically
            var yPosition = window.pageYOffset || document.documentElement.scrollTop;
            this.fakeElem.style.top = yPosition + 'px';

            this.fakeElem.setAttribute('readonly', '');
            this.fakeElem.value = this.text;

            this.container.appendChild(this.fakeElem);

            this.selectedText = select_default()(this.fakeElem);
            this.copyText();
        }

        /**
         * Only removes the fake element after another click event, that way
         * a user can hit `Ctrl+C` to copy because selection still exists.
         */

    }, {
        key: 'removeFake',
        value: function removeFake() {
            if (this.fakeHandler) {
                this.container.removeEventListener('click', this.fakeHandlerCallback);
                this.fakeHandler = null;
                this.fakeHandlerCallback = null;
            }

            if (this.fakeElem) {
                this.container.removeChild(this.fakeElem);
                this.fakeElem = null;
            }
        }

        /**
         * Selects the content from element passed on `target` property.
         */

    }, {
        key: 'selectTarget',
        value: function selectTarget() {
            this.selectedText = select_default()(this.target);
            this.copyText();
        }

        /**
         * Executes the copy operation based on the current selection.
         */

    }, {
        key: 'copyText',
        value: function copyText() {
            var succeeded = void 0;

            try {
                succeeded = document.execCommand(this.action);
            } catch (err) {
                succeeded = false;
            }

            this.handleResult(succeeded);
        }

        /**
         * Fires an event based on the copy operation result.
         * @param {Boolean} succeeded
         */

    }, {
        key: 'handleResult',
        value: function handleResult(succeeded) {
            this.emitter.emit(succeeded ? 'success' : 'error', {
                action: this.action,
                text: this.selectedText,
                trigger: this.trigger,
                clearSelection: this.clearSelection.bind(this)
            });
        }

        /**
         * Moves focus away from `target` and back to the trigger, removes current selection.
         */

    }, {
        key: 'clearSelection',
        value: function clearSelection() {
            if (this.trigger) {
                this.trigger.focus();
            }
            document.activeElement.blur();
            window.getSelection().removeAllRanges();
        }

        /**
         * Sets the `action` to be performed which can be either 'copy' or 'cut'.
         * @param {String} action
         */

    }, {
        key: 'destroy',


        /**
         * Destroy lifecycle.
         */
        value: function destroy() {
            this.removeFake();
        }
    }, {
        key: 'action',
        set: function set() {
            var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'copy';

            this._action = action;

            if (this._action !== 'copy' && this._action !== 'cut') {
                throw new Error('Invalid "action" value, use either "copy" or "cut"');
            }
        }

        /**
         * Gets the `action` property.
         * @return {String}
         */
        ,
        get: function get() {
            return this._action;
        }

        /**
         * Sets the `target` property using an element
         * that will be have its content copied.
         * @param {Element} target
         */

    }, {
        key: 'target',
        set: function set(target) {
            if (target !== undefined) {
                if (target && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && target.nodeType === 1) {
                    if (this.action === 'copy' && target.hasAttribute('disabled')) {
                        throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                    }

                    if (this.action === 'cut' && (target.hasAttribute('readonly') || target.hasAttribute('disabled'))) {
                        throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes');
                    }

                    this._target = target;
                } else {
                    throw new Error('Invalid "target" value, use a valid Element');
                }
            }
        }

        /**
         * Gets the `target` property.
         * @return {String|HTMLElement}
         */
        ,
        get: function get() {
            return this._target;
        }
    }]);

    return ClipboardAction;
}();

/* harmony default export */ var clipboard_action = (clipboard_action_ClipboardAction);
// EXTERNAL MODULE: ./node_modules/tiny-emitter/index.js
var tiny_emitter = __webpack_require__(1);
var tiny_emitter_default = /*#__PURE__*/__webpack_require__.n(tiny_emitter);

// EXTERNAL MODULE: ./node_modules/good-listener/src/listen.js
var listen = __webpack_require__(2);
var listen_default = /*#__PURE__*/__webpack_require__.n(listen);

// CONCATENATED MODULE: ./src/clipboard.js
var clipboard_typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var clipboard_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function clipboard_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





/**
 * Base class which takes one or more elements, adds event listeners to them,
 * and instantiates a new `ClipboardAction` on each click.
 */

var clipboard_Clipboard = function (_Emitter) {
    _inherits(Clipboard, _Emitter);

    /**
     * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
     * @param {Object} options
     */
    function Clipboard(trigger, options) {
        clipboard_classCallCheck(this, Clipboard);

        var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this));

        _this.resolveOptions(options);
        _this.listenClick(trigger);
        return _this;
    }

    /**
     * Defines if attributes would be resolved using internal setter functions
     * or custom functions that were passed in the constructor.
     * @param {Object} options
     */


    clipboard_createClass(Clipboard, [{
        key: 'resolveOptions',
        value: function resolveOptions() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            this.action = typeof options.action === 'function' ? options.action : this.defaultAction;
            this.target = typeof options.target === 'function' ? options.target : this.defaultTarget;
            this.text = typeof options.text === 'function' ? options.text : this.defaultText;
            this.container = clipboard_typeof(options.container) === 'object' ? options.container : document.body;
        }

        /**
         * Adds a click event listener to the passed trigger.
         * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
         */

    }, {
        key: 'listenClick',
        value: function listenClick(trigger) {
            var _this2 = this;

            this.listener = listen_default()(trigger, 'click', function (e) {
                return _this2.onClick(e);
            });
        }

        /**
         * Defines a new `ClipboardAction` on each click event.
         * @param {Event} e
         */

    }, {
        key: 'onClick',
        value: function onClick(e) {
            var trigger = e.delegateTarget || e.currentTarget;

            if (this.clipboardAction) {
                this.clipboardAction = null;
            }

            this.clipboardAction = new clipboard_action({
                action: this.action(trigger),
                target: this.target(trigger),
                text: this.text(trigger),
                container: this.container,
                trigger: trigger,
                emitter: this
            });
        }

        /**
         * Default `action` lookup function.
         * @param {Element} trigger
         */

    }, {
        key: 'defaultAction',
        value: function defaultAction(trigger) {
            return getAttributeValue('action', trigger);
        }

        /**
         * Default `target` lookup function.
         * @param {Element} trigger
         */

    }, {
        key: 'defaultTarget',
        value: function defaultTarget(trigger) {
            var selector = getAttributeValue('target', trigger);

            if (selector) {
                return document.querySelector(selector);
            }
        }

        /**
         * Returns the support of the given action, or all actions if no action is
         * given.
         * @param {String} [action]
         */

    }, {
        key: 'defaultText',


        /**
         * Default `text` lookup function.
         * @param {Element} trigger
         */
        value: function defaultText(trigger) {
            return getAttributeValue('text', trigger);
        }

        /**
         * Destroy lifecycle.
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            this.listener.destroy();

            if (this.clipboardAction) {
                this.clipboardAction.destroy();
                this.clipboardAction = null;
            }
        }
    }], [{
        key: 'isSupported',
        value: function isSupported() {
            var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['copy', 'cut'];

            var actions = typeof action === 'string' ? [action] : action;
            var support = !!document.queryCommandSupported;

            actions.forEach(function (action) {
                support = support && !!document.queryCommandSupported(action);
            });

            return support;
        }
    }]);

    return Clipboard;
}(tiny_emitter_default.a);

/**
 * Helper function to retrieve attribute value.
 * @param {String} suffix
 * @param {Element} element
 */


function getAttributeValue(suffix, element) {
    var attribute = 'data-clipboard-' + suffix;

    if (!element.hasAttribute(attribute)) {
        return;
    }

    return element.getAttribute(attribute);
}

/* harmony default export */ var clipboard = __webpack_exports__["default"] = (clipboard_Clipboard);

/***/ })
/******/ ])["default"];
});
/**
 * @popperjs/core v2.4.2 - MIT License
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.Popper = {}));
}(this, (function (exports) { 'use strict';

  function getBoundingClientRect(element) {
    var rect = element.getBoundingClientRect();
    return {
      width: rect.width,
      height: rect.height,
      top: rect.top,
      right: rect.right,
      bottom: rect.bottom,
      left: rect.left,
      x: rect.left,
      y: rect.top
    };
  }

  /*:: import type { Window } from '../types'; */

  /*:: declare function getWindow(node: Node | Window): Window; */
  function getWindow(node) {
    if (node.toString() !== '[object Window]') {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView : window;
    }

    return node;
  }

  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft: scrollLeft,
      scrollTop: scrollTop
    };
  }

  /*:: declare function isElement(node: mixed): boolean %checks(node instanceof
    Element); */

  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  /*:: declare function isHTMLElement(node: mixed): boolean %checks(node instanceof
    HTMLElement); */


  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }

  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }

  function getNodeName(element) {
    return element ? (element.nodeName || '').toLowerCase() : null;
  }

  function getDocumentElement(element) {
    // $FlowFixMe: assume body is always available
    return (isElement(element) ? element.ownerDocument : element.document).documentElement;
  }

  function getWindowScrollBarX(element) {
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    // Popper 1 is broken in this case and never had a bug report so let's assume
    // it's not an issue. I don't think anyone ever specifies width on <html>
    // anyway.
    // Browsers where the left scrollbar doesn't cause an issue report `0` for
    // this (e.g. Edge 2019, IE11, Safari)
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  function getComputedStyle(element) {
    return getWindow(element).getComputedStyle(element);
  }

  function isScrollParent(element) {
    // Firefox wants us to check `-x` and `-y` variations as well
    var _getComputedStyle = getComputedStyle(element),
        overflow = _getComputedStyle.overflow,
        overflowX = _getComputedStyle.overflowX,
        overflowY = _getComputedStyle.overflowY;

    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  // Composite means it takes into account transforms as well as layout.

  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }

    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement);
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };

    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }

      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }

    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  // Returns the layout rect of an element relative to its offsetParent. Layout
  // means it doesn't take into account transforms.
  function getLayoutRect(element) {
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  }

  function getParentNode(element) {
    if (getNodeName(element) === 'html') {
      return element;
    }

    return (// $FlowFixMe: this is a quicker (but less type safe) way to save quite some bytes from the bundle
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || // DOM Element detected
      // $FlowFixMe: need a better way to handle this...
      element.host || // ShadowRoot detected
      // $FlowFixMe: HTMLElement is a Node
      getDocumentElement(element) // fallback

    );
  }

  function getScrollParent(node) {
    if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
      // $FlowFixMe: assume body is always available
      return node.ownerDocument.body;
    }

    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }

    return getScrollParent(getParentNode(node));
  }

  /*
  given a DOM element, return the list of all scroll parents, up the list of ancesors
  until we get to the top window object. This list is what we attach scroll listeners
  to, because if any of these parent elements scroll, we'll need to re-calculate the 
  reference element's position.
  */

  function listScrollParents(element, list) {
    if (list === void 0) {
      list = [];
    }

    var scrollParent = getScrollParent(element);
    var isBody = getNodeName(scrollParent) === 'body';
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : // $FlowFixMe: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)));
  }

  function isTableElement(element) {
    return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
  }

  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle(element).position === 'fixed') {
      return null;
    }

    return element.offsetParent;
  } // `.offsetParent` reports `null` for fixed elements, while absolute elements
  // return the containing block


  function getContainingBlock(element) {
    var currentNode = getParentNode(element);

    while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
      // create a containing block.

      if (css.transform !== 'none' || css.perspective !== 'none' || css.willChange !== 'auto') {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }

    return null;
  } // Gets the closest ancestor positioned element. Handles some edge cases,
  // such as table ancestors and cross browser bugs.


  function getOffsetParent(element) {
    var window = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);

    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
      offsetParent = getTrueOffsetParent(offsetParent);
    }

    if (offsetParent && getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static') {
      return window;
    }

    return offsetParent || getContainingBlock(element) || window;
  }

  var top = 'top';
  var bottom = 'bottom';
  var right = 'right';
  var left = 'left';
  var auto = 'auto';
  var basePlacements = [top, bottom, right, left];
  var start = 'start';
  var end = 'end';
  var clippingParents = 'clippingParents';
  var viewport = 'viewport';
  var popper = 'popper';
  var reference = 'reference';
  var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []); // modifiers that need to read the DOM

  var beforeRead = 'beforeRead';
  var read = 'read';
  var afterRead = 'afterRead'; // pure-logic modifiers

  var beforeMain = 'beforeMain';
  var main = 'main';
  var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

  var beforeWrite = 'beforeWrite';
  var write = 'write';
  var afterWrite = 'afterWrite';
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  function order(modifiers) {
    var map = new Map();
    var visited = new Set();
    var result = [];
    modifiers.forEach(function (modifier) {
      map.set(modifier.name, modifier);
    }); // On visiting object, check for its dependencies and visit them recursively

    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function (dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);

          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }

    modifiers.forEach(function (modifier) {
      if (!visited.has(modifier.name)) {
        // check for visited object
        sort(modifier);
      }
    });
    return result;
  }

  function orderModifiers(modifiers) {
    // order based on dependencies
    var orderedModifiers = order(modifiers); // order based on phase

    return modifierPhases.reduce(function (acc, phase) {
      return acc.concat(orderedModifiers.filter(function (modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  function debounce(fn) {
    var pending;
    return function () {
      if (!pending) {
        pending = new Promise(function (resolve) {
          Promise.resolve().then(function () {
            pending = undefined;
            resolve(fn());
          });
        });
      }

      return pending;
    };
  }

  function format(str) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return [].concat(args).reduce(function (p, c) {
      return p.replace(/%s/, c);
    }, str);
  }

  var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
  var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
  var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
  function validateModifiers(modifiers) {
    modifiers.forEach(function (modifier) {
      Object.keys(modifier).forEach(function (key) {
        switch (key) {
          case 'name':
            if (typeof modifier.name !== 'string') {
              console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
            }

            break;

          case 'enabled':
            if (typeof modifier.enabled !== 'boolean') {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
            }

          case 'phase':
            if (modifierPhases.indexOf(modifier.phase) < 0) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
            }

            break;

          case 'fn':
            if (typeof modifier.fn !== 'function') {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
            }

            break;

          case 'effect':
            if (typeof modifier.effect !== 'function') {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
            }

            break;

          case 'requires':
            if (!Array.isArray(modifier.requires)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
            }

            break;

          case 'requiresIfExists':
            if (!Array.isArray(modifier.requiresIfExists)) {
              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
            }

            break;

          case 'options':
          case 'data':
            break;

          default:
            console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
              return "\"" + s + "\"";
            }).join(', ') + "; but \"" + key + "\" was provided.");
        }

        modifier.requires && modifier.requires.forEach(function (requirement) {
          if (modifiers.find(function (mod) {
            return mod.name === requirement;
          }) == null) {
            console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
          }
        });
      });
    });
  }

  function uniqueBy(arr, fn) {
    var identifiers = new Set();
    return arr.filter(function (item) {
      var identifier = fn(item);

      if (!identifiers.has(identifier)) {
        identifiers.add(identifier);
        return true;
      }
    });
  }

  function getBasePlacement(placement) {
    return placement.split('-')[0];
  }

  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function (merged, current) {
      var existing = merged[current.name];
      merged[current.name] = existing ? Object.assign(Object.assign(Object.assign({}, existing), current), {}, {
        options: Object.assign(Object.assign({}, existing.options), current.options),
        data: Object.assign(Object.assign({}, existing.data), current.data)
      }) : current;
      return merged;
    }, {}); // IE11 does not support Object.values

    return Object.keys(merged).map(function (key) {
      return merged[key];
    });
  }

  var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
  var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
  var DEFAULT_OPTIONS = {
    placement: 'bottom',
    modifiers: [],
    strategy: 'absolute'
  };

  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return !args.some(function (element) {
      return !(element && typeof element.getBoundingClientRect === 'function');
    });
  }

  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }

    var _generatorOptions = generatorOptions,
        _generatorOptions$def = _generatorOptions.defaultModifiers,
        defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
        _generatorOptions$def2 = _generatorOptions.defaultOptions,
        defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper(reference, popper, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var state = {
        placement: 'bottom',
        orderedModifiers: [],
        options: Object.assign(Object.assign({}, DEFAULT_OPTIONS), defaultOptions),
        modifiersData: {},
        elements: {
          reference: reference,
          popper: popper
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state: state,
        setOptions: function setOptions(options) {
          cleanupModifierEffects();
          state.options = Object.assign(Object.assign(Object.assign({}, defaultOptions), state.options), options);
          state.scrollParents = {
            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
            popper: listScrollParents(popper)
          }; // Orders the modifiers based on their dependencies and `phase`
          // properties

          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

          state.orderedModifiers = orderedModifiers.filter(function (m) {
            return m.enabled;
          }); // Validate the provided modifiers so that the consumer will get warned
          // if one of the modifiers is invalid for any reason

          {
            var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
              var name = _ref.name;
              return name;
            });
            validateModifiers(modifiers);

            if (getBasePlacement(state.options.placement) === auto) {
              var flipModifier = state.orderedModifiers.find(function (_ref2) {
                var name = _ref2.name;
                return name === 'flip';
              });

              if (!flipModifier) {
                console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
              }
            }

            var _getComputedStyle = getComputedStyle(popper),
                marginTop = _getComputedStyle.marginTop,
                marginRight = _getComputedStyle.marginRight,
                marginBottom = _getComputedStyle.marginBottom,
                marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
            // cause bugs with positioning, so we'll warn the consumer


            if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
              return parseFloat(margin);
            })) {
              console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
            }
          }

          runModifierEffects();
          return instance.update();
        },
        // Sync update – it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }

          var _state$elements = state.elements,
              reference = _state$elements.reference,
              popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
          // anymore

          if (!areValidElements(reference, popper)) {
            {
              console.error(INVALID_ELEMENT_ERROR);
            }

            return;
          } // Store the reference and popper rects to be read by modifiers


          state.rects = {
            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
            popper: getLayoutRect(popper)
          }; // Modifiers have the ability to reset the current update cycle. The
          // most common use case for this is the `flip` modifier changing the
          // placement, which then needs to re-run all the modifiers, because the
          // logic was previously ran for the previous placement and is therefore
          // stale/incorrect

          state.reset = false;
          state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
          // is filled with the initial data specified by the modifier. This means
          // it doesn't persist and is fresh on each update.
          // To ensure persistent data, use `${name}#persistent`

          state.orderedModifiers.forEach(function (modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          var __debug_loops__ = 0;

          for (var index = 0; index < state.orderedModifiers.length; index++) {
            {
              __debug_loops__ += 1;

              if (__debug_loops__ > 100) {
                console.error(INFINITE_LOOP_ERROR);
                break;
              }
            }

            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }

            var _state$orderedModifie = state.orderedModifiers[index],
                fn = _state$orderedModifie.fn,
                _state$orderedModifie2 = _state$orderedModifie.options,
                _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                name = _state$orderedModifie.name;

            if (typeof fn === 'function') {
              state = fn({
                state: state,
                options: _options,
                name: name,
                instance: instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update – it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce(function () {
          return new Promise(function (resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };

      if (!areValidElements(reference, popper)) {
        {
          console.error(INVALID_ELEMENT_ERROR);
        }

        return instance;
      }

      instance.setOptions(options).then(function (state) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state);
        }
      }); // Modifiers have the ability to execute arbitrary code before the first
      // update cycle runs. They will be executed in the same order as the update
      // cycle. This is useful when a modifier adds some persistent data that
      // other modifiers need to use, but the modifier is run after the dependent
      // one.

      function runModifierEffects() {
        state.orderedModifiers.forEach(function (_ref3) {
          var name = _ref3.name,
              _ref3$options = _ref3.options,
              options = _ref3$options === void 0 ? {} : _ref3$options,
              effect = _ref3.effect;

          if (typeof effect === 'function') {
            var cleanupFn = effect({
              state: state,
              name: name,
              instance: instance,
              options: options
            });

            var noopFn = function noopFn() {};

            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }

      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function (fn) {
          return fn();
        });
        effectCleanupFns = [];
      }

      return instance;
    };
  }

  var passive = {
    passive: true
  };

  function effect(_ref) {
    var state = _ref.state,
        instance = _ref.instance,
        options = _ref.options;
    var _options$scroll = options.scroll,
        scroll = _options$scroll === void 0 ? true : _options$scroll,
        _options$resize = options.resize,
        resize = _options$resize === void 0 ? true : _options$resize;
    var window = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.addEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.addEventListener('resize', instance.update, passive);
    }

    return function () {
      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.removeEventListener('scroll', instance.update, passive);
        });
      }

      if (resize) {
        window.removeEventListener('resize', instance.update, passive);
      }
    };
  } // eslint-disable-next-line import/no-unused-modules


  var eventListeners = {
    name: 'eventListeners',
    enabled: true,
    phase: 'write',
    fn: function fn() {},
    effect: effect,
    data: {}
  };

  function getVariation(placement) {
    return placement.split('-')[1];
  }

  function getMainAxisFromPlacement(placement) {
    return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
  }

  function computeOffsets(_ref) {
    var reference = _ref.reference,
        element = _ref.element,
        placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference.x + reference.width / 2 - element.width / 2;
    var commonY = reference.y + reference.height / 2 - element.height / 2;
    var offsets;

    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference.y - element.height
        };
        break;

      case bottom:
        offsets = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;

      case right:
        offsets = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;

      case left:
        offsets = {
          x: reference.x - element.width,
          y: commonY
        };
        break;

      default:
        offsets = {
          x: reference.x,
          y: reference.y
        };
    }

    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

    if (mainAxis != null) {
      var len = mainAxis === 'y' ? 'height' : 'width';

      switch (variation) {
        case start:
          offsets[mainAxis] = Math.floor(offsets[mainAxis]) - Math.floor(reference[len] / 2 - element[len] / 2);
          break;

        case end:
          offsets[mainAxis] = Math.floor(offsets[mainAxis]) + Math.ceil(reference[len] / 2 - element[len] / 2);
          break;
      }
    }

    return offsets;
  }

  function popperOffsets(_ref) {
    var state = _ref.state,
        name = _ref.name;
    // Offsets are the actual position the popper needs to have to be
    // properly positioned near its reference element
    // This is the most basic placement, and will be adjusted by
    // the modifiers in the next step
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: 'absolute',
      placement: state.placement
    });
  } // eslint-disable-next-line import/no-unused-modules


  var popperOffsets$1 = {
    name: 'popperOffsets',
    enabled: true,
    phase: 'read',
    fn: popperOffsets,
    data: {}
  };

  var unsetSides = {
    top: 'auto',
    right: 'auto',
    bottom: 'auto',
    left: 'auto'
  }; // Round the offsets to the nearest suitable subpixel based on the DPR.
  // Zooming can change the DPR, but it seems to report a value that will
  // cleanly divide the values into the appropriate subpixels.

  function roundOffsets(_ref) {
    var x = _ref.x,
        y = _ref.y;
    var win = window;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: Math.round(x * dpr) / dpr || 0,
      y: Math.round(y * dpr) / dpr || 0
    };
  }

  function mapToStyles(_ref2) {
    var _Object$assign2;

    var popper = _ref2.popper,
        popperRect = _ref2.popperRect,
        placement = _ref2.placement,
        offsets = _ref2.offsets,
        position = _ref2.position,
        gpuAcceleration = _ref2.gpuAcceleration,
        adaptive = _ref2.adaptive;

    var _roundOffsets = roundOffsets(offsets),
        x = _roundOffsets.x,
        y = _roundOffsets.y;

    var hasX = offsets.hasOwnProperty('x');
    var hasY = offsets.hasOwnProperty('y');
    var sideX = left;
    var sideY = top;
    var win = window;

    if (adaptive) {
      var offsetParent = getOffsetParent(popper);

      if (offsetParent === getWindow(popper)) {
        offsetParent = getDocumentElement(popper);
      } // $FlowFixMe: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it

      /*:: offsetParent = (offsetParent: Element); */


      if (placement === top) {
        sideY = bottom;
        y -= offsetParent.clientHeight - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }

      if (placement === left) {
        sideX = right;
        x -= offsetParent.clientWidth - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }

    var commonStyles = Object.assign({
      position: position
    }, adaptive && unsetSides);

    if (gpuAcceleration) {
      var _Object$assign;

      return Object.assign(Object.assign({}, commonStyles), {}, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }

    return Object.assign(Object.assign({}, commonStyles), {}, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
  }

  function computeStyles(_ref3) {
    var state = _ref3.state,
        options = _ref3.options;
    var _options$gpuAccelerat = options.gpuAcceleration,
        gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
        _options$adaptive = options.adaptive,
        adaptive = _options$adaptive === void 0 ? true : _options$adaptive;

    {
      var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || '';

      if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
        return transitionProperty.indexOf(property) >= 0;
      })) {
        console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
      }
    }

    var commonStyles = {
      placement: getBasePlacement(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration: gpuAcceleration
    };

    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign(Object.assign({}, state.styles.popper), mapToStyles(Object.assign(Object.assign({}, commonStyles), {}, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive: adaptive
      })));
    }

    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign(Object.assign({}, state.styles.arrow), mapToStyles(Object.assign(Object.assign({}, commonStyles), {}, {
        offsets: state.modifiersData.arrow,
        position: 'absolute',
        adaptive: false
      })));
    }

    state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), {}, {
      'data-popper-placement': state.placement
    });
  } // eslint-disable-next-line import/no-unused-modules


  var computeStyles$1 = {
    name: 'computeStyles',
    enabled: true,
    phase: 'beforeWrite',
    fn: computeStyles,
    data: {}
  };

  // and applies them to the HTMLElements such as popper and arrow

  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function (name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name]; // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      } // Flow doesn't support to extend this property, but it's the most
      // effective way to apply styles to an HTMLElement
      // $FlowFixMe


      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (name) {
        var value = attributes[name];

        if (value === false) {
          element.removeAttribute(name);
        } else {
          element.setAttribute(name, value === true ? '' : value);
        }
      });
    });
  }

  function effect$1(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: '0',
        top: '0',
        margin: '0'
      },
      arrow: {
        position: 'absolute'
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);

    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }

    return function () {
      Object.keys(state.elements).forEach(function (name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

        var style = styleProperties.reduce(function (style, property) {
          style[property] = '';
          return style;
        }, {}); // arrow is optional + virtual elements

        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        } // Flow doesn't support to extend this property, but it's the most
        // effective way to apply styles to an HTMLElement
        // $FlowFixMe


        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  } // eslint-disable-next-line import/no-unused-modules


  var applyStyles$1 = {
    name: 'applyStyles',
    enabled: true,
    phase: 'write',
    fn: applyStyles,
    effect: effect$1,
    requires: ['computeStyles']
  };

  function distanceAndSkiddingToXY(placement, rects, offset) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

    var _ref = typeof offset === 'function' ? offset(Object.assign(Object.assign({}, rects), {}, {
      placement: placement
    })) : offset,
        skidding = _ref[0],
        distance = _ref[1];

    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }

  function offset(_ref2) {
    var state = _ref2.state,
        options = _ref2.options,
        name = _ref2.name;
    var _options$offset = options.offset,
        offset = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function (acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement],
        x = _data$state$placement.x,
        y = _data$state$placement.y;

    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }

    state.modifiersData[name] = data;
  } // eslint-disable-next-line import/no-unused-modules


  var offset$1 = {
    name: 'offset',
    enabled: true,
    phase: 'main',
    requires: ['popperOffsets'],
    fn: offset
  };

  var hash = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash[matched];
    });
  }

  var hash$1 = {
    start: 'end',
    end: 'start'
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function (matched) {
      return hash$1[matched];
    });
  }

  function getViewportRect(element) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
    // can be obscured underneath it.
    // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
    // if it isn't open, so if this isn't available, the popper will be detected
    // to overflow the bottom of the screen too early.

    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
      // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
      // errors due to floating point numbers, so we need to check precision.
      // Safari returns a number <= 0, usually < -1 when pinch-zoomed
      // Feature detection fails in mobile emulation mode in Chrome.
      // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
      // 0.001
      // Fallback here: "Not Safari" userAgent

      if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }

    return {
      width: width,
      height: height,
      x: x + getWindowScrollBarX(element),
      y: y
    };
  }

  // of the `<html>` and `<body>` rect bounds if horizontally scrollable

  function getDocumentRect(element) {
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = element.ownerDocument.body;
    var width = Math.max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = Math.max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;

    if (getComputedStyle(body || html).direction === 'rtl') {
      x += Math.max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }

    return {
      width: width,
      height: height,
      x: x,
      y: y
    };
  }

  function contains(parent, child) {
    // $FlowFixMe: hasOwnProperty doesn't seem to work in tests
    var isShadow = Boolean(child.getRootNode && child.getRootNode().host); // First, attempt with faster native method

    if (parent.contains(child)) {
      return true;
    } // then fallback to custom implementation with Shadow DOM support
    else if (isShadow) {
        var next = child;

        do {
          if (next && parent.isSameNode(next)) {
            return true;
          } // $FlowFixMe: need a better way to handle this...


          next = next.parentNode || next.host;
        } while (next);
      } // Give up, the result is false


    return false;
  }

  function rectToClientRect(rect) {
    return Object.assign(Object.assign({}, rect), {}, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  function getInnerBoundingClientRect(element) {
    var rect = getBoundingClientRect(element);
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }

  function getClientRectFromMixedType(element, clippingParent) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  } // A "clipping parent" is an overflowable container with the characteristic of
  // clipping (or hiding) overflowing elements with a position different from
  // `initial`


  function getClippingParents(element) {
    var clippingParents = listScrollParents(element);
    var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

    if (!isElement(clipperElement)) {
      return [];
    } // $FlowFixMe: https://github.com/facebook/flow/issues/1414


    return clippingParents.filter(function (clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement);
    });
  } // Gets the maximum area that the element is visible in due to any number of
  // clipping parents


  function getClippingRect(element, boundary, rootBoundary) {
    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
    var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents[0];
    var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent);
      accRect.top = Math.max(rect.top, accRect.top);
      accRect.right = Math.min(rect.right, accRect.right);
      accRect.bottom = Math.min(rect.bottom, accRect.bottom);
      accRect.left = Math.max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  function mergePaddingObject(paddingObject) {
    return Object.assign(Object.assign({}, getFreshSideObject()), paddingObject);
  }

  function expandToHashMap(value, keys) {
    return keys.reduce(function (hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        _options$placement = _options.placement,
        placement = _options$placement === void 0 ? state.placement : _options$placement,
        _options$boundary = _options.boundary,
        boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
        _options$rootBoundary = _options.rootBoundary,
        rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
        _options$elementConte = _options.elementContext,
        elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
        _options$altBoundary = _options.altBoundary,
        altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
        _options$padding = _options.padding,
        padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var referenceElement = state.elements.reference;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
    var referenceClientRect = getBoundingClientRect(referenceElement);
    var popperOffsets = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: 'absolute',
      placement: placement
    });
    var popperClientRect = rectToClientRect(Object.assign(Object.assign({}, popperRect), popperOffsets));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
    // 0 or negative = within the clipping rect

    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

    if (elementContext === popper && offsetData) {
      var offset = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function (key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
        overflowOffsets[key] += offset[axis] * multiply;
      });
    }

    return overflowOffsets;
  }

  /*:: type OverflowsMap = { [ComputedPlacement]: number }; */

  /*;; type OverflowsMap = { [key in ComputedPlacement]: number }; */
  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        placement = _options.placement,
        boundary = _options.boundary,
        rootBoundary = _options.rootBoundary,
        padding = _options.padding,
        flipVariations = _options.flipVariations,
        _options$allowedAutoP = _options.allowedAutoPlacements,
        allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements$1 = (variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
      return getVariation(placement) === variation;
    }) : basePlacements).filter(function (placement) {
      return allowedAutoPlacements.indexOf(placement) >= 0;
    }); // $FlowFixMe: Flow seems to have problems with two array unions...

    var overflows = placements$1.reduce(function (acc, placement) {
      acc[placement] = detectOverflow(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding
      })[getBasePlacement(placement)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function (a, b) {
      return overflows[a] - overflows[b];
    });
  }

  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }

    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }

  function flip(_ref) {
    var state = _ref.state,
        options = _ref.options,
        name = _ref.name;

    if (state.modifiersData[name]._skip) {
      return;
    }

    var _options$mainAxis = options.mainAxis,
        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
        _options$altAxis = options.altAxis,
        checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
        specifiedFallbackPlacements = options.fallbackPlacements,
        padding = options.padding,
        boundary = options.boundary,
        rootBoundary = options.rootBoundary,
        altBoundary = options.altBoundary,
        _options$flipVariatio = options.flipVariations,
        flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
        allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
      return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        flipVariations: flipVariations,
        allowedAutoPlacements: allowedAutoPlacements
      }) : placement);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements[0];

    for (var i = 0; i < placements.length; i++) {
      var placement = placements[i];

      var _basePlacement = getBasePlacement(placement);

      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? 'width' : 'height';
      var overflow = detectOverflow(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        altBoundary: altBoundary,
        padding: padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }

      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];

      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }

      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }

      if (checks.every(function (check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }

      checksMap.set(placement, checks);
    }

    if (makeFallbackChecks) {
      // `2` may be desired in some cases – research later
      var numberOfChecks = flipVariations ? 3 : 1;

      var _loop = function _loop(_i) {
        var fittingPlacement = placements.find(function (placement) {
          var checks = checksMap.get(placement);

          if (checks) {
            return checks.slice(0, _i).every(function (check) {
              return check;
            });
          }
        });

        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };

      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);

        if (_ret === "break") break;
      }
    }

    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  } // eslint-disable-next-line import/no-unused-modules


  var flip$1 = {
    name: 'flip',
    enabled: true,
    phase: 'main',
    fn: flip,
    requiresIfExists: ['offset'],
    data: {
      _skip: false
    }
  };

  function getAltAxis(axis) {
    return axis === 'x' ? 'y' : 'x';
  }

  function within(min, value, max) {
    return Math.max(min, Math.min(value, max));
  }

  function preventOverflow(_ref) {
    var state = _ref.state,
        options = _ref.options,
        name = _ref.name;
    var _options$mainAxis = options.mainAxis,
        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
        _options$altAxis = options.altAxis,
        checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
        boundary = options.boundary,
        rootBoundary = options.rootBoundary,
        altBoundary = options.altBoundary,
        padding = options.padding,
        _options$tether = options.tether,
        tether = _options$tether === void 0 ? true : _options$tether,
        _options$tetherOffset = options.tetherOffset,
        tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      altBoundary: altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign(Object.assign({}, state.rects), {}, {
      placement: state.placement
    })) : tetherOffset;
    var data = {
      x: 0,
      y: 0
    };

    if (!popperOffsets) {
      return;
    }

    if (checkMainAxis) {
      var mainSide = mainAxis === 'y' ? top : left;
      var altSide = mainAxis === 'y' ? bottom : right;
      var len = mainAxis === 'y' ? 'height' : 'width';
      var offset = popperOffsets[mainAxis];
      var min = popperOffsets[mainAxis] + overflow[mainSide];
      var max = popperOffsets[mainAxis] - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
      // outside the reference bounds

      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
      // to include its full size in the calculation. If the reference is small
      // and near the edge of a boundary, the popper can overflow even if the
      // reference is not overflowing as well (e.g. virtual elements with no
      // width or height)

      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
      var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);
      popperOffsets[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset;
    }

    if (checkAltAxis) {
      var _mainSide = mainAxis === 'x' ? top : left;

      var _altSide = mainAxis === 'x' ? bottom : right;

      var _offset = popperOffsets[altAxis];

      var _min = _offset + overflow[_mainSide];

      var _max = _offset - overflow[_altSide];

      var _preventedOffset = within(_min, _offset, _max);

      popperOffsets[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }

    state.modifiersData[name] = data;
  } // eslint-disable-next-line import/no-unused-modules


  var preventOverflow$1 = {
    name: 'preventOverflow',
    enabled: true,
    phase: 'main',
    fn: preventOverflow,
    requiresIfExists: ['offset']
  };

  function arrow(_ref) {
    var _state$modifiersData$;

    var state = _ref.state,
        name = _ref.name;
    var arrowElement = state.elements.arrow;
    var popperOffsets = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? 'height' : 'width';

    if (!arrowElement || !popperOffsets) {
      return;
    }

    var paddingObject = state.modifiersData[name + "#persistent"].padding;
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === 'y' ? top : left;
    var maxProp = axis === 'y' ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
    var startDiff = popperOffsets[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
    // outside of the popper bounds

    var min = paddingObject[minProp];
    var max = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset = within(min, center, max); // Prevents breaking syntax highlighting...

    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
  }

  function effect$2(_ref2) {
    var state = _ref2.state,
        options = _ref2.options,
        name = _ref2.name;
    var _options$element = options.element,
        arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element,
        _options$padding = options.padding,
        padding = _options$padding === void 0 ? 0 : _options$padding;

    if (arrowElement == null) {
      return;
    } // CSS selector


    if (typeof arrowElement === 'string') {
      arrowElement = state.elements.popper.querySelector(arrowElement);

      if (!arrowElement) {
        return;
      }
    }

    {
      if (!isHTMLElement(arrowElement)) {
        console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
      }
    }

    if (!contains(state.elements.popper, arrowElement)) {
      {
        console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
      }

      return;
    }

    state.elements.arrow = arrowElement;
    state.modifiersData[name + "#persistent"] = {
      padding: mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements))
    };
  } // eslint-disable-next-line import/no-unused-modules


  var arrow$1 = {
    name: 'arrow',
    enabled: true,
    phase: 'main',
    fn: arrow,
    effect: effect$2,
    requires: ['popperOffsets'],
    requiresIfExists: ['preventOverflow']
  };

  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }

    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }

  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function (side) {
      return overflow[side] >= 0;
    });
  }

  function hide(_ref) {
    var state = _ref.state,
        name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: 'reference'
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets: referenceClippingOffsets,
      popperEscapeOffsets: popperEscapeOffsets,
      isReferenceHidden: isReferenceHidden,
      hasPopperEscaped: hasPopperEscaped
    };
    state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), {}, {
      'data-popper-reference-hidden': isReferenceHidden,
      'data-popper-escaped': hasPopperEscaped
    });
  } // eslint-disable-next-line import/no-unused-modules


  var hide$1 = {
    name: 'hide',
    enabled: true,
    phase: 'main',
    requiresIfExists: ['preventOverflow'],
    fn: hide
  };

  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
  var createPopper = /*#__PURE__*/popperGenerator({
    defaultModifiers: defaultModifiers
  }); // eslint-disable-next-line import/no-unused-modules

  exports.createPopper = createPopper;
  exports.defaultModifiers = defaultModifiers;
  exports.detectOverflow = detectOverflow;
  exports.popperGenerator = popperGenerator;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=popper.js.map

/*!
 * jQuery throttle / debounce - v1.1 - 3/7/2010
 * http://benalman.com/projects/jquery-throttle-debounce-plugin/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery throttle / debounce: Sometimes, less is more!
//
// *Version: 1.1, Last updated: 3/7/2010*
//
// Project Home - http://benalman.com/projects/jquery-throttle-debounce-plugin/
// GitHub       - http://github.com/cowboy/jquery-throttle-debounce/
// Source       - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.js
// (Minified)   - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.min.js (0.7kb)
//
// About: License
//
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
//
// About: Examples
//
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
//
// Throttle - http://benalman.com/code/projects/jquery-throttle-debounce/examples/throttle/
// Debounce - http://benalman.com/code/projects/jquery-throttle-debounce/examples/debounce/
//
// About: Support and Testing
//
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
//
// jQuery Versions - none, 1.3.2, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome 4-5, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-throttle-debounce/unit/
//
// About: Release History
//
// 1.1 - (3/7/2010) Fixed a bug in <jQuery.throttle> where trailing callbacks
//       executed later than they should. Reworked a fair amount of internal
//       logic as well.
// 1.0 - (3/6/2010) Initial release as a stand-alone project. Migrated over
//       from jquery-misc repo v0.4 to jquery-throttle repo v1.0, added the
//       no_trailing throttle parameter and debounce functionality.
//
// Topic: Note for non-jQuery users
//
// jQuery isn't actually required for this plugin, because nothing internal
// uses any jQuery methods or properties. jQuery is just used as a namespace
// under which these methods can exist.
//
// Since jQuery isn't actually required for this plugin, if jQuery doesn't exist
// when this plugin is loaded, the method described below will be created in
// the `Cowboy` namespace. Usage will be exactly the same, but instead of
// $.method() or jQuery.method(), you'll need to use Cowboy.method().

(function(window,undefined){
  '$:nomunge'; // Used by YUI compressor.

  // Since jQuery really isn't required for this plugin, use `jQuery` as the
  // namespace only if it already exists, otherwise use the `Cowboy` namespace,
  // creating it if necessary.
  var $ = window.jQuery || window.Cowboy || ( window.Cowboy = {} ),

    // Internal method reference.
    jq_throttle;

  // Method: jQuery.throttle
  //
  // Throttle execution of a function. Especially useful for rate limiting
  // execution of handlers on events like resize and scroll. If you want to
  // rate-limit execution of a function to a single time, see the
  // <jQuery.debounce> method.
  //
  // In this visualization, | is a throttled-function call and X is the actual
  // callback execution:
  //
  // > Throttled with `no_trailing` specified as false or unspecified:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // > X    X    X    X    X    X        X    X    X    X    X    X
  // >
  // > Throttled with `no_trailing` specified as true:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // > X    X    X    X    X             X    X    X    X    X
  //
  // Usage:
  //
  // > var throttled = jQuery.throttle( delay, [ no_trailing, ] callback );
  // >
  // > jQuery('selector').bind( 'someevent', throttled );
  // > jQuery('selector').unbind( 'someevent', throttled );
  //
  // This also works in jQuery 1.4+:
  //
  // > jQuery('selector').bind( 'someevent', jQuery.throttle( delay, [ no_trailing, ] callback ) );
  // > jQuery('selector').unbind( 'someevent', callback );
  //
  // Arguments:
  //
  //  delay - (Number) A zero-or-greater delay in milliseconds. For event
  //    callbacks, values around 100 or 250 (or even higher) are most useful.
  //  no_trailing - (Boolean) Optional, defaults to false. If no_trailing is
  //    true, callback will only execute every `delay` milliseconds while the
  //    throttled-function is being called. If no_trailing is false or
  //    unspecified, callback will be executed one final time after the last
  //    throttled-function call. (After the throttled-function has not been
  //    called for `delay` milliseconds, the internal counter is reset)
  //  callback - (Function) A function to be executed after delay milliseconds.
  //    The `this` context and all arguments are passed through, as-is, to
  //    `callback` when the throttled-function is executed.
  //
  // Returns:
  //
  //  (Function) A new, throttled, function.

  $.throttle = jq_throttle = function( delay, no_trailing, callback, debounce_mode ) {
    // After wrapper has stopped being called, this timeout ensures that
    // `callback` is executed at the proper times in `throttle` and `end`
    // debounce modes.
    var timeout_id,

      // Keep track of the last time `callback` was executed.
      last_exec = 0;

    // `no_trailing` defaults to falsy.
    if ( typeof no_trailing !== 'boolean' ) {
      debounce_mode = callback;
      callback = no_trailing;
      no_trailing = undefined;
    }

    // The `wrapper` function encapsulates all of the throttling / debouncing
    // functionality and when executed will limit the rate at which `callback`
    // is executed.
    function wrapper() {
      var that = this,
        elapsed = +new Date() - last_exec,
        args = arguments;

      // Execute `callback` and update the `last_exec` timestamp.
      function exec() {
        last_exec = +new Date();
        callback.apply( that, args );
      };

      // If `debounce_mode` is true (at_begin) this is used to clear the flag
      // to allow future `callback` executions.
      function clear() {
        timeout_id = undefined;
      };

      if ( debounce_mode && !timeout_id ) {
        // Since `wrapper` is being called for the first time and
        // `debounce_mode` is true (at_begin), execute `callback`.
        exec();
      }

      // Clear any existing timeout.
      timeout_id && clearTimeout( timeout_id );

      if ( debounce_mode === undefined && elapsed > delay ) {
        // In throttle mode, if `delay` time has been exceeded, execute
        // `callback`.
        exec();

      } else if ( no_trailing !== true ) {
        // In trailing throttle mode, since `delay` time has not been
        // exceeded, schedule `callback` to execute `delay` ms after most
        // recent execution.
        //
        // If `debounce_mode` is true (at_begin), schedule `clear` to execute
        // after `delay` ms.
        //
        // If `debounce_mode` is false (at end), schedule `callback` to
        // execute after `delay` ms.
        timeout_id = setTimeout( debounce_mode ? clear : exec, debounce_mode === undefined ? delay - elapsed : delay );
      }
    };

    // Set the guid of `wrapper` function to the same of original callback, so
    // it can be removed in jQuery 1.4+ .unbind or .die by using the original
    // callback as a reference.
    if ( $.guid ) {
      wrapper.guid = callback.guid = callback.guid || $.guid++;
    }

    // Return the wrapper function.
    return wrapper;
  };

  // Method: jQuery.debounce
  //
  // Debounce execution of a function. Debouncing, unlike throttling,
  // guarantees that a function is only executed a single time, either at the
  // very beginning of a series of calls, or at the very end. If you want to
  // simply rate-limit execution of a function, see the <jQuery.throttle>
  // method.
  //
  // In this visualization, | is a debounced-function call and X is the actual
  // callback execution:
  //
  // > Debounced with `at_begin` specified as false or unspecified:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // >                          X                                 X
  // >
  // > Debounced with `at_begin` specified as true:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // > X                                 X
  //
  // Usage:
  //
  // > var debounced = jQuery.debounce( delay, [ at_begin, ] callback );
  // >
  // > jQuery('selector').bind( 'someevent', debounced );
  // > jQuery('selector').unbind( 'someevent', debounced );
  //
  // This also works in jQuery 1.4+:
  //
  // > jQuery('selector').bind( 'someevent', jQuery.debounce( delay, [ at_begin, ] callback ) );
  // > jQuery('selector').unbind( 'someevent', callback );
  //
  // Arguments:
  //
  //  delay - (Number) A zero-or-greater delay in milliseconds. For event
  //    callbacks, values around 100 or 250 (or even higher) are most useful.
  //  at_begin - (Boolean) Optional, defaults to false. If at_begin is false or
  //    unspecified, callback will only be executed `delay` milliseconds after
  //    the last debounced-function call. If at_begin is true, callback will be
  //    executed only at the first debounced-function call. (After the
  //    throttled-function has not been called for `delay` milliseconds, the
  //    internal counter is reset)
  //  callback - (Function) A function to be executed after delay milliseconds.
  //    The `this` context and all arguments are passed through, as-is, to
  //    `callback` when the debounced-function is executed.
  //
  // Returns:
  //
  //  (Function) A new, debounced, function.

  $.debounce = function( delay, at_begin, callback ) {
    return callback === undefined
      ? jq_throttle( delay, at_begin, false )
      : jq_throttle( delay, callback, at_begin !== false );
  };

})(this);

(function($) {

	// Global `O2modules` variable should be already defined (typically: in a script
	// in the body of the HTML document.

	if ('undefined' == typeof window.O2modules) {
		window.O2modules = {};
	}

	/**
	 * Generic method to load a module and execute a callback after the module
	 * is loaded. The module is loaded only once.
	 *
	 * @param moduleName - name of the module to be loaded (key in the O2modules map)
	 * @param cbck       - callback to execute
	 */
	O2modules.load = function(moduleName, cbck) {

		var module = O2modules[moduleName];

		// `module` should be a structure containing
		// * `url`     - URL of a script to be executed to load the module
		// * `request` - jQuery Deferred (typically: script loading request) or false

		if (!module || !module.url) {
			O2util.reportError(
				'console',
				'Undefined JS module: "' + moduleName + '".',
				{
					definedModules: O2modules,
					suspendedCallback: cbck
				}
			);
			return;
		}
		if (!module.request) {
			if (window.define) {
				define._amd = define.amd;
				define.amd = false;
			}
			module.request = $.ajax({ // $.script is not cached!
				url: module.url,
				dataType: "script",
				cache: true
			});
			if (window.define) {
				module.request.done(function() {
					define.amd = define._amd;
				});
			}
		}
		module.request.done(cbck);
	};

})(jQuery);

(function($) {

	window.O2ajax = {

		blockedInstances: {},
		blockedSets: {},

  /**
	 * Provede asynchronní update stránky. Připraví data pro ajaxový request a postará se o zpracování response.
   * @param  {Object} instance Instance widgetu, která spouští asynchronní update.
   * @param  {(Object|undefined)} evt jQuery event, který vedl ke spuštění asynchronního updatu, pokud takový event existuje.
   * @param  {Object} trigger Element, který vyvolal spuštění asynchronního updatu.
   * @param  {Object} overwrite Hardcoded nastavení (options) v třídě widgetu, které přepíše uživatelské nastavení.
   * @param  {function} complete Funkce, která se zavolá po dokončení ajaxového requestu.
   * @return {undefined}
   */
		asyncUpdate: function(instance, evt, trigger, overwrite, complete) {

			if (evt) {
				evt.preventDefault();
			}

			var $trigger      = $(trigger),
			    widgetOptions = O2ajax.mergeOptions(instance, $trigger, overwrite);

			if (O2ajax.checkBlocked(instance.uuid, instance.set, widgetOptions)) {
				return;
			}

			var submit          = widgetOptions.submit || ($trigger.is('a') ? 'trigger' : 'form'), // 'form', 'self', 'trigger'
			    $elm            = instance.$elm,
			    $form           = O2ajax.findForm($trigger, $elm),
			    $ajaxOptionsSrc = (($form.length && !$trigger.is('a')) ? $form : $trigger),
			    $target         = widgetOptions.noResponse ? $() : (O2util.queryPath($elm, widgetOptions.target) || $elm),
			    $indicator      = O2util.queryPath($elm, widgetOptions.indicator) || $trigger || $target,
			    ajaxOptions     = O2ajax.deriveAjaxOptions(instance, widgetOptions, $ajaxOptionsSrc),
			    $disable        = $(),
			    isFileUpload    = instance.isFileUpload || false, // Widget zde může říct, že jde o čistý fileUpload.
			    $inputs         = null,
			    hasFiles        = false;

			// Memoizing aktuálního focused elementu
			var $focused = $(document.activeElement),
			    currentFocus = false;
			if ($focused.length === 1 && !$focused.is('body')) {
				try {
					currentFocus = {
						id: $focused.attr('id'),
						selectionStart: $focused[0].selectionStart || null,
						selectionEnd: $focused[0].selectionEnd || null
					};
				} catch(err) { // Kvůli bugu v IE11.
					currentFocus = {
						id: $focused.attr('id'),
						selectionStart: null,
						selectionEnd: null
					};
				}
			}

			if (!ajaxOptions.data) {
				$inputs  = O2ajax.collectInputs(submit, $trigger, $elm, $form, widgetOptions);
				hasFiles = widgetOptions.excludeFiles ? false : $inputs.is('input[type="file"]');
			}
			if (widgetOptions.disable) {
				$disable = O2ajax.elmToDisable($elm, widgetOptions.disable);
				$disable.prop('disable', true);
			}

			if (widgetOptions.previewTemplate && widgetOptions.previewAppendTo)
				ajaxOptions.finalPreviewTemplate = O2ajax.renderPreview($elm, $trigger, widgetOptions);

			if (hasFiles) {
				submit, $form, evt, isFileUpload, $inputs
				var formData = O2ajax.collectDataWithFiles(submit, $form, evt, isFileUpload, $inputs);
				ajaxOptions.data = formData.data;

				if (isFileUpload && formData.hasFiles) { // Zda po aplikaci filtrů zůstaly nějaké soubory.
					O2ajax.blockedInstances[instance.uuid] = O2ajax.execXhr($target, $indicator, $disable, currentFocus, ajaxOptions, widgetOptions, complete);
				} else if (isFileUpload && !formData.hasFiles) { // Pokud jde o fileUpload, ale nezůstaly žádné soubory.
					O2ajax.uncheckBlocked(ajaxOptions.sourceUuid, ajaxOptions.sourceSet, widgetOptions);
				} else { // Pokud nejde o fileUpload, provedeme XHR vždy.
					O2ajax.blockedInstances[instance.uuid] = O2ajax.execXhr($target, $indicator, $disable, currentFocus, ajaxOptions, widgetOptions, complete);
				}
			} else { // Pokud sada k odeslání ajaxem nemá žádné soubory.
				if (!ajaxOptions.data) {
					var data = (submit == 'form' ? O2util.collectData($form, evt) : $inputs.serialize());
					ajaxOptions.data = data;
				}
				O2ajax.blockedInstances[instance.uuid] = O2ajax.execAjax($target, $indicator, $disable, currentFocus, ajaxOptions, widgetOptions, complete);
			}
		},

  /**
   * Na základě připravených dat odesílá jQuery ajaxový request a postará se o zpracování response.
   * @param  {Object} $target JQuery object obsahující elementy, do kterých bude umístěno HTML z response.
   * @param  {Object} $indicator JQuery object obsahující elementy, na kterých se zobrazí loading indicator.
   * @param  {Object} $disable JQuery object obsahující elementy, které budou během requestu disablované.
   * @param  {(Object|false)} currentFocus Objekt obsahující informace o stavu focusu před zahájením asynchrnního updatu. False, pokud žádný element vybraný nebyl.
   * @param  {Object} ajaxOptions Objekt s nastavením pro jQuery.ajax().
   * @param  {Object} widgetOptions Nastavení instance widgetu, jenž vyvolal asynchronní update.
   * @param  {function} complete Callback funkce, která se spustí po dokončení ajaxu.
   * @return {Object} Objekt jqXHR z jQuery obsahující ajaxový request.
   */
		execAjax: function($target, $indicator, $disable, currentFocus, ajaxOptions, widgetOptions, complete) {

			if (typeof complete != 'function')
				complete = function(hasError) {}; // callback po provedení ajaxu, hasError je true, pokud ajax selhal

			var opts = {};

			opts = $.extend(opts, ajaxOptions, {
				success: function(data) {
					O2ajax.handleSuccess(data, $target, $indicator, $disable, currentFocus, opts, widgetOptions);
					complete(false);
				},
				error: function(jqXHR) {
					O2ajax.handleError($indicator, $disable, currentFocus, opts, widgetOptions, jqXHR);
					complete(true);
				}
			});

			opts.loadingClass = widgetOptions.indicatorClass || 'o2-loader--overlay';
			opts.errorClass   = widgetOptions.errorClass || 'o2-loader--overlay-error';
			$disable.prop('disabled', true);

			$indicator.removeClass(opts.errorClass).addClass(opts.loadingClass);
			return $.ajax(opts);
		},

  /**
   * Na základě připravených dat odesílá xhr ajaxový request a postará se o zpracování response. Používá se při odesílání souborů.
   * @param  {Object} $target JQuery object obsahující elementy, do kterých bude umístěno HTML z response.
   * @param  {Object} $indicator JQuery object obsahující elementy, na kterých se zobrazí loading indicator.
   * @param  {Object} $disable JQuery object obsahující elementy, které budou během requestu disablované.
   * @param  {(Object|false)} currentFocus Objekt obsahující informace o stavu focusu před zahájením asynchrnního updatu. False, pokud žádný element vybraný nebyl.
   * @param  {Object} ajaxOptions Objekt s nastavením pro jQuery.ajax().
   * @param  {Object} widgetOptions Nastavení instance widgetu, jenž vyvolal asynchronní update.
   * @param  {function} complete Callback funkce, která se spustí po dokončení ajaxu.
   * @return {Object} Xhr object obsahující ajaxový request.
   */
		execXhr: function($target, $indicator, $disable, currentFocus, ajaxOptions, widgetOptions, complete) {

			if (typeof complete != 'function')
				complete = function(hasError) {}; // callback po provedení ajaxu, hasError je true, pokud ajax selhal

			var opts = $.extend({}, ajaxOptions);

			opts.loadingClass = widgetOptions.indicatorClass || 'o2-loader--overlay';
			opts.errorClass = widgetOptions.errorClass || (opts.loadingClass + '-error');
			$disable.prop('disabled', true);

			$indicator.removeClass(opts.errorClass).addClass(opts.loadingClass);

			var xhr = $.ajaxSettings.xhr();
			xhr.open((opts.method).toUpperCase(), opts.url);
			xhr.onreadystatechange = function () {
				if (xhr.readyState == XMLHttpRequest.DONE) {
					if (xhr.status == 200) {
						O2ajax.handleSuccess(xhr.responseText, $target, $indicator, $disable, currentFocus, opts, widgetOptions);
						complete(false);
					} else {
						O2ajax.handleError($indicator, $disable, currentFocus, opts, widgetOptions, xhr);
						complete(true);
					}
				}
			};
			xhr.send(opts.data);
			return xhr;
		},

  /**
   * Zpracuje úspěšnou ajaxovou response. Provede akce na základě nastavení volajícího widgetu a instrukcí v samotné response.
   * @param  {string} data Přijatý HTML kód z ajaxové response.
   * @param  {Object} $target JQuery object obsahující elementy, do kterých bude umístěno HTML z response.
   * @param  {Object} $indicator JQuery object obsahující elementy, na kterých se zobrazí loading indicator.
   * @param  {Object} $disable JQuery object obsahující elementy, které budou během requestu disablované.
   * @param  {(Object|false)} currentFocus Objekt obsahující informace o stavu focusu před zahájením asynchrnního updatu. False, pokud žádný element vybraný nebyl.
   * @param  {Object} ajaxOptions Objekt s nastavením pro jQuery.ajax().
   * @param  {Object} widgetOptions Nastavení instance widgetu, jenž vyvolal asynchronní update.
   * @return {undefined}
   */
		handleSuccess: function(data, $target, $indicator, $disable, currentFocus, ajaxOptions, widgetOptions) {
			if (ajaxOptions.finalPreviewTemplate)
				ajaxOptions.finalPreviewTemplate.remove();

			if (widgetOptions.noResponse) {
				$indicator.removeClass(ajaxOptions.loadingClass).removeClass(ajaxOptions.errorClass);
				$disable.prop('disabled', false);
				O2ajax.uncheckBlocked(ajaxOptions.sourceUuid, ajaxOptions.sourceSet, widgetOptions);
			} else {
				var $fragment = O2ajax.prepareFragment(data),
					execData = O2ajax.extractExecFragments($fragment);
				$fragment = O2ajax.preprocessResponse(execData.$fragment, widgetOptions);
				var $newContent = O2ajax.useResponseMain($fragment, $target, widgetOptions);
				O2ajax.postprocessResponse($newContent);
				$indicator.removeClass(ajaxOptions.loadingClass).removeClass(ajaxOptions.errorClass);
				$disable.prop('disabled', false);
				O2ajax.uncheckBlocked(ajaxOptions.sourceUuid, ajaxOptions.sourceSet, widgetOptions);
				if (currentFocus)
					O2ajax.renewFocus(currentFocus);

				O2ajax.executeWidgets(execData.$exec);
			}

			if (widgetOptions.scrollToTarget && !O2util.scrolledToElement($target, -100))
				O2util.scrollTo($target, 250, -100);
		},

		/**
   * Zpracuje neúspěšnou ajaxovou response. Zobrazí chybové hlášení.
   * @param  {Object} $indicator JQuery object obsahující elementy, na kterých se zobrazí loading indicator.
   * @param  {Object} $disable JQuery object obsahující elementy, které budou během requestu disablované.
   * @param  {(Object|false)} currentFocus Objekt obsahující informace o stavu focusu před zahájením asynchrnního updatu. False, pokud žádný element vybraný nebyl.
   * @param  {Object} ajaxOptions Objekt s nastavením pro jQuery.ajax().
   * @param  {Object} widgetOptions Nastavení instance widgetu, jenž vyvolal asynchronní update.
	 * @param  {Object} JQuery jqXHR object pokud bylo voláno přes execAjax, případně vanilla xhr object, pokud bylo voláno přes execXhr.
   * @return {undefined}
   */
		handleError: function($indicator, $disable, currentFocus, ajaxOptions, widgetOptions, xhr) {
			if (ajaxOptions.finalPreviewTemplate)
				ajaxOptions.finalPreviewTemplate.remove();

			if (xhr.statusText === 'abort') // Zrušené requsty nijak nelogujeme.
				return;


			if (xhr.statusText === 'error' && xhr.readyState === 0) { // Pravděpodobně není připojení k netu.
				O2util.reportError(
					'user',
					"Nepodařilo se odeslat požadavek. Jste připojeni k internetu?",
					ajaxOptions
				);
			} else if (xhr.status == 409) {
				if (O2config.getInformationMessagesURL) {
					window.O2widget.classes.sysmsg.kahl(O2config.getInformationMessagesURL, {
						msgid: "ID0256",
						timestamp: Date.now(),
						sourceid: "Theme - o2ajax.js:handleError:409",
						exceptParams: ""
					});
				} else
					O2util.reportError(
						'user',
						"V aplikaci došlo k chybě. Vyzkoušejte zopakovat akci později.",
						ajaxOptions
					);
			} else {
				if (O2config.getInformationMessagesURL) {
					window.O2widget.classes.sysmsg.kahl(O2config.getInformationMessagesURL, {
						msgid: "ID0942",
						timestamp: Date.now(),
						sourceid: "Theme - o2ajax.js:handleError:2",
						exceptParams: ""
					});
				} else
					O2util.reportError(
						'user',
						"V aplikaci došlo k chybě. Vyzkoušejte zopakovat akci později.",
						ajaxOptions
					);
			}

			$indicator.removeClass(ajaxOptions.loadingClass).addClass(ajaxOptions.errorClass);
			$disable.prop('disabled', false);
			O2ajax.uncheckBlocked(ajaxOptions.sourceUuid, ajaxOptions.sourceSet, widgetOptions);
			if (currentFocus)
				O2ajax.renewFocus(currentFocus);
		},

		/**
		 * Z ajaxové response extrahuje "exec" fragmenty, tedy ty části, které mají následně spouštět další widgety na stránce.
		 * @param  {Object} $fragment JQuery object obsahující připravenou HTML response z ajaxového requestu.
		 * @return {{$fragment: Object, $exec: Object}} Vlastnost $fragment obsahuje jQuery object zbylého HTML po extrakci exec fragmentů. Vlatnost $exec obsahuje jQuery object se samotnými exec fragmenty.
		 *
		 */
		extractExecFragments: function($fragment) {
			var execClass = '.js-ajax-exec';
			var $exec = $fragment.find(execClass);

			$fragment.remove(execClass);
			return {
				$fragment: $fragment,
				$exec: $exec
			};
		},

		/**
		 * Z ajaxové response extrahuje "aux" fragmenty, tedy ty části, které mají kromě HTML kódu i instrukce, jak s daným fragmentem dále pracovat.
		 * @param  {Object} $fragment JQuery object obsahující připravenou HTML response z ajaxového requestu (bez "exec" fragmentů).
		 * @param  {Object} widgetOptions Nastavení instance widgetu, jenž vyvolal asynchronní update.
		 * @return {Object} JQuery object obsahující HTML response bez "aux" fragmentů.
		 */
		extractAuxFragments: function($fragment, widgetOptions) {
			var aux = '.js-ajax-aux',
				$auxLs = $fragment.find(aux);

			if (widgetOptions.instance)
				$elm = widgetOptions.instance.$elm;
			else
				$elm = undefined;

			$auxLs.each(function() {
				var $aux               = $(this),
				    target             = $aux.data('ajax-target')       || widgetOptions.auxTarget,
				    $target            = O2util.queryPath($elm, target),
				    replace            = $aux.data('ajax-replace')      || widgetOptions.auxReplace,
				    visibility         = $aux.data('ajax-visibility')   || widgetOptions.auxVisibility,
				    remove             = $aux.data('ajax-remove')       || widgetOptions.auxRemove,
				    keep               = $aux.data('ajax-keep')         || widgetOptions.auxKeep,
				    append             = $aux.data('ajax-append')       || widgetOptions.auxAppend,
				    trimWrapper        = $aux.data('ajax-trim-wrapper') || widgetOptions.auxTrimWrapper;

				// Auxiliary fragment without a matching target element is
				// simply removed from the response. So is the element that
				// is not used to replace the content (with a `keep` option).

				if (!$target.length || keep || remove) {
					$aux.remove();
				}

				if (remove) {
					$target.trigger('contentgone.o2util');
					$target.remove();
					return;
				}

				if (!$target.length) {
					return;
				}

				// Otherwise progress just like with an ordinary response.

				if (!keep) {
					var $wrappedAux = O2ajax.prepareFragment($aux);
					var $newContent = O2ajax.useResponse($wrappedAux, $target, { replace: replace, append: append, trimWrapper: trimWrapper });
					O2ajax.postprocessResponse($newContent);
				}
				switch (visibility) {
					case 'show': case 'shown': case 'visible':
						$target.show().trigger('shown.o2util');
						break;
					case 'hide': case 'hidden': case 'invisible':
						$target.hide().trigger('hidden.o2util');
						break;
				}
			});

			return $fragment.remove(aux);
		},

		/**
		 * Provede instrukce přítomné v ajaxové response (volitelné), extrahuje "aux" fragmenty (volitelné) a připraví zbylou část response k dalšímu zpracování.
		 * @param  {Object} $fragment JQuery object obsahující připravenou HTML response z ajaxového requestu (bez "exec" fragmentů).
		 * @param  {Object} widgetOptions Nastavení instance widgetu, jenž vyvolal asynchronní update.
		 * @return {Object} JQuery object s HTML kódem připraveným k vložení do DOMu aktuální stránky.
		 */
		preprocessResponse: function($fragment, widgetOptions) {
			// Various special instructions (redirect, notification) are executed
			// before the fragment is reduced.

			$fragment = O2ajax.executeModalClose($fragment);
			O2ajax.executeRedir($fragment, widgetOptions);
			$fragment = O2ajax.executeModalOpen($fragment);
			$fragment = O2ajax.extractAuxFragments($fragment, widgetOptions);

			// The fragment can be reduced to a range specified by a selector.

			if (widgetOptions.partial) {
				$fragment = $fragment.find(widgetOptions.partial);
				$fragment = O2ajax.prepareFragment($fragment);
			}

			return $fragment;
		},

		/**
		 * V těch částech stránky, kde došlo ke změně či nahrazení DOMu, spustí eventy pro reinicializaci widgetů.
		 * @param  {Object} $fragment JQuery object obsahující HTML očištěné o všechny další fragmenty.
		 * @return {undefined}
		 */
		postprocessResponse: function($fragment) {

			// By now, triggering the `contentready` event is sufficient to initialize
			// all widgets that may be found within the new content.

			$fragment.trigger('contentready.o2util');
			$fragment.trigger('modified.o2util');
		},

		/**
		 * Spustí vybrané akce na dalších widgetech. Instrukce jsou přebrány z "exec" fragmentů v ajaxové response.
		 * @param  {Object} $exec JQuery object s "exec" fragmenty.
		 * @return {undefined}
		 */
		executeWidgets: function($exec) {
			$exec.each(function(){
				var $elm = $(this);
				var options = {
					target: ($elm.data('ajax-exec-target') || false),
					widget: ($elm.data('ajax-exec-widget') || false)
				};
				var $target = options.target ? O2util.queryPath($(document), options.target) : $();

				if (O2widget.classes[options.widget]) {
					var instance = O2widget.classes[options.widget].getInstance($target);

					if (instance) {
						switch(options.widget) {
							case 'update':
								instance.handleUpdate(false, $target, false);
								break;
							case 'ask':
								instance.handleSubmit(false, $target);
								break;
							case 'notify':
								instance.handleSubmit(false);
								break;
							default:
								console.error('js-' + options.widget + ' chain not supported.');
						}
					}
				}
			});
		},

		/**
		 * Ověří aktuální stav probíhajících ajaxových requestů na základě nastavení instance widgetu.
		 * @param  {string} uuid Unikátní identifikátor instance widgetu.
		 * @param  {string} set Název sady, do které instance widgetu spadá.
		 * @param  {Object} widgetOptions Nastavení instance widgetu, jenž vyvolal asynchronní update.
		 * @return {boolean} True, pokud je ajax pro daný request zablokovaný. False, pokud zablokovaný není.
		 */
		checkBlocked: function(uuid, set, widgetOptions) {
			if (!widgetOptions) {
				return false;
			}
			if (widgetOptions.blockAjaxInSet) {
				if (O2ajax.blockedSets[set]) {
					return true;
				} else {
					O2ajax.blockedSets[set] = true;
					return false;
				}
			} else if (widgetOptions.allowOverwriteAjax) {
				if (O2ajax.blockedInstances[uuid]) {
					O2ajax.blockedInstances[uuid].abort();
					O2ajax.blockedInstances[uuid] = false;
				}
				return false;
			} else if (widgetOptions.allowMultipleAjax) {
				return false;
			} else {
				if (O2ajax.blockedInstances[uuid]) {
					return true;
				} else {
					O2ajax.blockedInstances[uuid] = true;
					return false;
				}
			}
		},

		/**
		 * Uvolní aktuální stav probíhajících ajaxových requestů pro budoucí requesty.
		 * @param  {string} uuid Unikátní identifikátor instance widgetu.
		 * @param  {string} set Název sady, do které instance widgetu spadá.
		 * @param  {Object} widgetOptions Nastavení instance widgetu, jenž vyvolal asynchronní update.
		 * @return {undefined}
	   */
		uncheckBlocked: function(uuid, set, widgetOptions) {
			if (!widgetOptions) {
				return;
			}
			if (widgetOptions.blockAjaxInSet) {
				O2ajax.blockedSets[set] = false;
			} else if (widgetOptions.allowOverwriteAjax) {
				O2ajax.blockedInstances[uuid] = false;
			} else if (!widgetOptions.allowMultipleAjax) {
				O2ajax.blockedInstances[uuid] = false;
			}
		},

		/**
		 * Připraví výsledné nastavení asynchronního updatu. Sloučí nastavení instance widgetu, nastavení trigger elementu (volitelné) a hardcoded nastavení v třídě widgetu (volitelné).
		 * @param  {Object} instance Instance widgetu, která spouští asynchronní update.
		 * @param  {type} $trigger JQuery object obsahující element, který vyvolal spuštění asynchronního updatu.
		 * @param  {Object} overwrite Hardcoded nastavení (options) v třídě widgetu, které přepíše uživatelské nastavení.
		 * @return {Object} Sloučená nastavení asynchronního updatu.
		 */
		mergeOptions: function(instance, $trigger, overwrite) {

			var options = $.extend({}, instance.options),
				triggerOptions = {};
			if (typeof overwrite == 'undefined')
				overwrite = {};

			O2util.extendFromData(triggerOptions, $trigger.data(), instance.widgetName);

			var profile = triggerOptions.profile;
			if (profile && instance.profileOptions) {
				var profileOptions = instance.profileOptions[profile];
				if (profileOptions) {
					$.extend(options, profileOptions);
				}
			}

			$.extend(options, triggerOptions, overwrite);

			return options;
		},

		/**
		 * Nalezne nejbližší nadřazený <form> element. Pokud je element $trigger typu <form>, vrátí $trigger. To samé následně platí pro element $elm.
		 * @param  {Object} $trigger JQuery object obsahující element, který vyvolal spuštění asynchronního updatu.
		 * @param  {Object} $elm JQuery object obsahující root element instance widgetu.
		 * @return {Object} JQuery object obsahující <form> element, případně prázdný jQuery object, pokud form nebyl nalezen.
		 */
		findForm: function($trigger, $elm) {
			if ($trigger.is('form')) {
				return $trigger;
			} else if ($elm.is('form')) {
				return $elm;
			} else {
				return $trigger.closest('form');
			}
		},

		/**
		 * Obnoví focus na formulářovém prvku, který měl focus před zahájením asynchronního updatu a zároveň měl přiřazený atribut "id".
		 * @param  {{id: string, selectionStart: number, selectionEnd: number}} currentFocus Objekt obsahující informace o stavu focusu před zahájením asynchrnního updatu.
		 * @return {undefined}
		 */
		renewFocus: function(currentFocus) {
			var $elmToFocus = $(document).find('#' + currentFocus.id);
			if ($elmToFocus.length) {
				var $scrollParent  = $elmToFocus.scrollParent(),
				    scrollPosition = { top: $scrollParent.scrollTop(), left: $scrollParent.scrollLeft() },
				    elmToFocus     = $elmToFocus.get(0);

				if (elmToFocus.focus) {
					elmToFocus.focus();
					if (typeof elmToFocus.selectionStart === 'number' && typeof elmToFocus.selectionEnd === 'number') { // Některé inputy nepodporují selection.
						elmToFocus.selectionStart = currentFocus.selectionStart;
						elmToFocus.selectionEnd = currentFocus.selectionEnd;
					}
				}

				// Focus přescrolluje okno, takže nascrollujeme zase zpět
				$scrollParent.scrollLeft(scrollPosition.left);
				$scrollParent.scrollTop(scrollPosition.top);
			}
		},

		/**
		 * Připraví objekt obsahující základní nastavení ajaxového requestu.
		 * @param  {Object} instance Instance widgetu, která spouští asynchronní update.
		 * @param  {Object} widgetOptions Nastavení instance widgetu, jenž vyvolal asynchronní update.
		 * @param  {Object} $ajaxOptionsSrc JQuery object s elementem, který slouží jako zdroj dat pro základní nastavení ajaxového requestu.
		 * @return {{method: string, url:string, sourceUuid: string, sourceSe: string}} Objekt obsahující základní nastavení ajaxového requestu.
		 */
		deriveAjaxOptions: function(instance, widgetOptions, $ajaxOptionsSrc) {
			var ajaxOptions = {
				method:     widgetOptions.method || O2util.deriveMethod($ajaxOptionsSrc),
				url:        widgetOptions.url    || O2util.deriveUrl($ajaxOptionsSrc),
				sourceUuid: instance.uuid,
				sourceSet:  instance.set
			};

			if (widgetOptions.data) // pokud jsou data již zadaná z venčí
				ajaxOptions.data = data;

			return ajaxOptions;
		},

		/**
		 * Vybere elementy určené k disablování během probíhajícího asynchronního updatu.
		 * @param  {Object} $elm JQuery object obsahující root element instance widgetu.
		 * @param  {string} toDisable QueryPath selektor elementů k disablování.
		 * @return {Object} JQuery object s elementy určenými k disablování.
		 */
		elmToDisable: function($elm, toDisable) {
			var $toDisable = O2util.queryPath($elm, toDisable);
			return $toDisable ? $toDisable.filter(':enabled') : $();
		},

		/**
		 * Do DOM vygeneruje dočasnou šablonu, která se bude zobrazovat během probíhajícího asynchronního updatu.
		 * @param  {Object} $elm JQuery object obsahující root element instance widgetu.
		 * @param  {Object} $trigger JQuery object obsahující element, který vyvolal spuštění asynchronního updatu.
		 * @param  {Object} widgetOptions Nastavení instance widgetu, jenž vyvolal asynchronní update.
		 * @return {Object} JQuery object s výslednou šablonou přidanou v DOM.
		 */
		renderPreview: function($elm, $trigger, widgetOptions) {

			var previewTemplate = widgetOptions.previewTemplate,
			    previewAppendTo = widgetOptions.previewAppendTo,
			    previewConstant = widgetOptions.previewConstant,
			    $finalTemplate   = $();

			var $tgt = O2util.queryPath($elm, previewAppendTo);

			if (previewConstant) {
				previewTemplate = previewTemplate.replace('{constant}', previewConstant);
			}

			// Renderuje preview pro každý soubor zvlášť.
			if ($trigger.is('input[type="file"]')) {
				for (var fs = $trigger[0].files, i = 0, f; f = fs[i++]; ) {
					var maxFileSize = parseInt($trigger.data('maxfilesize')) || Infinity;
					if ((maxFileSize * 1000 * 1000) > f.size)
						var currentTemplate = $(previewTemplate.replace('{value}', f.name));
						$tgt.append(currentTemplate);
						$finalTemplate = $finalTemplate.add(currentTemplate);
				}
			} else {
				$finalTemplate = $(previewTemplate.replace('{value}', $trigger.val()));
				$tgt.append($finalTemplate);
			}

			return $finalTemplate;
		},

		/**
		 * Sesbírá všechny formulářové prvky (inputy, selecty, atd.) na základě parametru "submit".
		 * @param  {string} submit Určuje, které formulářové prvky mají být součástí ajaxového requestu. Může být "trigger", pokud se má odeslat pouze hodnota prvku, který synchronní update vyvolal, "self", pokud se mají odeslat všechny prvky uvnitř root elementu instance widgetu, "form", pokud se mají odeslat vechny prvky uvnitř nejbližšího nadřazeného fomuláře, nebo může být queryPath selektor, pokud se mají odeslat konkrétní prkvy.
		 * @param  {Object} $trigger JQuery object obsahující element, který vyvolal spuštění asynchronního updatu.
		 * @param  {Object} $elm JQuery object obsahující root element instance widgetu.
		 * @param  {Object} $form JQuery object obsahující element <form>, případně prázdný JQuery object, pokud <form> není k dispozici.
		 * @param  {Object} widgetOptions Nastavení instance widgetu, jenž vyvolal asynchronní update.
		 * @return {Object} JQuery object s formulářovými prvky.
		 */
		collectInputs: function(submit, $trigger, $elm, $form, widgetOptions) {
			var s = 'input, textarea, select', $controls;
			switch (submit) {
			case 'trigger':
				$controls = $trigger.filter(s).add($trigger.find(s));
				break;
			case 'self':
				$controls = $elm.filter(s).add($elm.find(s));
				break;
			case 'form':
				$controls = $form.find(s);
				break;
			default:
				$controls = O2util.queryPath($elm, submit);
				break;
			}

			if (widgetOptions.excludeFiles)
				$controls = $controls.not('input[type="file"]');

			$controls = $controls.not('input:checkbox:not(:checked), input:radio:not(:checked)');

			return $controls;
		},

		/**
		 * U formulářů, kde je součástí i file upload, sesbírá data ze všech formulářových prvků. Pokud tyto prvky nejsou součástí <form>, vytvoří FormData object. Ověří, zda velikost souborů nepřesahuje maximální hranici (volitelné).
		 * @param  {string} submit Určuje, které formulářové prvky mají být součástí ajaxového requestu.
		 * @param  {Object} $form JQuery object obsahující element <form>, případně prázdný JQuery object, pokud <form> není k dispozici.
		 * @param  {(Object|undefined)} evt jQuery event, který vedl ke spuštění asynchronního updatu, pokud takový event existuje.
		 * @param  {boolean} isFileUpload Pokud je true, vždy se použije FormData object a vždy se bude ověřovat velikost souborů.
		 * @param  {Object} $inputs JQuery object obsahující všechny formulářové prvky k odeslání.
		 * @return {{hasFiles: boolean, data: Object}} Parametr hasFiles je true, pokud data k odeslání obsahují soubory, parametr data obsahuje samotná data.
		 */
		collectDataWithFiles: function(submit, $form, evt, isFileUpload, $inputs) {

			var data,
			    hasFiles = false;

			if (!isFileUpload && submit == 'form' && $form.length) {
				data = new FormData($form[0]);
			} else {
				data = new FormData();
				$inputs.each(function() {
					var $i = $(this);
					if ($i.is('input[type="file"]')) {
						var files = this.files;
						for (var i = 0, l = files.length; i < l; i++) {
							var maxFileSize = parseInt($i.data('maxfilesize')) || Infinity;
							if ((maxFileSize * 1000 * 1000) > files[i].size) {
								data.append($i.attr('name'), files[i]);
								hasFiles = true;
							}
							else {
								if (O2config.getInformationMessagesURL) {
									window.O2widget.classes.sysmsg.kahl(O2config.getInformationMessagesURL, {
										msgid: "ID0255",
										timestamp: Date.now(),
										sourceid: "Theme - o2ajax.js",
										exceptParams: ""
									});
									window.O2widget.classes.sysmsg.showMessage([
										{
											"text": "Maximální velikost je " + maxFileSize + " MB.",
											"textInternal": "",
											"severity": "warning",
											"isInternal": false,
											"closeBtn": true,
											"autoClose": 15000
										}
									]);
								} else
									window.O2widget.classes.sysmsg.showMessage([
										{
											"text": "Soubor " + files[i].name + " je příliš velký. Maximum je " + maxFileSize + " MB.",
											"textInternal": "",
											"severity": "danger",
											"isInternal": false,
											"closeBtn": true,
											"autoClose": 30000,
											"messageId": "dsFilesize"
										}
									]);
							}
						}
					} else {
						data.append($i.attr('name'), $i.val());
					}
				});
			}

			var submit = O2util.getActiveSubmit(evt);
			if (submit && submit.name && submit.value) {
				data.append(submit.name, submit.value);
			}

			return {
				hasFiles: hasFiles,
				data: data
			};
		},

		/**
		 * Připraví HTML kód z ajaxové response pro budoucí parsování.
		 * @param  {(Object|string)} fragment {description}
		 * @return {Object} JQuery object, který má vždy jeden element <div>, jehož obsahem je samotný HTML fragmet.
		 */
		prepareFragment: function(fragment) {
			var $fragment = $('<div></div>');
			if (fragment instanceof jQuery && fragment.length >= 1) {
				$fragment.append(fragment);
			} else if (typeof fragment == 'string') {
				$fragment.html($.trim(fragment));
			}

			return $fragment;
		},

		/**
		 * Zpracuje část HTML response. Nahradí příslušná místa v DOMu novým HTML.
		 * @param  {Object} $fragment JQuery object obsahující HTML očištěné o všechny další fragmenty.
		 * @param  {Object} $target JQuery object obsahující elementy, do kterých bude umístěno HTML z response.
		 * @param  {Object} widgetOptions Nastavení instance widgetu, jenž vyvolal asynchronní update.
		 * @return {Object} JQuery object obsahující ty části DOM, ve kterých došlo k úpravě struktury, nebo byly nově přidány.
		 */
		useResponse: function($fragment, $target, widgetOptions) {
			if (widgetOptions.hideOnInsert) {
				$fragment
					.find(widgetOptions.hideOnInsert)
					.hide();
			}

			var $toAdd = $fragment.contents();
			if (widgetOptions.trimWrapper)
				$toAdd = $toAdd.contents();

			var $newContent = $toAdd;

			if (widgetOptions.replace) {
				$target.trigger('contentgone.o2util');
				if ($target.length > 1) {
					$target.eq(0).replaceWith($toAdd);
					$target.slice(1).each(function() {
						var $f = $toAdd.clone();
						$(this).replaceWith($f);
						$newContent = $newContent.add($f);
					});
				} else {
					$target.replaceWith($toAdd);
				}
			} else {
				if (!widgetOptions.append) {
					$target.children().trigger('contentgone.o2util');
					$target.empty();
				}
				if ($target.length > 1) {
					$target.eq(0).append($toAdd);
					$target.slice(1).each(function() {
						var $f = $toAdd.clone();
						$(this).append($f);
						$newContent = $newContent.add($f);
					});
				} else {
					$target.append($toAdd);
				}
			}

			return $newContent;
		},

		/**
		 * Zpracuje hlavní část HTML response. Nahradí příslušná místa v DOMu novým HTML.
		 * @param  {Object} $fragment JQuery object obsahující HTML očištěné o všechny další fragmenty.
		 * @param  {Object} $target JQuery object obsahující elementy, do kterých bude umístěno HTML z response.
		 * @param  {Object} widgetOptions Nastavení instance widgetu, jenž vyvolal asynchronní update.
		 * @return {Object} JQuery object obsahující ty části DOM, ve kterých došlo k úpravě struktury, nebo byly nově přidány.
		 */
		useResponseMain: function($fragment, $target, widgetOptions) {
			var $newContent;

			if (widgetOptions.replacements) {
				var replIds = widgetOptions.replacements.split(/\s*\|\s*/),
					replOptions = $.extend({}, widgetOptions, { replace: true }),
					$newContent = $();
				for (var i = 0, currentRepl; currentRepl = replIds[i++]; ) {
					var $currentRepl = $(currentRepl);
					if ($currentRepl.length == 1) {
						var $f = $fragment.find(currentRepl);
						$f = O2ajax.prepareFragment($f);
						$f = O2ajax.useResponse($f, $currentRepl, replOptions);
						$newContent = $newContent.add($f);
					}
				}
			} else {
				$newContent = O2ajax.useResponse($fragment, $target, widgetOptions);
			}

			return $newContent;
		},

		/**
		 * Pokud je v HTML ajaxové response přítomný fragment k přesměrování, postará se o přesměrování stránky v prohlížeči.
		 * @param  {Object} $fragment JQuery object obsahující HTML očištěné o "exec" fragmenty.
		 * @return {boolean} True, pokud dochází k přesměrování, false, pokud nikoliv.
		 */
		executeRedir: function($fragment) {
			var redir  = '.js-ajax-redir',
			    $redir = $fragment.find(redir);

			if ($redir.length) {
				var url = $redir.data('ajax-redir') || $redir.attr('href');

				if (url) {
					location.href = url;
					return true;
				}
			}
			return false;
		},

		/**
		 * Pokud je v HTML ajaxové response přítomný fragment k zavření modálu, zavře modál a odstraní fragment z HTML.
		 * @param  {Object} $fragment JQuery object obsahující HTML očištěné o "exec" fragmenty.
		 * @return {Object} JQuery object obsahující HTML response bez fragmentu k zavření modálu.
		 */
		executeModalClose: function($fragment) {
			var modalClose = '.js-ajax-close-modal',
				$modalClose = $fragment.find(modalClose);

			if ($modalClose.length) {
				$.magnificPopup.close();
				return $fragment.remove(modalClose);
			} else
				return $fragment;
		},

		executeModalOpen: function($fragment) {
			var modalAux = '.js-ajax-open-modal',
				$modalAux = $fragment.find(modalAux);

			if ($modalAux.length === 1) {
				//$modalAux.hide();
				var $wrappedAux = O2ajax.prepareFragment($modalAux);

				var $newContent = O2ajax.useResponse($wrappedAux, $("body"), { replace: false, append: true, trimWrapper: false });
				O2ajax.postprocessResponse($newContent);

				// Obsah modálu je připravený v body, takže ho můžeme otevřít.
				var modalFragment = {
					$container: $newContent,
					$content: $newContent
				};

				$newContent.data("modalFragmentState", modalFragment);

				var modalInstance = O2widget.assignInstance("modal", $newContent);


				return $fragment.remove(modalAux);
			} else if ($modalAux.length > 1) // Je-li více modálů, prostě je všechny ignorujeme.
				return $fragment.remove(modalAux);
			else
				return $fragment;
		}
	};

})(jQuery);
(function($) {

	var $w = $(window);

	window.O2util = {

		scrollbarNeeded: function(windowHeight) {

			return (document.body.scrollHeight > windowHeight);
		},

		scrollbarWidth: function() {

			if (this._scrollbarWidth === undefined) {

				var dummy = document.createElement('div');

				dummy.style.cssText = 'width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;';
				document.body.appendChild(dummy);

				this._scrollbarWidth = dummy.offsetWidth - dummy.clientWidth;

				document.body.removeChild(dummy);
			}

			return this._scrollbarWidth;
		},

		disableScroll: function() {

			var sty = { overflow: 'hidden' },
				wh = $w.height();

			if (this.scrollbarNeeded(wh)){
				var sw = this.scrollbarWidth();
				if (sw) {
					sty.marginRight = sw;
				}
			}

			$('html').css(sty);
		},

		enableScroll: function() {

			var sty = { overflow: '' },
				wh = $w.height();

			if (this.scrollbarNeeded(wh)){
				sty.marginRight = '';
			}

			$('html').css(sty);
		},

		/**
		 * Extended selector evaluation - enables XPath like axis prefix.
		 *
		 * @param $base context element to be used when the axis is present
		 * @param path  jQuery selector, possibly starting with an axis prefix
		 *              Prefix is separated by '::' (double colon).
		 * @returns     jQuery selection or false (path is not a selector or axis
		 *              name is not recognized)
		 */

		queryPathSingle: function ($base, path) {

			var i,
				axis,
				selector,
				$r;

			if (!path) {
				return false;
			}

			i = path.indexOf('::');

			if (i < 0) {
				try {
					$r = $(path);
				} catch(error) {
					return false;
				}
				return $r;
			}

			axis = path.substring(0, i);
			selector = path.substring(i + 2);

			switch (axis) {
			case 'empty':
				return $();

			case 'self':
				return $base.is(selector) ? $base : $();

			case 'form':
				// 'form::' is an axis prefix - it has to be chained with another axis name
				return this.queryPathSingle($($base[0].form || $base.closest('form')), selector);

			case 'closest':
			case 'prev':
			case 'next':
				return $base[axis](selector); // axis name is a jQuery method name

			case 'closest-next':
				var $selection = $base,
					$candidate;
				do {
					$candidate =
						$selection.filter(selector)
							.add($selection.nextAll(selector))
							.add($selection.nextAll().find(selector));
				} while (
					!$candidate.length &&
					($selection = $selection.parent()).length
				);
				return ($candidate.length ? $candidate.eq(0) : $());

			case 'closest-prev':
				var $selection = $base,
					$candidate;
				do {
					$candidate =
						$selection.filter(selector)
							.add($selection.prevAll(selector))
							.add($selection.prevAll().find(selector));
				} while (
					!$candidate.length &&
					($selection = $selection.parent()).length
				);
				return ($candidate.length ? $candidate.slice($candidate.length - 1) : $());

			case 'descendant':
				return $base.find(selector);

			case 'ancestor':
				return $base.parents(selector);

			default:
				return false;
			}
		},

		/**
		 * Creates a regular expression instance matching the search string
		 * while ignoring common diacritics.
		 *
		 * @param search search string
		 * @param flags  resulting regular expression flags
		 * @returns      regular expression
		 */
		buildMatcher: function(search, flags) {

			var tagRemoving = document.createElement('div');
			tagRemoving.innerHTML = search.trim();
			var s = tagRemoving.textContent || tagRemoving.innerText || '';

			s = s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&').split(' ').join('|');
			for (var i = 0, d = [
				'[aAáÁäÄâÂąĄăĂåÅàÀ]',
				'[cCćĆčČçÇ]',
				'[dDďĎđĐ]',
				'[eEéÉěĚëËêÊęĘèÈėĖæÆ]',
				'[iIíÍïÏîÎįĮìÌıİ]',
				'[lLĺĹľĽłŁļĻ]',
				'[nNńŃňŇņŅ]',
				'[oOóÓöÖőŐôÔòÒøØ]',
				'[rRŕŔřŘŗŖ]',
				'(ss|šš|ŠŠ|ß)',
				'[sSśŚšŠşŞ]',
				'[tTťŤţŢ]',
				'[uUúÚůŮüÜűŰûÛųŲùÙ]',
				'[yYýÝÿŸŷŶ]',
				'[vVwWŵŴ]',
				'[zZźŹžŽżŻ]'
			], m; m = d[i++]; ) {
				s = s.replace(new RegExp(m, 'gi'), m);
			}

			return new RegExp('(' + s + ')', flags || 'gi');
		},

		/**
		 * Extended selector evaluation - enables XPath like axis prefix.
		 * Allows multiple expressions separated by `|`.
		 *
		 * @param $base context element to be used when the axis is present
		 * @param path  jQuery selector, possibly starting with an axis prefix
		 *              Prefix is separated by '::' (double colon). Multiple such
		 *              expression can be joined by '|'.
		 * @returns     jQuery selection or false (any path is not a selector or axis
		 *              name is not recognized)
		 */
		queryPath: function($base, path) {

			if (!path) {
				return false;
			} else if (path instanceof jQuery)
				return path;

			var $elems = $(),
				paths = path.split(/\| ?/);

			switch (paths.length) {
			case 0:
				return false;
			case 1:
				// To preserve element ordering in case there is a single branch of the expression:
				return this.queryPathSingle($base, paths[0]);
			}

			for (var j = 0; j < paths.length; j++) {

				var $elem = this.queryPathSingle($base, paths[j]);

				if ($elem === false) {
					return false;
				}
				$elems = $elems.add($elem);
			}

			return $elems;
		},

		/**
		 * Vypisuje chybu.
		 * Argumenty:
		 * - channel: komunikacni kanal ('channel': JS konzole, 'user': zprava se zobrazi uzivateli)
		 * - message: chybova zprava
		 * - data: dalsi data k vypsani
		 */
		reportError: function(channel, message, data) {
			switch (channel) {
			case 'user':
				window.O2widget.classes.sysmsg.showMessage([
					{
						"text": message,
						"textInternal": "",
						"severity": "danger",
						"isInternal": false,
						"closeBtn": true,
						"autoClose": 0,
						"messageId": "dsError"
					}
				]);
				// fall through!
			case 'console':
			default:
				var errorMsg = '';
				if (data && data.widgetName) {
					errorMsg += "Error in '" + data.widgetName + "'.\n\n";
				}
				errorMsg += message;
				console.error(errorMsg);
				if (data)
					console.log(data);

				break;
			}
		},

		getActiveSubmit: function(evt) {
			var oe = evt && evt.originalEvent,
				sbtn = oe && (oe.explicitOriginalTarget || oe.relatedTarget || document.activeElement),
				$sbtn;

			if (sbtn && sbtn.nodeType != 1) {
				sbtn = sbtn.parentNode;
			}

			if (!sbtn) {
				return null;
			}

			$sbtn = $(sbtn);

			if ($sbtn.attr('type') != 'submit') {
				return null;
			}

			return {
				name: $sbtn.attr('name'),
				value: $sbtn.val()
			};
		},

		extendFromData: function(obj, data, prefix, excludes) {
			var len = prefix.length;
			for (var dataName in data) {
				if (dataName.indexOf(prefix) == 0 && dataName.length > len) {
					var initial = dataName.substring(len, len + 1),
						lo = initial.toLowerCase();
					if (lo != initial) {
						var optionName = lo + dataName.substring(len + 1);
						if (!excludes || !excludes[optionName]) {
							obj[optionName] = data[dataName];
						}
					}
				}
			}
		},

		/**
		 * Nacte z elementu serializovana data pro AJAX. Druhy argument je jQuery
		 * udalost; pokud je to udalost 'submit', pouzije ji k doplneni elementu,
		 * na ktery uzivatel kliknul.
		 */
		collectData: function($elm, evt) {
			if (!$elm.is('form')) {
				return {};
			} else {
				var data = $elm.serialize(),
					submit = this.getActiveSubmit(evt);

				if (submit && submit.name && submit.value) {
					data = (data ? (data + '&') : '') + encodeURIComponent(submit.name) + '=' + encodeURIComponent(submit.value);
				}
				return data;
			}
		},

		joinUrl: function(base, params) {
			var hasParams = base && base.match(/\?/),
				paramStr = '';
			if ('object' == typeof params) {
				for (var k in params) {
					paramStr =
						(paramStr ? (paramStr + '&') : '') +
						encodeURIComponent(k) + '=' + encodeURIComponent(params[k]);
				}
			} else {
				paramStr = params + '';
			}
			return (base + (hasParams ? '&' : '?') + paramStr);
		},

		/**
		 * Odscrolluje plynule na element.
		 */
		scrollTo: function($elm, speed, offset, callback) {
			if (typeof offset === 'undefined') {
				var fixed = O2widget && O2widget.classes && O2widget.classes.fixed;
				if (fixed) {
					offset = -fixed.anchorDelta();
				} else {
					offset = 0;
				}
			}

			var $scrollParent = $elm.scrollParent();
			if ($scrollParent.is(document))
				$scrollParent = $('html, body');

			$scrollParent.stop().animate({
				scrollTop: $elm.offset().top + offset
			}, speed || 500, 'swing', callback);
		},

		/**
		 * Testuje, jestli je argument validni selektor.
		 */
		isValidSelector: function(selector) {
	        try {
	            $(selector);
	        } catch(error) {
	            return false;
	        }
	        return true;
	    },

		/**
		 * Testuje, zda je aktualni rozliseni md nebo vetsi.
		 */
		isTabletPlus: function() {
			return this.isMedia(['md', 'desktop']);
		},

		/**
		 * Checks whether current screen size matches the media specified.
		 *
		 * @param media String or Array of strings; valid media names are:
		 *              `desktop` = `lg` (`bigscreen` = `xl`), `md` = `md`,
		 *              `mobile` = `sm` (`large-mobile`, `small-mobile`)
		 */
		isMedia: function(media) {

			this.prepareMediaChecks();

			if ($.isArray(media)) {

				// Always return false, if one of the media is noIE and you are in IE.
				if (media.includes('noIE') && window.isIE)
					return false;

				for (var i = 0; i < media.length; i++) {
					var currentMedia = media[i];
					if (currentMedia === "noIE") // Don't check again, already checked.
						continue;

					if (this.isMedia(currentMedia))
						return true;
				}
				return false;

			} else {

				switch (media) {
					case 'hg':
					case 'huge': // deprecated
						return this.checkMediaThreshold('$hg');
					case 'xl':
					case 'bigscreen': // deprecated
						return this.checkMediaThreshold('$xl', '$hg');
					case 'lg':
						return this.checkMediaThreshold('$lg', '$xl');
					case 'md':
					case 'tablet': // deprecated
						return this.checkMediaThreshold('$md', '$lg');
					case 'sm':
					case 'large-mobile': // deprecated
						return this.checkMediaThreshold('$sm', '$md');
					case 'xs':
					case 'small-mobile': // deprecated
						return this.checkMediaThreshold(false, '$sm');
					case 'mobile': // deprecated
						return this.checkMediaThreshold(false, '$md');
					case 'desktop': // deprecated
						return this.checkMediaThreshold('$lg');
					case 'noIE':
						return !window.isIE;
				}
			}
		},

		/**
		 * Pripravi elementy, ktere jsou v CSS nastavene jako viditelne vzdy od urciteho
		 * rozliseni vyse. Elementy zaradi do DOM a nastavi jim styl tak, aby nebyly videt
		 * (1x1 obrazovy bod v pravem dolnim rohu obrazovky).
		 *
		 * Pozor, nazvy CSS trid jsou misty matouci.
		 */
		prepareMediaChecks: function() {

			if (this.mediaChecks) {
				return;
			}

			var invisible = {
					margin: 0, border: 0, padding: 0, width: 1, height: 1, overflow: 'hidden',
					position: 'absolute', left: 'auto', top: 'auto', right: 0, bottom: 0,
					background: 'transparent'
				},
				$sm = $('<div class="h-show-sm-up"></div>').css(invisible),
				$md = $('<div class="h-show-md-up"></div>').css(invisible),
				$lg = $('<div class="h-show-lg-up"></div>').css(invisible),
				$xl = $('<div class="h-show-xl-up"></div>').css(invisible),
				$hg = $('<div class="h-show-hg-up"></div>').css(invisible),
				$container = $('<div></div>').css(invisible)
					.append($sm)
					.append($md)
					.append($lg)
					.append($xl)
					.append($hg);

			$('body').append($container);

			this.mediaChecks = {
				$sm: $sm,
				$md: $md,
				$lg: $lg,
				$xl: $xl,
				$hg: $hg
			};
		},

		/**
		 * Otestuje jednu z mezi - vstupem jsou dva klice v mape mediaChecks, prvni ma byt
		 * viditelny, druhy skryty.
		 */
		checkMediaThreshold: function(isA, isNotA) {
			return (
				(!isA    || this.mediaChecks[isA].is(':visible')) &&
				(!isNotA || this.mediaChecks[isNotA].is(':hidden'))
			);
		},

		/**
		 * Testuje, zda je pro dany widget nastaveny lokalni cil (tj. element ve strance,
		 * ktery je jeho cilem). Toto nastaveni muze byt definovane cilem odkazu (atribut
		 * href, kdyz zacina na "#"), pripadne formulare (atribut action, kdyz zacina na "#").
		 * Pokud je lokalni cil nastaveny, vraci funkce jQuery kolekci obsahujici cil.
		 * Jinak vrati false.
		 */
		localTarget: function($elm) {
			var str = $elm.attr($elm.is('form') ? 'action' : 'href');

			if (!str || str.charAt(0) != '#') {
				return false;
			}
			if (!this.isValidSelector(str)) {
				return false;
			}
			return $(str);
		},

		/**
		 * Odvozuje z elementu HTTP metodu pro AJAX. Vraci nazev malymi pismeny,
		 * aby bylo mozne volat nad jQuery $[method](url).
		 */
		deriveMethod: function($elm) {
			if ($elm.is('form')) {
				return ($elm.attr('method') || 'get').toLowerCase();
			} else {
				return 'get';
			}
		},

		/**
		 * Odvozuje z elementu URL pro AJAX.
		 */
		deriveUrl: function($elm) {
			if ($elm.is('form'))
				return $elm.attr('action');
			else if ($elm.attr('href'))
				return $elm.attr('href');
			else
				return location.href;
		},

		/**
		 * Vrátí pozici prvku relativně k viewportu okna prohlížeče
		 * @param {object} [$elm] jQuery objekt s elementem, jehož polohu budeme zjišťovat
		 * @return {object} obj.left = pozice X, obj.top = pozice Y
		 */
		getViewportOffset: function ($elm) {
			var offset = $elm.offset();
			viewportOffsetTop = offset.top - $(document).scrollTop();
			viewportOffsetLeft = offset.left - $(document).scrollLeft();

			return { top: viewportOffsetTop, left: viewportOffsetLeft };
		},

		/**
		 * Zjistí, zda elementu bylo dosaženo scrollováním.
		 * @param {object} [$elm] jQuery objekt s elementem, jehož viditelnost chceme zjišťovat
		 * @param {number} [offset] Element je považovaný za viditelný o zadaný počet pixelů dříve.
		 *                          V případě záporného čísla o zadaný počet pixelů později.
		 * @return {boolean}
		 */
		scrolledToElement: function($elm, offset, $viewport) {
			if (!$elm || !$elm.length) {
				return null;
			}

			var rect      = $elm[0].getBoundingClientRect(),
			    top       = rect.top,
			    bottom    = rect.bottom,
				$viewport = $viewport || $elm.scrollParent(),
				offset    = offset || 0;

			if ($viewport.is(document))
				$viewport = $(window);

			var $viewportHeight = $viewport.height();
			var typeofViewport  = $viewport[0].toString();

			// Přepočítá top/bottom, pokud viewport není window
			if ($viewport[0] !== window && typeofViewport !== '[object Window]' && typeofViewport !== '[object DOMWindow]') { // PhantomJS kompatibilní
				var viewportRect = $viewport[0].getBoundingClientRect();
				top = top - viewportRect.top;
				bottom = bottom - viewportRect.top;
			}

			return (bottom + offset) > 0 && (top - offset) <= $viewportHeight;
		},

		/**
		 * Převede base64 UTF-8 do textu.
		 * @param {string} [str] Text encodovaný v base64 UTF-8
		 * @return {string} Dekódovaný UTF-8 text.
		 */
		decodeBase64: function(str) {
			return decodeURIComponent(
				atob(str)
				.split('')
				.map(function(c) {
					return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
				})
				.join('')
			);
		},

		/**
		 * Převede seznam hodnot oddělených čárkou na pole.
		 * @param {string} values Seznam hodnot oddělených čárkou, např. "1, 2,3, 4"
		 * @return {array} Seznam hodnot. Pokud není vstupní formát typu string, vrátí se původní hodnota parametru.
		 */
		csvToArray: function(values) {
			if (typeof values !== 'string')
				return values;

			values = values.replace(/\s/g, ''); // Odstranění mezer
			values = values.split(',');         // Rozpad do pole
			return values;
		},

		/**
		 * Pokusí se zjistit, zda jde o dotykové zařízení.
		 * https://gist.github.com/roydejong/fb021a973160fa3d04d7aaca675a46cf
		 */
		hasTouch: function() {
			try {
				var prefixes = " -webkit- -moz- -o- -ms- ".split(" ");

				var mq = function (query) {
					return window.matchMedia(query).matches;
				};

				if (("ontouchstart" in window) || (typeof window.DocumentTouch !== "undefined" && document instanceof window.DocumentTouch)) {
					return true;
				}

				return mq(["(", prefixes.join("touch-enabled),("), "heartz", ")"].join(""));
			} catch (e) {
				return false;
			}
		}
	};

})(jQuery);

(function($) {

 /**
  * Slouží jako kontejner pro všechny widgety a jejich instance a zároveň umožňuje jejich vytváření a správu.
	* Widget či widgetClass - Takto je označen objekt, který umožňuje vytvářet instance widgetu a zároveň se stará o jejich správu.
	* Instance widgetu - Takto je označen objekt, který byl vytvořen widgetem jakožto jeho instance. Jedná se tedy o objekt, který je již vázaný na konkrétní element ve stránce.
  */
	window.O2widget = {

  /**
   * Abstraktní třída widgetu, ze které následně, pomocí prototype, přebírá vlastnosti každý widget. Konkrétní vlastnosti této proměnné jsou v samostatném .js souboru.
   */
		AbstractWidget: function() {},

  /**
   * Obsahuje seznam všech widgetů vytvořených pomocí funkce createClass().
	 * @type {Object.<string, Object>}
   */

		classes: {},

  /**
   * Obsahuje seznam všech asociací mezi widgetem a CSS třídou. Pokud je daná CSS třída nalezena v DOM, inicializuje se na daném elementu instance widgetu.
	 * @type {Array.<Object>}
   */
		associations: [],

		/**
		 * Obsahuje seznam všech instancí widgetů, jenž mají definovaný "media" atribut a tedy mění svůj stav na základě šířky prohlížeče.
		 * @type {Array.<Object>}
		 */
		mediaEnabled: [],

		/**
		 * Vytvoří nový widget a uloží ho do O2widget.classes.
		 * @param  {string} widgetName Unikátní název widgetu.
		 * @param  {function} constructorFunction Funkce sloužící jako construktor pro nové instance widgetu. Při instancování, jsou do ní předány parametry "elm" (element, který instanci zavolal) a "options" (předáván z O2widget.associate()). Konstruktor by měl vždy na závěr volat inicializaci instance widgetu (funkce AbstractWidget.init()).
		 * @param  {Object.<string, function>} staticProps Objekt, jehož vlastnosti se přes prototype vážou na widgetClass, jde tedy o jakési jeho statické vlastnosti. Pokud obsahuje vlastnost "delegate", zavolá se její funkce vždy pouze jednou při první inicializaci instance widgetu.
		 * @param  {Object.<string, function>} instanceProps Objekt, jehož vlastnosti se přes prototype vážou na instanci widgetu. Další vlastnosti instance jsou součástí objektu AbstractWidget.
		 * @return {function} Třída (či přesněji constructor funkce) s výsledným widgetem. Tuto třídu označujeme jako widgetClass.
		 */
		createClass: function(widgetName, constructorFunction, staticProps, instanceProps) {

			// Rozšíření pro widgetClass:
			$.extend(constructorFunction, {

				/**
				 * Vrací existující instanci widgetu na vybraném elementu. Funkce je součástí widgetClass, tedy je přístupná přes O2widget.classes.WIDGET_NAME.getInstance().
				 * @param  {string} elm Selektor elementu, jehož instance se má získat. Musí vždy odpovídat pouze jednomu elementu.
				 * @return {(Object|undefined)} Instance widgetu, případně undefined, pokud nebyla instance na elementu nalezena.
				 */
				getInstance: function(elm) {
					return O2widget.getInstance(widgetName, elm);
				},

				/**
				 * Vrací existující instance widgetu, které se vážou k vybranému elementu, ale nejsou jeho přímou součástí. Funkce je součástí widgetClass, tedy je přístupná přes O2widget.classes.WIDGET_NAME.getRelatedInstanceList().
				 * @param  {string} elm Selektor elementu, jehož nadřazená instance se má získat. Musí vždy odpovídat pouze jednomu elementu.
				 * @return {(Object|undefined)} Výčet instancí widgetu, případně undefined, pokud nebyla žádná instance na vázaném elementu nalezena.
				 */
				getRelatedInstanceList: function(elm) {
					return O2widget.getRelatedInstanceList(widgetName, elm);
				},

				/**
				 * Prototype widgetu bude obsahovat objekt AbstractWidget, který následně bude sloužit jako construktor function pro nové instance widgetu.
				 */
				prototype: new O2widget.AbstractWidget(),

				sets: {},

				/**
				 * Seznam všech existujících instancí daného widgetu. Je přístupné přes O2widget.classes.WIDGET_NAME.instances.
				 * @type {Array}
				 */
				instances: [],

				/**
				 * Viz AbstractWidget.each().
				 */
				each: O2widget.AbstractWidget.each,

				/**
				 * Viz AbstractWidget.handle().
				 */
				handle: O2widget.AbstractWidget.handle,

				/**
				 * Viz AbstractWidget.handleRelated().
				 */
				handleRelated: O2widget.AbstractWidget.handleRelated,

				/**
				 * Viz AbstractWidget.handleGlobal().
				 */
				handleGlobal: O2widget.AbstractWidget.handleGlobal,

				/**
				 * Určuje, zda v daném widgetu již byla spuštěna statická funkce delegate() (true), či nikoliv (false).
				 * @type {boolean}
				 */
				isDelegated: false

			}, staticProps);

			// Rozšíření pro instanci widgetu:
			$.extend(constructorFunction.prototype, {
				widgetName: widgetName,
				widgetClass: constructorFunction
			}, instanceProps);

			this.classes[widgetName] = constructorFunction;

			return constructorFunction;
		},

		/**
		 * Vrací existující instanci vybraného widgetu na vybraném elementu. Funkce je součástí O2widget, tedy je přístupná přes O2widget.getInstance().
		 * @param  {string} widgetName Název widgetu, jehož instance se má získat.
		 * @param  {string} elm Selektor elementu, jehož instance se má získat. Musí vždy odpovídat pouze jednomu elementu.
		 * @return {(Object|undefined)} Instance widgetu, případně undefined, pokud nebyla instance na elementu nalezena.
		 */
		getInstance: function(widgetName, elm) {

			var $elm = $(elm),
				dataName = widgetName + '-instance';

			return $elm.data(dataName);
		},

		/**
		 * Vrací existující instance vybraného widgetu, které se vážou k vybranému elementu, ale nejsou jeho přímou součástí. Funkce je přístupná přes O2widget.getRelatedInstanceList().
		 * @param  {string} widgetName Název widgetu, jehož instance se má získat.
		 * @param  {string} elm Selektor elementu, jehož nadřazená instance se má získat. Musí vždy odpovídat pouze jednomu elementu.
		 * @return {(Object|undefined)} Výčet instancí widgetu, případně undefined, pokud nebyla žádná instance na vázaném elementu nalezena.
		 */
		getRelatedInstanceList: function(widgetName, elm) {

			var $elm = $(elm),
				dataName = widgetName + '-related-instance';

			return $elm.data(dataName);
		},

		/**
		 * Vybranému elementu přiřadí novou instanci widgetu.
		 * @param  {string} widgetName Název widgetu.
		 * @param  {Object} elm Objekt s HTML elementem, k němuž bude přiřazena instance.
		 * @param  {Object} options Další libovolná data, která se mají předat do instance widgetu.
		 * @return {type} Nová instance widgetu. Pokud na daném elementu instance stejného widgetu již existuje, místo vytvoření nové vrátí již existující.
		 */
		assignInstance: function(widgetName, elm, options) {
			var i = O2widget.getInstance(widgetName, elm);
			if (i) {
				return i;
			} else {
				return new this.classes[widgetName](elm, options);
			}
		},


		/**
		 * Odstraní zadanou instanci ze seznamu instancí. Daná instance ale existuje dál.
		 *
		 * @param {Object} instance Instance widgetu.
		 * @return {(Object|boolean)} Odstraněná instance nebo false, pokud daná instance nebyla nalezena.
		 */
		removeInstance: function(instance) {
			var instances = this.classes[instance.widgetName].instances;
			var index = instances.indexOf(instance);
			if (index >= 0)
				return instances.splice(index, 1);
			else
				return false;
		},

		/**
		 * Vytvoří novou asociaci mezi widgetem a CSS třídou. Tato asociace bude v budoucnu použita pro vytváření instancí widgetů.
		 * @param  {string} widgetName Název widgetu, na jehož základě má být instance vytvořena.
		 * @param  {string} selector JQuery selektor elementů, na něž se instance naváže.
		 * @param  {string} module Název modulu, kde se widget nachází. Modul je stejnojmenný .js soubor.
		 * @param  {Object} options Další libovolná data, která se mají předat do instance widgetu.
		 * @return {Object} O2widget objekt.
		 */
		associate: function(widgetName, selector, module, options) {
			this.associations.push({
				selector: selector,
				widgetName: widgetName,
				module: (module || false),
				options: options
			});

			return this;
		},

		/**
		 * Vrátí jQuery selektor, který je asociován se zadaným widgetem.
		 * @param  {string} widgetName Název widgetu, jehož selektor se má vrátit.
		 * @return {(string|boolean)} JQuery selektor asociovaný se zadaným widgetem. False, pokud daný widget neexistuje.
		 */
		resolveWidgetSelector: function(widgetName) {
			var widget = this.associations.filter(function(val){
				return val.widgetName == widgetName;
			});

			if (widget.length == 1)
				return widget[0].selector;
			else
				return false;
		},

		/**
		 * V zadaném obsahu nazezne všechny CSS třídy asociované na widgety a přiřadí jim nové instance, pokud ještě neexistují.
		 * @param  {Object} $content JQuery object s elementy, v jejižch obsahu se mají hledat asociace.
		 * @return {undefined}
		 */
		resolveAssociations: function($content) {
			for (var i = 0, associations = this.associations, a; a = associations[i++]; ) {
				$content.find(a.selector).add($content.filter(a.selector)).each(function() {
					if (a.module) {
						var elm = this;
						(function() {
							var assoc = a;
							O2modules.load(assoc.module, function() {
								O2widget.assignInstance(assoc.widgetName, elm, assoc.options);
							});
						})();
					} else {
						O2widget.assignInstance(a.widgetName, this, a.options);
					}
				});
			}
		},

		/**
		 * V zadaném obsahu nazezne všechny existující instance widgetů a vypne je. Instance budou dále k dispozci, pouze budou neaktivní, dokud neude obsah zcela vymazán.
		 * @param  {Object} $content JQuery object s elementy, v jejižch obsahu se mají hledat instance.
		 * @return {undefined}
		 */
		resolveDissociations: function($content) {

			for (var i = 0, associations = this.associations, a; a = associations[i++]; ) {
				$content.find(a.selector).add($content.filter(a.selector)).each(function() {
					var widgetClass = O2widget.classes[a.widgetName],
						instance = widgetClass && widgetClass.getInstance(this);

					if (instance) {
						var toRemove = instance.turnOff();

						if (toRemove)
							O2widget.removeInstance(instance);
					}
				});
			}
		},

		/**
		 * Resolves media filters for all media enabled widget instances.
		 */

		/**
		 * U všceh instancí widgetů, které jsou závislé na šířce prohlížeče, ověří, zda se daná instance má aktivovat, či deaktivovat. Tato funkce by měla být spouštěna vždy při resize okna prohlížeče.
		 * @return {undefined}
		 */
		resolveMedia: function() {
			for (var i = 0, mediaEnabled = this.mediaEnabled, instance; instance = mediaEnabled[i++]; ) {
				instance.checkMedia();
			}
			$(document).trigger('mediachange.o2util');
		},

		/**
		 * Checks for all watching widget instances above the changed content.
		 */

		/**
		 * Prověří, zda na některém z předků změněného obsahu, nejsou navázané watchery widgetů a pokud ano, tak u všech aktivních instancí spustí rerender. Tato funkce by měla být spouštěna vždy při "modified.o2util" eventu nad určitou částí DOMu.
		 * @param  {Object} $changed JQuery object se všemi elementy, jenž byly v DOM nahrazeny novým obsahem.
		 * @return {undefined}
		 */
		resolveWatchers: function($changed) {

			$changed.parents().each(function() {
				var ls = $(this).data('o2widget-watchers');
				if (ls && ls.length) {
					for (var i = 0, instance; instance = ls[i++]; ) {
						if (instance && !instance.disabled) {
							instance.scanDom();
							instance.render();
						}
					}
				}
			});
		}
	};

})(jQuery);
(function($, AbstractWidget) {

	var $document = $(document);
	var $window = $(window);

	/**
	 * Konstruktor AbstractWidget je již vytvořen v O2widget.AbstractWidget a zde je rozšířen o další funkce.
	 */
	$.extend(AbstractWidget, {

		// The following methods get copied on each subclass
		// constructor:

		each: function(callback, ignoreDisabled) {
			var args = Array.prototype.slice.call(arguments, 1);
			var callbackStatus;
			for (var instances = this.instances, i = 0, instance; instance = instances[i++]; ) {
				if (!ignoreDisabled || !instance.disabled) {
					callbackStatus = callback.apply(instance, args);
					if (callbackStatus === false)
						break;
				}
			}
		},

		handle: function(eventType, selector, handlerName) {
			var widget = this;
			$document.on(eventType, selector, function(evt, data) {
				var i = widget.getInstance(this);
				if (i && !i.disabled) {
					if (typeof i[handlerName] == 'function')
						i[handlerName](evt, this, data);
					else if (typeof widget[handlerName] == 'function')
						widget[handlerName](evt, this, data);
				}
			});
			return this;
		},

		/**
		 * Umožní widgetu navázat handler na globalní event, tedy takový, který probublá až na $document. Handler se spustí nad všemi instancemi widgetu.
		 * Jelikož v jednu chvíli může na $document probublat mnoho stejných event, spouští se handler s určitým zpožděním.
		 *
		 * @param {string} eventType Název eventy, např. "shown.o2util".
		 * @param {string} handlerName Název funkce, která se má spustit.
		 * @param {number} debounceTime Čas v milisekundách, po který se má vyčkávat, zda stejný event znovu neprobublá na $document.
		 * @returns {object} Widget class.
		 */
		handleGlobal: function(eventType, handlerName, debounceTime) {
			var widget = this;

			if (!debounceTime)
				debounceTime = 1;

			$document.on(eventType, $.debounce(debounceTime, function(evt, data) {
				var runWidgetClassFn = false; // Zda se callback funkce spustí z třídy widgetu, nikoliv z instance.
				widget.each(function() {
					if (typeof this[handlerName] === 'function')
						this[handlerName](evt, this, data); // Spustí callback pro každou instanci.
					else if (typeof widget[handlerName] === 'function') {
						runWidgetClassFn = true;
						return false; // Vrací status "false", který zastaví "each" iteraci, protože widgetClassFn chcene spustit pouze jednou.
					}
				}, true);
				if (runWidgetClassFn)
					widget[handlerName](evt, this, data); // Spustí callback pro widgetClass.
			}));

			return this;
		},

		handleRelated: function(eventType, selector, handlerName) {
			var widget = this;
			$document.on(eventType, selector, function(evt, data) {
				var ls = widget.getRelatedInstanceList(this);
				if (ls && ls.length) {
					for (var n = 0, i; i = ls[n++]; ) {
						if (i && !i.disabled) {
							if (typeof i[handlerName] == 'function')
								i[handlerName](evt, this, data);
							else if (typeof widget[handlerName] == 'function')
								widget[handlerName](evt, this, data);
						}
					}
				}
			});
			return this;
		}
	});

	$.extend(AbstractWidget.prototype, {

		defaultOptions: {}, // To be overridden in the subclass.

		profileOptions: {}, // To be overridden in the subclass.

		paramExpansion: {   // May be extended in the subclass.

			// Keys are parameter names, values are functions to be applied on the
			// widget instance. Functions accept the original value of the parameter
			// as single argument.

			/* FIXME - requires preparing toggle.js and popover.js for media filter
			tabletPlus: function(value) {
				if (value) {
					this.options.media = ['tablet','mobile'];
				}
			}
			*/
		},

		/**
		 * Generic method to initialize any instances of the subclasses.
		 *
		 * @param elm       - selector, jQuery object or a DOM element - single element should be returned
		 * @param options   - common configuration options
		 * @param propNames - names of widget properties to be set from computed options
		 *
		 * @returns An already existing instance of the widget for the element, or (boolean) true if the
		 *          widget was initialized anew.
		 */
		init: function(elm, options, propNames) {

			var $elm = this.$elm = $(elm),
			    widgetName = this.widgetName;

			if ($elm.length) {

				var dataName = widgetName + '-instance',
					instance = $elm.data(dataName);

				if (instance) { // FIXME - tested in the assignInstance - is redundant here?

					// The instance for the element already exists - return the instance:
					return instance;

				} else {

					this.uuid = 'w' + Math.floor(Math.random() * 1000000000000);

					this.propNames = propNames;

					// The instance is linked to the root element:
					$elm.data(dataName, this);

					// The instance is pushed to the static instance list at the class:
					this.widgetClass.instances.push(this);

					// All possible sources of widget options are merged in due order:
					this.mergeOptions(options);

					// Expand parameters:
					this.expandParams();

					// All options listed in the constructor are set directly as the instance properties:
					if (('undefined' != typeof propNames) && propNames.length) {
						for (var i = 0, l = propNames.length; i < l; i++) {
							var n = propNames[i];
							this[n] = this.options[n];
						}
					}

					this.registerMedia();
					this.registerWatch();

					// Basic widget initialization steps:
					this.scanDom();
					if (this.mediaMatch()) {
						this.turnOn();
					} else {
						this.disabled = true;
					}
					this.delegateOnce();

					// New instance was created - return `true`:
					return true;
				}
			}
		},

		/**
		 * Apply predefined parameter value expansions:
		 */
		expandParams: function() {
			var expansion = this.paramExpansion,
			    options = this.options;
			for (var p in options) {
				var e = expansion[p];
				if (e) {
					e.apply(this, [options[p]]);
				}
			}
		},

		/**
		 * Register the instance as media enabled, if it a media filter.
		 */
		registerMedia: function() {

			var media = this.media;

			if (media) {
				O2widget.mediaEnabled.push(this);
			} else {
				return;
			}

			if (!$.isArray(media) && media.match(',')) {
				media = this.media = media.split(',');
			}
		},

		/**
		 * Check whether the instance should watch for changes in its content.
		 * If so, registers the instance as a watcher.
		 */
		registerWatch: function() {

			var options = this.options;

			if (options.watchContent) {

				var $elm = this.$elm,
					path = options.watchContentPath,
					$watched = (path ? O2util.queryPath($elm, path) : $elm),
					watchers = $watched.data('o2widget-watchers');

				if (watchers && watchers.length) {
					watchers.push(this);
				} else {
					watchers = [this];
					$watched.data('o2widget-watchers', watchers);
				}
			}
		},

		/**
		 * Tell whether the widget media filter matches the current screen size.
		 * Note that no filter means any screen size matches the filter.
		 */
		mediaMatch: function() {

			var media = this.media;

			if (!media) {
				return true;
			}

			return O2util.isMedia(media);
		},

		/**
		 * Check the current media size and turn the widget on / off accordingly.
		 */
		checkMedia: function() {
			if (this.mediaMatch()) {
				if (this.disabled) {
					this.turnOn();
				}
			} else {
				if (!this.disabled) {
					this.turnOff();
				}
			}
		},

		/**
		 * Turn the widget on - its rendering and event binding will be active.
		 */
		turnOn: function() {
			this.disabled = false;
			this.render();
			this.bind();
		},

		/**
		 * Turn the widget off - rendering and event binding will be as if there were no widget
		 * at all.
		 */
		turnOff: function() {
			this.disabled = true;
			this.unbind();
			return this.unrender();
		},

		/**
		 * Checks event data to detect possible recursion.
		 *
		 * @param data event data
		 * @returns    boolean - true if recursion would be caused
		 */
		isRecursion: function(data) {
			return (data && data.sourceUuid && data.sourceUuid == this.uuid);
		},

		/**
		 * Merge options passed to the init method with the configuration set on the DOM
		 * element via data-* attribute(s).
		 *
		 * @param options - common configuration options
		 */
		mergeOptions: function(options) {

			var data = this.$elm.data(),
				widgetName = this.widgetName;

			this.options = $.extend({}, this.defaultOptions, options || {});

			var profile = this.profile = (data[widgetName + 'Profile'] || this.options.profile),
				profileOptions = profile && this.profileOptions[profile];

			// A data-<widgetName>-profile attribute can be used: preconfigured profiles
			// can be referenced this way.

			if (profileOptions) {
				$.extend(this.options, profileOptions);
			}

			// A single data-<widgetName> attribute containing JSON encoded property map
			// can be stated in the HTML:

			if ("undefined" != typeof data[widgetName]) {
				$.extend(this.options, data[widgetName]);
			}

			// Multiple data-<widgetName>-<propertyName> attributes are understood, too:

			O2util.extendFromData(this.options, data, widgetName, {'instance': true});
		},

		/**
		 * Calls the "static" `delegate` method of the widget constructor.
		 * The `delegate` method is called only once for each widget subclass - at the moment of
		 * the first instance initialization.
		 */
		delegateOnce: function() {
			var c = this.widgetClass;
			if (c && c.delegate && !c.isDelegated) {
				c.delegate();
				c.isDelegated = true;
			}
		},

		/**
		 * Reports a widget specific error.
		 *
		 * @param channel - see O2util.reportError for meaning
		 * @param message - textual message (simple string)
		 */
		reportError: function(channel, message) {
			O2util.reportError(
				channel,
				message,
				$.extend({}, this.options, {
					elm: this.$elm.get(0),
					widgetName: this.widgetName
				})
			);
		},

		/**
		 * Adds the instance to a named set.
		 */
		addToSet: function(setName) {

			var sets = this.widgetClass.sets,
				name = setName || '';
				set = sets[name];

			if (!set) {
				set = sets[name] = [];
				set.setName = setName;
			}

			if (!this.uuid || !set[this.uuid]) {
				set.push(this);
				set[this.uuid] = this;
			}
		},

		/**
		 * Prepares an instance for set membership - checks for
		 * container element representing an implicit set, in any case
		 * adds the instance to the set.
		 */
		prepareSet: function() {
			if (!this.set) {

				var widgetName = this.widgetName,
					setPath = this.options.setPath || ('closest::.js-' + widgetName + '-set'),
					$set = O2util.queryPath(this.$elm, setPath),
					dataName = widgetName + '-set-id';

				if ($set.length) {
					$set.data(dataName, this.set = ($set.data(dataName) || ('generated-set-' + Math.random())));
				}
			}
			if (this.set) {
				this.addToSet(this.set);
			}
		},

		/**
		 * Executes (applies) a callback for all other members of the same set.
		 * The first argument is a callback, the second specifies, whether to ignore
		 * disabled instances; all remaining arguments are passed to the callback.
		 */
		othersInSet: function(callback, ignoreDisabled) {
			var args = (arguments.length && arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : []);
			var returnData = [];
			for (var instances = this.widgetClass.sets[this.set], i = 0, instance; instance = instances[i++]; ) {
				if (instance !== this && (!ignoreDisabled || !instance.disabled)) {
					var callbackData = callback.apply(instance, args);
					if (callbackData)
						returnData.push(callbackData);
				}
			}
			return returnData;
		},

		/**
		 * Executes (applies) a callback for all members of the same set (including the current
		 * instance). The first argument is a callback, the second is a base value, the third one
		 * an operation callback, the fourth one specifies, whether to ignore disabled instances;
		 * all remaining arguments are passed to the callback.
		 */
		collectThruSet: function(callback, base, operation, ignoreDisabled) {
			var args = (arguments.length && arguments.length > 4 ? Array.prototype.slice.call(arguments, 4) : []),
				r = base;
			for (var instances = this.widgetClass.sets[this.set], i = 0, instance; instance = instances[i++]; ) {
				if (!ignoreDisabled || !instance.disabled) {
					var t = callback.apply(instance, args);
					r = operation(r, t);
				}
			}
			return r;
		},

		/**
		 * Marks elements as related - saves the instance as a member of an array that is
		 * set as data on the elements; possibly adds a class.
		 */
		markRelatedElements: function(elements, cls) {
			var $elements = $(elements),
				dataName = this.widgetName + '-related-instance',
				instance = this;

			$elements.each(function() {
				var $this = $(this),
					ls = $this.data(dataName);
				if (ls) {
					if (!ls[instance.uuid]) {
						ls.push(instance);
						ls[instance.uuid] = true;
					}
				} else {
					ls = [instance];
					ls[instance.uuid] = true;
					$this.data(dataName, ls);
				}
			});

			if (cls) {
				$elements.addClass(cls);
			}
		},

		widgetName: null,  // Will be set automatically in the subclass prototype - string.

		widgetClass: null, // Will be set automatically in the subclass prototype - reference to the function.

		/**
		 * Scan the elements related to the $elm, cache the results as needed. This scan should be
		 * done only once, when the instance is created, to avoid repeated DOM traversal.
		 */
		scanDom: function() {
			// To be implemented in the subclass.
		},

		/**
		 * Adjust rendering of the widget.
		 */
		render: function() {
			// To be implemented in the subclass.
		},

		/**
		 * Bind necessary event handlers.
		 */
		bind: function() {
			// To be implemented in the subclass.
		},

		/**
		 * Restore rendering of the content as if there were no widget.
		 */
		unrender: function() {
			// To be implemented in the subclass.
		},

		/**
		 * Remove widget event handlers.
		 */
		unbind: function() {
			// To be implemented in the subclass.
		}
	});

})(jQuery, window.O2widget.AbstractWidget);
(function($) {

	if ('undefined' == typeof window.O2page) {
		window.O2page = {};
	}

	$.extend(O2page, {
		extend: function(obj) {
			$.extend(this, obj);
		},

		/**
		 * Singleton for showing popup notifications on the page.
		 */
		popUpNotification: {

			prepare: function() {

				var $elm = this.$elm = $('<div class="o2-popup" />'),
					$content = this.$content = $('<div class="o2-popup__content" />'),
					me = this;

				$elm
					.append($content)
					.append('<div class="o2-popup__buttons"><a href="#" class="o2-btn o2-btn--small o2-btn--icon o2-btn--transparent o2-popup__close"><span class="o2-icon o2-icon--cross"></span><span class="o2-btn__text"></span></a>');

				$(document).on('click', '.o2-popup__close', function() {
					me.hide();
				});
			},

			show: function(html) {

				if (!this.$elm || !this.$content) {
					this.prepare();
				}

				var $elm = this.$elm;

				$elm.addClass('o2-popup--removed');
				this.$content.html(html);
				$(document.body).append($elm);
				$elm.removeClass('o2-popup--removed');
			},

			hide: function() {

				var me = this;

				if (this.$elm && this.$content) {
					this.$elm.addClass('o2-popup--removed');
				}

				window.setTimeout(function() {
					me.$elm.remove();
				}, 2000);
			}
		}
	});

})(jQuery);

(function($) {

	O2widget.createClass(

		'submit',

		function(elm, options) {
			this.init(elm, options, []);
		},

		{
			delegate: function() {
				this.handle('change', '.js-submit-on-change', 'handleChange');
			}
			// other static methods
		},

		{
			defaultOptions: {},
			profileOptions: {},
			scanDom: function() {
				this.form = this.$elm.is('form') ? this.$elm[0] : this.$elm[0].form;

				if (!this.form) {
					O2util.reportError('consosle', 'Widget ' + this.widgetName + ' musí být definován uvnitř fomuláře.');
				}
			},
			render: function() {},
			bind: function() {},
			unrender: function() {},
			unbind: function() {},

			handleChange: function(evt) {
				if (!this.form)
					return false;

				var $elm = this.$elm,
				    form = this.form;

				// DEPRECATED attributes
				if ($elm.data('submit-url'))
					form.action = $elm.data('submit-url')
				if ($elm.data('submit-method'))
					form.method = $elm.data('submit-method');

				evt.stopImmediatePropagation();
				form.submit();
			}
		}
	);

})(jQuery);
// @TODO: Nahradit Tipso za popper.js
(function($) {
	O2widget.createClass(

		'tooltip',

		function(elm, options) {
			this.init(elm, options, []);
		},

		{
			// no static methods
		},

		{
			defaultOptions: {
				position:   'top',
				width:      false,
				maxWidth:   300,
				target:     false,
				delay:      100,
				hover:      true,
				shadow:     false,
				textleft:   false,
				background: '#000000',
				color:      '#ffffff',
				content:    false
			},

			profileOptions: {
				simplehtml: {
					target: 'next::.js-tooltip-content',
					shadow: true
				}
			},

			scanDom: function() {
				var target = this.options.target;
				if (target) {
					this.$target = O2util.queryPath(this.$elm, this.options.target);
				}
			},

			render: function() {
				if(this.$target)
					this.$target.hide();
			},

			bind: function() {

				var options = $.extend({
						useTitle: true,
						width:        this.options.maxWidth ? false : this.options.width,
						maxWidth:     this.options.maxWidth,
						delay:        this.options.delay,
						tooltipHover: this.options.hover,
						background:   this.options.background,
						color:        this.options.color,
						content:      this.options.content || null
					}, this.options),
					$target = this.$target,
					extraClasses = [];

				if (this.options.shadow)
					extraClasses.push('tipso--shadow');
				if(this.options.textleft)
					extraClasses.push('tipso--left');
				if(extraClasses.length > 0) {
					options.onBeforeShow = function($elm, elm, tipso) {
						tipso.tipso_bubble.addClass(extraClasses.join(' ')); // doplní tipso bublině extra classy dle zadaných options
					};
				}

				if ($target && $target.length) {
					options.content = $target.html();
					options.useTitle = false;
				}

				this.$elm.tipso(options);
			}
		}
	);
})(jQuery);


(function($) {
	O2widget.createClass(

		'double',

		function(elm, options) {
			this.init(elm, options);
		},

		{
			delegate: function() {
				this
					.handle('submit', 'form.js-double', 'handleSubmit')
					.handle('click', 'a.js-double', 'handleSubmit')
					.handleRelated('click', 'a.js-double-disable', 'handleDisabledClick');
			}
		},

		{
			defaultOptions: {
				preventDefault:  true,
				stopPropagation: true,
				lockTimeout:     30000,
				disabledClass:   '',
				classTarget:     'self::*',
				disable:         false
			},

			timeout: null,

			scanDom: function() {
				var options = this.options;

				this.$disable     = O2util.queryPath(this.$elm, options.disable);
				this.$classTarget = O2util.queryPath(this.$elm, options.classTarget);

				if (this.$disable) {
					this.markRelatedElements(this.$disable.filter('a'), 'js-double-disable');
				}

				if (options.blockDefault) // DEPRECATED fallback
					options.preventDefault = options.blockDefault;

				if (options.blockPropagation) // DEPRECATED fallback
					options.stopPropagation = options.blockPropagation;
			},

			setBlocked: function() {
				this.doubleBlocked = true;
				if (this.$disable) {
					this.$disable.filter('input, select, button, textarea').prop('disabled', true);
				}
				if (this.$classTarget && this.options.disabledClass)
					this.$classTarget.addClass(this.options.disabledClass);
			},

			resetBlocked: function() {
				this.doubleBlocked = false;
				if (this.$disable) {
					this.$disable.filter('input, select, button, textarea').prop('disabled', false);
				}
				if (this.$classTarget) {
					this.$classTarget.removeClass(this.options.disabledClass);
				}
			},

			handleSubmit: function(evt) {
				var options     = this.options,
					lockTimeout = options.lockTimeout,
					me          = this;

				if (this.doubleBlocked) {
					if (options.preventDefault)
						evt.preventDefault();
					if (options.stopPropagation)
						evt.stopImmediatePropagation();

					return false;
				} else {
					this.setBlocked();
					if (lockTimeout) {
						window.clearTimeout(this.timeout);
						this.timeout = window.setTimeout(function() {
							me.resetBlocked();
						}, lockTimeout);
					}

					return true;
				}
			},

			handleDisabledClick: function(evt) {
				if (this.doubleBlocked) {
					evt.preventDefault();
					return false;
				}
			}
		}
	);
})(jQuery);

(function($) {
	O2widget.createClass(

		'clickable',

		function(elm, options) {
			this.init(elm, options);
		},

		{
			delegate: function() {
				this
					.handle('click', '.js-clickable', 'handleClick')
					.handle('mouseup', '.js-clickable', 'handleMouseUp');
			}
		},

		{
			defaultOptions: {
				morePath: 'descendant::.js-clickable-more',
				event: false,
				middleClickEvent: false
			},

			scanDom: function() {
				var $elm  = this.$elm,
				    $p    = $elm.find('.js-clickable-protected'),
				    $more = O2util.queryPath($elm, this.options.morePath);

				// Exclude those in protected areas: // TODO: why?
				$more = $more.filter(function() {
					return !($p.has(this).length);
				});

				if ($more.length != 1) {
					// Either the element to propagate the click to was not found,
					// or there are more elements.
					this.reportError(
						'console',
						"Wrong `.js-clickable-more` element count: " + $more.length + "."
					);
					return;
				}

				this.$more = $more;
				this.more = $more[0];
			},

			render: function() {
				$('.js-clickable-redundant').hide();
			},

			handleMouseUp: function(evt) {

				var target = evt && evt.target,
					$protected = this.$elm.find(
						'a[href],input[type="checkbox"],input[type="radio"],.js-clickable-protected'
					),
					event = this.options.middleClickEvent,
					$more = this.$more,
					clickCaptured = $more.data('click-captured'), // TODO: není v dokumentaci
					which = (evt.which || 1);

				var selection = window.getSelection();
				if (selection.type == "Range") {
					var $selectionParent = $(selection.focusNode.parentElement);
					if ($selectionParent.closest('.js-clickable').length > 0) {
						// Je vybraný text a výběr končí na lilbovolném js-clickable.
						return;
					}
				}

				if (which != 2) {
					// Handle middle click only.
					return;
				}

				if ($protected.is(target) || $protected.has(target).length || this.$more.is(target)) {
					// Clicked a protected area - this should be ignored.
					return;
				}

				if (event) {
					$(this.more).trigger(event);
				} else if (clickCaptured) {
					this.more.click();
				} else {
					var origTarget = $more.attr('target');
					$more.attr('target', '_blank');
					this.more.click();
					$more.attr('target', origTarget);
				}
			},

			handleClick: function(evt) {

				var target = evt && evt.target,
					$protected = this.$elm.find(
						'a[href],input[type="checkbox"],input[type="radio"],.js-clickable-protected'
					),
					event = this.options.event,
					which = (evt.which || 1);

				var selection = window.getSelection();
				if (selection.type == "Range") {
					var $selectionParent = $(selection.focusNode.parentElement);
					if ($selectionParent.closest('.js-clickable').length > 0) {
						// Je vybraný text a výběr končí na lilbovolném js-clickable.
						return;
					}
				}

				if (which > 1) {
					// Right or middle click must not be handled here.
					return;
				}

				if ($protected.is(target) || $protected.has(target).length || this.$more.is(target)) {
					// Clicked a protected area - this should be ignored.
					return;
				}

				if (event) {
					$(this.more).trigger(event);
				} else {
					this.more.click();
				}
			}
		}
	);
})(jQuery);
(function($) {
	O2widget.createClass(

		'toggle',

		function(elm, options) {
			if (typeof options == 'undefined');
				options = {};

			if ($(elm).hasClass('o2-section--collapsible'))
				options.profile = 'section';
			else if ($(elm).hasClass('o2-pane--collapsible'))
				options.profile = 'pane';

			this.init(elm, options, [
				'open',
				'target',
				'parent',
				'icon',
				'indicator',
				'textTarget',
				'activeClass',
				'disableScroll',
				'parentActiveClass',
				'iconActiveClass',
				'iconInactiveClass',
				'openText',
				'closedText',
				'tabletPlus',
				'url',
				'set',
				'singleActive',
				'openOnly',
				'classDriven',
				'trigger',
				'media'
			]);
		},

		{
			delegate: function() {
				this
					.handle('click', '.js-toggle', 'handleClick')
					.handleRelated('click', '.js-toggle-trigger', 'handleClick')
					.handleRelated('hashfor.js-toggle', '.js-toggle-target', 'handleHash');

				$(window).on('load.js-toggle hashchange.js-toggle', function(){
					hash = location.hash;
					if (!hash || !O2util.isValidSelector(hash))
						return;

					$elm = $(hash);
					if (!$elm || !$elm.length)
						return;

					$elm.trigger('hashfor.js-toggle');
				});
			}
		},

		{
			defaultOptions: {
				target: undefined,
				icon: undefined,
				speed: 250,
				singleActive: true,
				notifyMethod: 'post',
				notifyOpen: undefined,
				notifyClosed: undefined,
				loadOnce: true,
				parent: '.js-toggle-parent',
				openText: undefined,
				closedText: undefined,
				disableScroll: false,
				activeClass: undefined,
				iconActiveClass: undefined,
				iconInactiveClass: undefined,
				scroll: false,
				trigger: undefined,
				dummy: undefined,
				classDriven: false,
				hidden: undefined,
				openOnly: false,
				history: false,
				tabletPlus: false,
				addons: undefined
			},

			profileOptions: {
				accordion: {
					history: true,
					parent: '.o2-accordion',
					parentActiveClass: 'o2-accordion--active',
					activeClass: 'o2-accordion__header--active'
				},
				triangle: {
					icon: '.o2-icon--rounded-triangle-right-fill,.o2-icon--rounded-triangle-down-fill',
					iconActiveClass: 'o2-icon--rounded-triangle-down-fill',
					iconInactiveClass: 'o2-icon--rounded-triangle-right-fill',
					tabletPlus: true
				},
				trianglesm: {
					icon: '.o2-icon--rounded-triangle-right-fill,.o2-icon--rounded-triangle-down-fill',
					iconActiveClass: 'o2-icon--rounded-triangle-down-fill',
					iconInactiveClass: 'o2-icon--rounded-triangle-right-fill',
					tabletPlus: false
				},
				tab: {
					activeClass: 'o2-tabs__item--active',
					history: false,
					speed: 0,
					openOnly: true,
					scroll: false,
					hidden: 'closest-next::.js-toggle-hidden',
				},
				groupview: {
					openText: 'Skrýt',
					closedText: 'Více',
					history: false,
					target: 'closest-next::.o2-groupview__content',
					tabletPlus: true,
					parentActiveClass: 'o2-groupview--active'
				},
				chevron: {
					icon: '.o2-icon--chevron-up,.o2-icon--chevron-down',
					iconActiveClass: 'o2-icon--chevron-up',
					iconInactiveClass: 'o2-icon--chevron-down',
					textTarget: 'descendant::.o2-btn__text'
				},
				retention: {
					history: false,
					scroll: false,
					activeClass: 'o2-popover__heading--active'
				},
				retentionExpand: {
					history: false,
					scroll: false,
					classDriven: true,
					parent: '.o2-popover',
					parentActiveClass: 'o2-popover--docked-expand'
				},
				hamburger: {
					trigger: "#o2-header-menu-close",
					media: ['xs', 'sm'],
					disableScroll: true
				},
				tree: {
					history: false,
					parent: '.o2-tree__item',
					parentActiveClass: 'o2-tree__item--active',
					target: 'closest-next::.o2-tree__content'
				},
				section: {
					history: true,
					trigger: 'descendant::.o2-section__heading',
					activeClass: 'o2-section--active',
					speed: 0,
					classDriven: true,
					target: 'self::*'
				},
				pane: {
					history: true,
					trigger: 'descendant::.o2-pane__heading',
					activeClass: 'o2-pane--active',
					speed: 0,
					classDriven: true,
					target: 'self::*'
				}
			},

			loaded: false,

			scanDom: function() {
				var $elm       = this.$elm,
				    target     = (this.target || $elm.attr('href') || ''),
				    parent     = this.parent,
				    textTarget = this.textTarget,
				    indicator  = this.indicator,
				    $target    = this.$target = (target.replace('#', '') ? O2util.queryPath($elm, target) : $elm.next()),
				    hidden     = this.options.hidden,
				    $addons    = this.$addons = this.options.addons ? O2util.queryPath($elm, this.options.addons) : $();

				$elm.data('click-captured', true);

				this.$parent = $elm.closest(parent);
				if (!this.$parent.length)
					this.$parent = $elm;

				if (this.options.dummy) // Deprecated fallback
					this.classDriven = this.options.dummy;

				this.$textTarget = (textTarget ? O2util.queryPath($elm, textTarget) : $elm);
				this.$icon       = (this.icon ? this.$parent.find(this.icon) : $());
				this.$indicator  = (indicator ? O2util.queryPath($elm, indicator) : $target);
				this.anchor      = $target.attr('id');

				if (hidden) {
					this.$hidden = O2util.queryPath($elm, hidden);
				}

				this.markRelatedElements($target, 'js-toggle-target');
				if (this.trigger) {
					this.markRelatedElements(O2util.queryPath($elm, this.trigger), 'js-toggle-trigger');
				}

				this.prepareSet();
			},

			render: function() {
				switch (true) {
				case this.tabletPlus && !O2util.isTabletPlus() && !!this.open:
					// do nothing
					break;
				case !!this.open:
					this.renderOpen(0);
					break;
				default:
					this.renderClosed(0);
					break;
				}
			},

			unrender: function() {
				this.$target.attr('style', '');

				if (this.disableScroll) {
					O2util.enableScroll();
				}
			},

			renderOpen: function(speed, evt, trigger) {

				var $target = this.$target;

				if (this.$addons.length)
					$target = $target.add(this.$addons);

				this.$elm.addClass(this.activeClass);
				this.$parent.addClass(this.parentActiveClass);
				this.$icon.addClass(this.iconActiveClass).removeClass(this.iconInactiveClass);

				if (this.$hidden && this.$hidden.length) {
					this.$hidden.val(this.anchor);
				}

				if (!this.classDriven) {
					if (speed) {
						$target.slideDown(speed, function() {
							$target.trigger('shown.o2util');
						});
					} else {
						$target
							.show()
							.trigger('shown.o2util');
					}
				}

				if (this.disableScroll) {
					O2util.disableScroll();
				}

				if (this.openText) {
					this.$textTarget.text(this.openText);
				}

				if (this.singleActive && this.set) {
					this.othersInSet(this.close, true, speed, this.$addons);
				}

				if (this.url && !this.loaded) {
					var me = this,
					    overwrite = {
							target: $target,
							indicator: this.$indicator // Pokud není zadaný, bere se jako indicator $target.
						};

					O2ajax.asyncUpdate(this, evt, trigger, overwrite, function() {
						if (me.options.loadOnce)
							me.loaded = true;
					});
				}
			},

			// Callback pro sadu, který zavírá elementy, když se jiný v sadě otevře.
			close: function(speed) {
				if (this.open) {
					this.open = false;
					this.renderClosed(speed);
				}

				return true;
			},

			// Callback pro sadu, který vrací otevřené addony, aby tyto nebyly uzavřeny jinou instancí v sadě.
			getActiveAddons: function() {
				// This bude pravděpodobně odkazovat na instanci v sadě, nikoliv na instanci odkud byla funkce vyvolána.
				if (this.open && this.$addons.length)
					return this.$addons;
				else
					return false;
			},

			renderClosed: function(speed) {
				var $target = this.$target;
				var $addons = this.$addons;

				if ($addons.length) {
					if (this.set) {
						var $activeAddons = this.othersInSet(this.getActiveAddons, true);

						if ($activeAddons.length) { // Vynechá stejné addony zobrazené jinou instancí v sadě, jinak by se zase zavřely.
							var $exceptAddons = $activeAddons.reduce(function(prev, curr) { // Zredukuje pole všech otevřených addonů ze všech instancí na jeden jQ objekt.
								if (curr.length)
									return prev.add(curr);
								else
									return prev;
							}, $());
							$addons = $addons.not($exceptAddons); // Otevřené addony z jiných instancí odstraní ze sady addonů k uzavření.
						}
					}
					$target = $target.add($addons);
				}

				this.$elm.removeClass(this.activeClass);
				this.$parent.removeClass(this.parentActiveClass);
				this.$icon.addClass(this.iconInactiveClass).removeClass(this.iconActiveClass);
				if (!this.classDriven) {
					if (speed) {
						$target.slideUp(speed, function() {
							$target.trigger('hidden.o2util');
						});
					} else {
						$target
							.hide()
							.trigger('hidden.o2util');
					}
				}

				if (this.disableScroll) {
					O2util.enableScroll();
				}

				if (this.closedText) {
					this.$textTarget.text(this.closedText);
				}
			},

			updateHistory: function() {
				var anchor = this.anchor;
				if (anchor && window.history && history.pushState) {
					var title = this.$elm.attr('title');
					if (title) {
						title = document.title + ' (' + title + ')';
					} else {
						title = document.title;
					}
					history.pushState({}, title, '#' + anchor);
				}
			},

			handleHash: function() {
				if (!this.open) {
					this.handleClick();
				}
			},

			handleClick: function(evt, trigger) {

				if (this.tabletPlus && !O2util.isTabletPlus()) {
					return;
				}

				var $target = this.$target,
				    $elm = this.$elm;

				if ($target.length != 1 && !this.classDriven) {
					this.reportError(
						'console',
						"Wrong target element count: " + $target.length + "."
					);
					return;
				}

				if (evt) {
					var $origTrigger = $(evt.target);
					if ($origTrigger.hasClass('js-toggle-protected') || $origTrigger.closest('.js-toggle-protected').length > 0)
						return;
				}

				if (evt) {
					evt.preventDefault();
					evt.stopImmediatePropagation();
				}

				// Invert the status:
				var open = this.open = !this.open; // sic!

				if (open) {
					if (this.options.history) {
						this.updateHistory();
					}
					this.renderOpen(this.options.speed, evt, trigger);
					switch (this.options.scroll) { // @TODO: při refaktoru toto omezit pouze na target, proč bych kua chtěl scrollovat na něco jiného?
					case 'target':
						O2util.scrollTo($target);
					case 'control':
						O2util.scrollTo($elm);
					case true:
						O2util.scrollTo($elm.add($target));
					}
					this.notify(open);
				} else {
					if (this.openOnly) {
						this.open = true;
					} else {
						this.renderClosed(this.options.speed);
						this.notify(open);
					}
				}
			},

			notify: function(state) {

				var options = this.options,
					method = options.notifyMethod.toLowerCase(),
					url = (state ? options.notifyOpen : options.notifyClosed);

				if (url && method) {
					$[method](url);
				}
			}
		}
	);
})(jQuery);
(function($) {
	O2widget.createClass(

		'hover',

		function(elm, options) {
			this.init(elm, options, [
				'target'
			]);
		},

		{
			delegate: function() {}
		},

		{
			defaultOptions: {
				target: "descendant::.js-hover-target",
				activeClass: undefined,
				inactiveClass: undefined,
				visibilityOnly: false
			},

			profileOptions: {},

			scanDom: function() {
				var $elm       = this.$elm,
				    $target    = this.$target = O2util.queryPath($elm, this.target);

				this.markRelatedElements($target, "js-hover-target");
				$elm.on("mouseenter mouseleave", this.handleHover.bind(this)); // Vytvoří na elementu hover event.
			},

			render: function() {
				this.renderClosed();
			},

			unrender: function() {
				this.$target.removeClass(this.activeClass + " " + this.inactiveClass); // Odstraní přidané classy.
				this.$target // Skryté elementy odkryje.
					.filter(":hidden")
					.show()
					.trigger("shown.o2util");
			},

			renderOpen: function() {
				var $target = this.$target;

				if (this.options.activeClass && this.options.inactiveClass)
					$target
						.removeClass(this.inactiveClass)
						.addClass(this.activeClass);
						//.trigger("shown.o2util"); // @TODO: Vyřešit zbytečné probublávání eventů do všech ostatních widgetů.
				else if (this.options.visibilityOnly)
					$target
						.css("visibility", "visible");
						//.trigger("shown.o2util");
				else
					$target
						.show();
						//.trigger("shown.o2util");
			},

			renderClosed: function() {
				var $target = this.$target;

				if (this.options.activeClass && this.options.inactiveClass)
					$target
						.removeClass(this.activeClass)
						.addClass(this.inactiveClass);
						//.trigger("hidden.o2util");
				else if (this.options.visibilityOnly)
					$target
						.css("visibility", "hidden");
						//.trigger("shown.o2util");
				else
					$target
						.hide();
						//.trigger("hidden.o2util");
			},

			handleHover: function(evt, trigger) {
				if (evt) {
					var $origTrigger = $(evt.target);
					if ($origTrigger.hasClass("js-hover-protected") || $origTrigger.closest(".js-hover-protected").length > 0)
						return;

					if (evt.type == "mouseenter")
						this.renderOpen();
					else if (evt.type == "mouseleave")
						this.renderClosed();
				}
			}
		}
	);
})(jQuery);
(function($) {
	O2widget.createClass(

		'remove',

		function(elm, options) {
			this.init(elm, options);
		},

		{
			delegate: function() {
				this.handle('click', '.js-remove', 'handleClick');
			}
		},

		{
			defaultOptions: {
				speed: 0,
				inner: false,
				trigger: true,
			},

			profileOptions: {
				advsearch: {
					target: 'closest::.js-remove-2',
					prevCheck: 'closest-prev::.js-remove-2',
					prevSep: 'closest-prev::.js-remove-1',
					nextCheck: 'closest-next::.js-remove-2',
					nextSep: 'closest-next::.js-remove-1',
					trigger: false
				},
				sysmessage: {
					target: 'closest::.js-message-container',
					prevCheck: false,
					nextCheck: false,
					trigger: false
				}
			},

			render: function() {

				$('.js-remove-redundant').hide();
			},

			start: function(triggerElm) {

				var $elm = this.$elm,
					options = this.options,
					speed = options.speed,
					target = options.target || $elm.attr('href'),
					$target = (target ? O2util.queryPath($elm, target) : $()),
					trigger = options.trigger,
					inner = options.inner,
					prevCheck = options.prevCheck,
					hasNotPrev = false,
					nextCheck = options.nextCheck,
					hasNotNext = false,
					$toBeRemoved = (inner ? $target.children() : $target);

				if (prevCheck) {
					var $prevCheck = O2util.queryPath($elm, prevCheck);
					hasNotPrev = ($prevCheck && !$prevCheck.length);
				}

				if (nextCheck) {
					var $nextCheck = O2util.queryPath($elm, nextCheck);
					hasNotNext =($nextCheck && !$nextCheck.length);
				}

				switch (true) {
				case hasNotNext && !hasNotPrev:
					if (options.prevSep) {
						$toBeRemoved = $toBeRemoved.add(O2util.queryPath($elm, options.prevSep));
					}
				case hasNotPrev && !hasNotNext:
					if (options.nextSep) {
						$toBeRemoved = $toBeRemoved.add(O2util.queryPath($elm, options.nextSep));
					}
				case !hasNotNext && !hasNotPrev:
					var $r = false;
					if (options.prevSep) {
						$r = O2util.queryPath($elm, options.prevSep);
					}
					if ((!$r || !$r.length) && options.nextSep) {
						$r = O2util.queryPath($elm, options.nextSep);
					}
					if ($r && $r.length) {
						$toBeRemoved = $toBeRemoved.add($r);
					}
				}

				if (trigger) {
					$toBeRemoved = $toBeRemoved.add(triggerElm);
				}

				this.$toBeRemoved = $toBeRemoved;

				if (speed) {
					$target.slideUp(speed, $.proxy(this.resume, this));
				} else {
					this.resume();
				}
			},

			resume: function() {

				var $toBeRemoved = this.$toBeRemoved;

				if ($toBeRemoved && $toBeRemoved.length) {
					$toBeRemoved.trigger('contentgone.o2util');
					$toBeRemoved.remove();
					this.notify();
				}
			},

			handleClick: function(evt, triggerElm) {

				this.start(triggerElm);
				evt.preventDefault();
			},

			notify: function() {

				var options = this.options,
					method = options.notifyMethod ? options.notifyMethod.toLowerCase() : 'get',
					url = options.notify;

				if (url && method) {
					$[method](url); // $.post OR $.get
				}
			}
		}
	);
})(jQuery);
(function($) {
	O2widget.createClass(

		'toggleval',

		function(elm, options) {
			this.init(elm, options, [
				'parent',
				'speed',
				'map'
			]);
		},

		{
			delegate: function() {
				this
					.handle('change', 'select.js-toggleval,input.js-toggleval,textarea.js-toggleval', 'handleChange')
					.handleRelated('change', 'input.js-toggleval-control,input.js-toggleval-related', 'handleChange');
			}
		},

		{
			profileOptions: {
				validate: {
					parent: 'input',
					map: function(userValue) {
						var validate = '';
						this.$related.each(function() {
							var relatedVal   = $(this).val(),
							    relatedState = $(this).data('togglevalState') || false;

							if (relatedState == 'error') { // Zadán state, na value tedy nezáleží.
								validate = 'error';
								return false; // Při chybě zastaví zpracování dalších .each().
							} else if (userValue && !relatedVal) { // Vyplněno je toggleval, ale ne related, takže invalid.
								validate = 'invalid';
								return false;
							} else if (userValue && relatedVal) { // Vyplněno je toggleval i related, takže OK.
								validate = '';
							}
						});
						return validate;
					},
					cfg: [{
						val: 'invalid',
						show: 'closest-next::.js-toggleval-complement',
						activeClass: 'o2-control__validation--warning'
					}, {
						val: 'error',
						show: 'closest-next::.js-toggleval-fallback',
						activeClass: 'o2-control__validation--warning'
					}, {
						val: ''
					}]
				},
				dph: {
					watchContent: true,
					watchContentPath: 'closest::.o2-section'
				}
			},

			scanDom: function() {

				var $elm = this.$elm,
					parent = this.parent,
					related = this.options.related,
					$opts,
					cfg = this.options.cfg,
					behavior = this.behavior = {"":{$show:$(),$hide:$()}},
					xActive = '', // all active classes
					$xShow = $(), // all elements declared explicitly to be shown by some option
					$xHide = $(); // all elements declared explicitly to be hidden by some option

				this.$parent = (parent ? $elm.closest(parent) : $());

				if (related) {
					var $related = this.$related = O2util.queryPath($elm, related);
					this.markRelatedElements($related, 'js-toggleval-related');
				}

				// Find all related elements with a `value` attribute and
				// data-toggleval-show/hide settings. These should be options of a select
				// element or radios sharing the same name.

				switch (true) {
					case $elm.is('select'):
						$opts = $elm.find('option');
						break;
					case $elm.is('input[type="checkbox"]'):
						$opts = $elm;
						break;
					case $elm.is('input[type="radio"]'):
						$opts = $($elm[0].form).find('input[name="' + $elm.attr('name') + '"]');
						this.$controls = $opts;
						break;
					case $elm.is('input, textarea'):
						$opts = $();
						break;
					default: // Předpokládá, že root element obaluje radiobuttony
						$opts = $elm.find('input[type="radio"]');
						this.$controls = $opts;
				}

				// First pass - find out which elements are shown/hidden by a value
				// explicitly; also collect possible active classes:

				if (cfg && cfg.length) {
					for (var i = 0, c; c = cfg[i++]; ) {
						var $show = (c.show ? O2util.queryPath($elm, c.show) : $()),
							$hide = (c.hide ? O2util.queryPath($elm, c.hide) : $()),
							active = c.activeClass,
							val = c.val;

						$xShow = $xShow.add($show);
						$xHide = $xHide.add($hide);
						if (active) {
							xActive += (xActive ? ' ' : '') + active;
						}

						behavior[val] = {
							$show: $show,
							$hide: $hide,
							parentActiveClass: active
						};
					}
				}

				$opts.each(function() {

					var $option = $(this),
						val = $option.attr('value') || '',
						show = $option.data('toggleval-show'),
						hide = $option.data('toggleval-hide'),
						$show = (show ? O2util.queryPath($elm, show) : $()),
						$hide = (hide ? O2util.queryPath($elm, hide) : $()),
						active = $option.data('toggleval-parent-active-class');

					$xShow = $xShow.add($show);
					$xHide = $xHide.add($hide);
					if (active) {
						xActive += (xActive ? ' ' : '') + active;
					}

					behavior[val] = {
						$show: $show,
						$hide: $hide,
						parentActiveClass: active
					};
				});

				// What is only shown explicitly, should be hidden elsewhere and vice versa.
				// Now let's compute the "only shown - hide elsewhere" and "only hidden -
				// show elsewhere" element sets.

				var $implicitHide = $xShow.not($xHide);
					$implicitShow = $xHide.not($xShow);

				// Update the behavior so that implicit elements are included:

				for (var val in behavior) {
					var b = behavior[val];
					b.$show = b.$show.add($implicitShow.not(b.$hide));
					b.$hide = b.$hide.add($implicitHide.not(b.$show));
					b.parentInactiveClass = xActive; // quick and dirty
				}
			},

			render: function() {
				var v = this.computeValue(),
					b = this.behavior[this.map ? this.map(v) : v],
					$controls = this.$controls;

				if ($controls && $controls.length) {
					this.markRelatedElements($controls, 'js-toggleval-control');
				}

				this.executeBehavior(b, 0);
			},

			executeBehavior: function(b, speed) {

				var $parent = this.$parent,
					active = b.parentActiveClass,
					inactive = b.parentInactiveClass;

				this.renderShown(b.$show, speed);
				this.renderHidden(b.$hide, speed);

				if (inactive) {
					$parent.removeClass(inactive);
				}
				if (active) {
					$parent.addClass(active);
				}
			},

			// Generic interface method to compute the instance value,
			// based on element type.

			computeValue: function() {
				var $elm = this.$elm,
					$controls = this.$controls;

				switch (true) {
					case $controls && $controls.length && true:
						return $controls.filter(':checked').attr('value') || '';
					case $elm.is('input[type="checkbox"]'):
						return ($elm.is(':checked') ? $elm.attr('value') : '');
					default:
						return $elm.val() || '';
				}
			},

			renderShown: function($e, speed) {
				if (speed) {
					$e.slideDown(speed, function() {
						$e.trigger('shown.o2util');
					});
				} else {
					$e
						.show()
						.trigger('shown.o2util');
				}
			},

			renderHidden: function($e, speed) {
				if (speed) {
					$e.slideUp(speed, function() {
						$e.trigger('hidden.o2util');
					});
				} else {
					$e
						.hide()
						.trigger('hidden.o2util');
				}
			},

			handleChange: function(evt) {
				var v = this.computeValue(),
					b = this.behavior[this.map ? this.map(v) : v];
				this.executeBehavior(b, this.speed || 0);
			}
		}
	);
})(jQuery);


(function($) {
	O2widget.createClass(

		'focusedit',

		function(elm, options) {
			this.init(elm, options, [
				'scope',
				'container',
				'show',
				'hide',
				'confirm'
			]);
		},

		{
			delegate: function() {
				this
					.handle('focusin', '.js-focusedit', 'handleFocus')
					.handleRelated('click', '.js-focusedit-confirm', 'handleConfirm');
			}
		},

		{
			defaultOptions: {
				scope:                '.o2-control__wrapper',
				container:            '.o2-control__wrapper',
				containerActiveClass: 'o2-control__wrapper--button-right',
				show:                 'descendant::.js-focusedit-show',
				hide:                 'descendant::.js-focusedit-hide',
				confirm:              'descendant::.js-focusedit-confirm'
			},

			profileOptions: {},

			lastVal: null,
			isOpen: null,

			scanDom: function() {
				var $elm       = this.$elm,
				    $scope     = this.$scope     = $elm.closest(this.scope),
				    $container = this.$container = $elm.closest(this.container);

				if (this.$scope.length != 1)
					console.error('focusedit.js - Scope neodpovídá žádnému elementu.'); // TODO

				this.$show    = O2util.queryPath($scope, this.show);
				this.$hide    = O2util.queryPath($scope, this.hide);
				this.$confirm = O2util.queryPath($scope, this.confirm);
				this.markRelatedElements(this.$confirm, 'js-focusedit-confirm');
			},

			render: function() {
				if (this.$elm.is(':focus'))
					this.renderOpen();
				else {
					this.$show.hide().removeAttr('hidden');
					this.$hide.show();
				}
			},

			unrender: function() {

			},

			renderOpen: function() {
				if (this.isOpen)
					return;

				var $scope        = this.$scope,
					scopePosition = $scope.position();

				this.lastVal = this.$elm.val();
				this.isOpen  = true;

				var $placeholder = $('<div>').css({
					display: 'inline-block',
					width: $scope.outerWidth(),
					height: $scope.outerHeight(),
					verticalAlign: 'top', // TODO: tohle nějak dořešit
					margin: $scope.css('margin')
				});

				this.$placeholder = $placeholder.insertAfter($scope);
				this.$container.addClass(this.options.containerActiveClass);
				scopePosition.left -= parseInt($scope.css('paddingLeft')) + parseInt($scope.css('borderLeftWidth'));
				scopePosition.top  -= parseInt($scope.css('paddingTop')) + parseInt($scope.css('borderTopWidth'));
				$scope.css({
					position: 'absolute',
					left:     scopePosition.left,
					top:      scopePosition.top,
					zIndex:   2
				});
				this.$show.show();
				this.$hide.hide();
				$(document).on('click.' + this.uuid, $.proxy(this.handleDocumentClick, this));
				$(document).on('keydown.' + this.uuid, $.proxy(this.handleDocumentKeydown, this));

				$scope.trigger('shown.o2util');
			},

			renderClosed: function() {
				if (!this.isOpen)
					return;

				this.$show.hide();
				this.$hide.show();
				this.$placeholder.remove();
				this.$placeholder = null;
				this.$scope.css({
					position: '',
					left: '',
					top: '',
					zIndex: ''
				});
				this.$container.removeClass(this.options.containerActiveClass);
				this.isOpen = false;

				this.$scope.trigger('hidden.o2util');
			},

			handleDocumentClick: function(evt) {
				if (!$.contains(this.$scope[0], evt.target)) {
					$(document).off('click.' + this.uuid);
					$(document).off('keydown.' + this.uuid);
					if (this.$elm.val() !== this.lastVal)
						this.$elm.val(this.lastVal);

					this.renderClosed();
				}
			},

			handleDocumentKeydown: function(evt) {
				if (!this.$elm.is(':focus'))
					return;

				if (evt.keyCode == 13) {
					this.$elm.blur();
					this.$confirm.click();
				} else if (evt.keyCode == 27) {
					this.$elm.blur();
					this.handleDocumentClick({target: document.body});
				}
			},

			handleFocus: function(evt) {
				if (!this.isOpen)
					this.renderOpen();
			},

			handleConfirm: function(evt) {
				$(document).off('click.' + this.uuid);
				$(document).off('keydown.' + this.uuid);
				this.renderClosed();
			}
		}
	);
})(jQuery);

// https://goodies.pixabay.com/jquery/auto-complete/demo.html
(function($) {
	var authorizedUrl = [];
	/*{
		originalUrl: "proxy.html?tlp=123456",
		url: "proxy.html",
		tlp: "123456",
		otp: null,
		status: "ready|retrieving|error",
		interval: 5000
	}*/

	O2widget.createClass(

		'autocomplete',

		function(elm, options) {
			this.init(elm, options, [
				'url',
				'data',
				'minlen',
				'dataRootElem',
				'dataContainerName',
				'dataIdName',
				'dataTextName',
				'dataValueName',
				'hidden',
				'queryParam',
			]);
		},

		{
			delegate: function() {
				this.handle('change', '.js-autocomplete', 'handleChange');
			}
		},

		{
			defaultOptions: {
				data:              false,
				minlen:            3,
				delay:             300,
				dataRootElem:      false,
				dataContainerName: false,
				dataIdName:        "id",
				dataTextName:      "text",
				dataValueName:     false,
				validChange:       false,
				timeout:           3000,
				kahlId:            'ID1006',
				cache:             false,
				useTlp:            false,
				tlpInterval:       5*60 // 5 mins
			},

			profileOptions: {
				addressSearch: {
					minlen: 2,
					queryParam: 'mask',
					dataContainerName: 'addresses',
					dataIdName: 'crossId',
					dataTextName: 'description',
					dataValueName: 'description',
					hidden: 'next::input[type="hidden"]',
					skipResetFrom: 'coupled',
					kahlId: 'ID0999',
					cache: false,
					useTlp: true,
					tlpInterval: 5*60
				},
				addressSearchV11: {
					minlen: 2,
					queryParam: 'mask',
					dataRootElem: 'addresses',
					dataContainerName: 'addresses',
					dataIdName: 'crossId',
					dataTextName: 'description',
					dataValueName: 'description',
					hidden: 'next::input[type="hidden"]',
					skipResetFrom: 'coupled',
					kahlId: 'ID0999',
					cache: false,
					useTlp: true,
					tlpInterval: 5*60
				}
			},

			isBroken: false,           // Je to rozbitý.
			isCached: false,           // Zda používáme cache url
			request: null,             // Aktuálně probíhající request

			scanDom: function() {
				this.$hidden = (this.hidden ? O2util.queryPath(this.$elm, this.hidden) : $()); // skrytý input
			},

			bind: function() {
				var $hidden = this.$hidden,
						$elm = this.$elm,
						validationState = '';

				if (!this.data && !this.url) {
					O2util.reportError('console', 'URL or DATA must be provided.', this);
					this.setBroken();
					return;
				}


				if ($elm.val() === '' && $hidden.val() === '')
					validationState = 'empty';
				else if ($elm.val() !== '' && $hidden.val() === '')
					validationState = 'invalid';
				else if ($elm.val() !== '' && $hidden.val() !== '')
					validationState = 'success';

				$hidden.data('validationState', validationState);

				if (this.options.useTlp) {
					for (var i = 0; i < authorizedUrl.length; i++) {
						if (authorizedUrl[i].originalUrl == this.options.url) { // Pokud je url v cache, použije se.
							this.url = authorizedUrl[i];
							this.isCached = true;
							break;
						}
					}
					if (!this.isCached) { // Není v cache, připraví ji a zjistí URL.
						var urlComponents = this.url.split('?', 2),
							urlAddress = urlComponents[0],
							urlQS = urlComponents[1] || false,
							urlQSData = {};

						if (urlQS === false) {
							O2util.reportError('console', 'Query string is missing in autocomplete URL.', this);
							this.setBroken();
							return;
						}

						// Mapování QS do objektu
						urlQS = urlQS.split('&');
						for (var i = 0; i < urlQS.length; i++) {
							var value = urlQS[i].split('=');
							urlQSData[value[0]] = value[1];
						}

						authorizedUrl.unshift({
							originalUrl: this.url,
							url: urlAddress,
							tlp: urlQSData.TLP || urlQSData.tlp,
							otp: null,
							interval: (parseInt(this.options.tlpInterval) * 1000) + 5000,
							timeout: null,
							status: 'ready'
						});
						this.url = authorizedUrl[0];

						if (this.options.tlpInterval > 0) {
							this.url.timeout = setTimeout($.proxy(this.autorenewTlp, this), this.url.interval);
						}
						this.isCached = true;
					}
				}
			},

			processData: function(data, ignoreContainer) {

				var r = [],
					dataTextName  = this.dataTextName,
					dataIdName    = this.dataIdName,
					dataValueName = this.dataValueName,
					hidden        = this.hidden;

				if (this.dataRootElem && !ignoreContainer) {
					data = data[this.dataRootElem];
				}
				if (this.dataContainerName && !ignoreContainer) {
					data = data[this.dataContainerName];
				}
				for (var i = 0, curr; i < data.length; i++) {
					curr = {
						'text':  dataTextName  ? data[i][dataTextName]  : data[i],
						'id':    hidden        ? data[i][dataIdName]    : false,
						'value': dataValueName ? data[i][dataValueName] : false
					};
					r.push(curr);
				}

				return r;
			},

			source: function(term, response){
				if (this.isBroken)
					return false;

				if (this.data) {
					this.sourceStatic(term, response);
				} else if (this.url) {
					this.sourceAjax(term, response);
				}
			},

			sourceStatic: function(term, response) {
				var r = [],
					data = this.data,
					dataTextName = this.dataTextName,
					re = O2util.buildMatcher(term, 'i');

				if (this.dataContainerName) {
					data = data[this.dataContainerName];
				}

				for (var i = 0, x, s; i < data.length; i++) {
					x = data[i];
					s = (dataTextName ? x[dataTextName] : x);
					if (s.match(re)) {
						r.push(x);
					}
				}

				response(this.processData(r, true));
			},

			sourceAjax: function(term, response) {
				if (this.request) {
					this.request.abort();
				}

				if (this.isCached) {
					switch (this.url.status) {
						case 'retrieving':
							return false;
						case 'error':
							this.setBroken();
							return false;
					}
				}

				var params = {},
					me     = this,
					url    = this.url;

				params[this.queryParam] = term;

				if (this.isCached) {
					params['TLP'] = this.url.tlp;
					url = this.url.url;
				}

				this.request = $.ajax({ // Tento request žádá data do našeptávače
					dataType: 'json',
					url: url,
					data: params,
					timeout: this.options.timeout
				})
					.done(function(data, textStatus, jqXHR) {
						me.url.iteration = 0;
						//if (me.$elm.is(':focus')) { //tato podminka nefunguje v phantomjs, asi bude i v jinych widgetech
						if (me.$elm.is($(document.activeElement))) {
							response(me.processData(data));
						}
						if (me.options.useTlp && jqXHR.getResponseHeader('X-1P-Proxy-OTP')) {
							me.url.otp = jqXHR.getResponseHeader('X-1P-Proxy-OTP');
							me.renewTlp();
						}
					})
					.fail(function(jqXHR, textStatus) {
						if (jqXHR.status == 405 && me.options.useTlp && jqXHR.getResponseHeader('X-1P-Proxy-OTP')) { // Neplatné TLP zdroje dat.
							me.url.otp = jqXHR.getResponseHeader('X-1P-Proxy-OTP');
							me.renewTlp(true);
						} else if (textStatus == 'error' || textStatus == 'parsererror') { // Obecná chyba zdroje dat našeptávače.
							me.ajaxError("Theme - autocomplete.js:sourceAjax", jqXHR.status, this.url);
						}
					})
					.always(function() {
						me.request = null;
					});
			},

			renderItem: function(item, search) {

				var hidden = this.hidden,
					re = O2util.buildMatcher(search),
					id = item.id ? ' data-autocomplete-id="' + item.id + '"' : '',
					value = ' data-val="' + (item.value || item.text) + '"',
					html = item.text.replace(/<br>/g, '\n');
					html = html.replace(re, "<b>$1</b>");
					html = html.replace(/\n/g, '<br>');

				return '<div class="autocomplete-suggestion"' + id + value + '>' + html + '</div>';
			},

			onSelect: function(e, term, item) {
				e.preventDefault();
				if (this.hidden) {
					this.$hidden
						.val(item.data('autocomplete-id'))
						.data('validationState', 'success')
						.trigger('change');
					this.$elm.trigger('forceValidation.js-validation');
				}
				this.lastSelectedValue = this.$elm.val();
				this.$elm.trigger('change');
			},

			handleChange: function(evt, trigger, data) {
				var options = this.options,
					skipResetFrom = options && options.skipResetFrom; // widgetName, pokud je definováno, jinak false
				if (this.hidden && this.isBroken == false) {
					if (this.lastSelectedValue != this.$elm.val()) {
						if (!skipResetFrom || !data || skipResetFrom != data.widgetName) {
							// Hidden data se promažou, pokud uživatel přepsal ručně input a
							//  - pokud není definováno skipReset nebo nejsou žádná data
							//  - pokud je reset definován, ale je jiný než předaná data
							this.$hidden
								.val('')
								.data('validationState', this.$elm.val() == '' ? 'empty' : 'invalid');
							this.$elm.trigger('forceValidation.js-validation');
						}
					}

					if (options.validChange) { // odpálí change pouze pokud byla vybrána validní hodnota našeptávače
						if (this.$hidden.val() !== '')
							this.$hidden.trigger('change');
						evt.stopPropagation();
					} else {
						this.$hidden.trigger('change');
					}
				}
			},

			render: function() {
				var me = this;
				me.$elm.autoComplete({
					minChars: me.minlen,
					delay: me.options.delay,
					source: function(term, response){
						term = term.trim();
						me.source(term, response);
				    },
				    renderItem: function(item, search) {
				    	return me.renderItem(item, search);
				    },
				    onSelect: function(e, term, item) {
				    	me.onSelect(e, term, item);
					},
					cache: me.options.cache
			    });
			},

			unrender: function() {
				this.$elm.autoComplete("destroy");
			},

			autorenewTlp: function() {
				var me = this;
				this.url.status = 'retrieving';
				clearTimeout(this.url.timeout);

				$.ajax({ // Tento request žádá o OTP
					dataType: 'json',
					method:   'get',
					data: {
						'TLP': this.url.tlp,
						'mask': 'dummy'
					},
					url:      this.url.url,
					timeout:  this.options.timeout
				})
					.done(function(data, textStatus, jqXHR) {
						if (jqXHR.getResponseHeader('X-1P-Proxy-OTP')) {
							me.url.otp = jqXHR.getResponseHeader('X-1P-Proxy-OTP');
							me.renewTlp();
						} else { // Nepřišlo OTP
							me.url.status = 'error';
							me.ajaxError("Theme - autocomplete.js:autorenewTlp:fail", jqXHR.status, this.url);
						}
					})
					.fail(function(jqXHR, textStatus) {
						if (jqXHR.status == 405 && jqXHR.getResponseHeader('X-1P-Proxy-OTP')) {
							me.url.otp = jqXHR.getResponseHeader('X-1P-Proxy-OTP');
							me.renewTlp();
						} else { // Neznámá chyba
							me.url.status = 'error';
							me.ajaxError("Theme - autocomplete.js:autorenewTlp:fail", jqXHR.status, this.url);
						}
					});
			},

			renewTlp: function(refresh) {
				var me = this;
				this.url.status = 'retrieving';
				clearTimeout(this.url.timeout);
				this.url.iteration = this.url.iteration || 0;

				$.ajax({ // Tento request žádá o novou dataURL
					dataType: 'json',
					method:   'get',
					data: {
						'TLP': this.url.tlp,
						'OTP': this.url.otp,
						'mask': 'dummy'
					},
					url:      this.url.url,
					timeout:  this.options.timeout
				})
					.done(function(data, textStatus, jqXHR) {
						if (jqXHR.getResponseHeader('X-1P-Proxy-TLP') && me.url.iteration < 2) {
							me.url.iteration += 1;
							me.url.tlp = jqXHR.getResponseHeader('X-1P-Proxy-TLP');
							me.url.otp = null;
							me.url.timeout = setTimeout($.proxy(me.autorenewTlp, me), me.url.interval);
							me.url.status = 'ready';
							if (refresh)
								me.refresh();
						} else { // Nepřišlo očekávané TLP nebo hrozí zacyklení
							me.url.status = 'error';
							me.ajaxError("Theme - autocomplete.js:renewTlp:done", jqXHR.status, this.url);
						}
					})
					.fail(function(jqXHR, textStatus) {
						me.url.status = 'error';
						me.ajaxError("Theme - autocomplete.js:renewTlp:fail", jqXHR.status, this.url);
					});
			},

			logAjaxError: function(status, ajaxUrl) {
				$.ajax({ // Tento request loguje error URL našeptávače do renew URL. Nečeká žádnou odpověď.
					dataType: 'json',
					method: "post",
					url: this.options.logUrl,
					timeout: this.options.timeout,
					data: {
						httpStatus: status,
						proxyUrl: ajaxUrl
					}
				});
			},

			ajaxError: function(sourceid, httpStatus, ajaxUrl) {
				if (this.options.logUrl)
					this.logAjaxError(httpStatus, ajaxUrl);

				if (O2config.getInformationMessagesURL) {
					window.O2widget.classes.sysmsg.kahl(O2config.getInformationMessagesURL, {
						msgid: this.options.kahlId,
						timestamp: Date.now(),
						sourceid: sourceid,
						exceptParams: ""
					});
				} else {
					window.O2widget.classes.sysmsg.showMessage(
						{
							"text": "Našeptávač není momentálně k dispozici. Zkuste to prosím za chvíli.",
							"textInternal": "",
							"severity": "danger",
							"isInternal": false,
							"closeBtn": true,
							"autoClose": 10000,
							"messageId": "dsAutocomplete"
						}
					);
				}

				this.setBroken();
			},

			setBroken: function() {
				this.$elm.addClass('o2-control__validation--warning');
				this.$hidden
					.data('togglevalState', 'error')
					.data('validationState', 'error')
					.trigger('change'); // Kvůli js-toggleval a js-validation.
				this.$elm.trigger('forceValidation.js-validation');
				this.isBroken = true;
			},

			refresh: function() {
				this.$elm.trigger('refresh.autocomplete');
			}
		}
	);
})(jQuery);


(function($) {
	O2widget.createClass(

		'more',

		function(elm, options) {
			this.init(elm, options);
		},

		{
			// no static methods
		},

		{
			defaultOptions: {
				moreText: 'Zobrazit více',
				lessText: 'Zobrazit méně'
			},

			bind: function() {
				this.$elm.more(this.options);
			}
		}
	);
})(jQuery);


(function($) {

	O2widget.createClass(

		'modal',

		function(elm, options) {
			this.init(elm, options, [
				'media',
				'target',
				'showCloseBtn',
				'bgClick',
				'controls'
			]);
		},

		{
			delegate: function() {

				var c = this;

				var handleOpen = function(evt, args) {
					var instance = c.getInstance(this);
					if (instance && !instance.disabled && !instance.confirmedBy) {
						instance.openModal(evt, args);
						evt.stopImmediatePropagation();
					}
					if (instance && instance.confirmedBy) {
						instance.confirmedBy = false;
					}
				};

				var handleConfirm = function(evt) {
					var $content = $(this).closest('.js-modal-content');
					if ($content.length) {
						var i = $content.data('modal-opener');
						if (i && !i.disabled) {
							i.$elm.data("modalConfirmState", true);
							i.confirmSourceEvent(evt);
						}
					}
					$.magnificPopup.close();
				};

				var handleSave = function(evt) {
					var $content = $(this).closest('.js-modal-content');
					evt.preventDefault();
					if ($content.length) {
						var i = $content.data('modal-opener');
						if (i && !i.disabled && i.$contents) {
							var pushValue = $(this).data('modal-push-value');
							i.pushBinding(i.$contents, pushValue);
						}
					}
					$.magnificPopup.close();
				};

				$(document)
					.on('click', 'a.js-modal,button.js-modal', handleOpen)
					.on('submit', 'form.js-modal', handleOpen)
					.on('change', 'select.js-modal', handleOpen)
					.on('click', '.js-modal-confirm', handleConfirm)
					.on('click', '.js-modal-save', handleSave)
					.on('click', '.js-modal-close', function(evt) {
						evt.preventDefault();
						$.magnificPopup.close();
					})
					.on('click', '.js-modal-continue', function(evt) {
						setTimeout(function(){
							$.magnificPopup.close();
						}, 10); // Protože nechceme zničit elementy v DOM dřív, než se odešle ajaxový request pomocí js-update.
					});
			}
		},

		{
			defaultOptions: {
				media: false,
				open: false,
				showCloseBtn: true,
				mainClass: 'o2-modal-wrapper',
				bgClick: false,
				enableEscapeKey: true,
				closeMarkup: '<div class="o2-modal__close"><button type="button" class="o2-btn o2-btn--transparent o2-btn--icon js-modal-close"><span class="o2-icon o2-icon--cross"></span></button></div>',
				closeUrl: false,
				closeMethod: 'GET',
				removalDelay: 0
			},

			profileOptions: {
				legacy: {
					media: ['md', 'lg', 'xl', 'hg'],
					showCloseBtn: true,
					bgClick: true,
					closeMarkup: false
				},
				map: {
					media: false,
					showCloseBtn: false,
					mainClass: 'o2-modal-wrapper o2-modal-wrapper--map',
					bgClick: false
				},
				sticky: {
					mainClass: 'o2-modal-wrapper o2-modal-wrapper--sticky',
					removalDelay: 300
				},
				dialog: {
					showCloseBtn: false
				}
			},

			scanDom: function() {
				var $elm = this.$elm,
					target = this.options.target;

				$elm.data('click-captured', true);

				if (typeof $elm.data("modalFragmentState") === "object") {
					this.$target = false;
					this.isFragment = true;
				} else {
					// V tomto pořadí:
					// Zadaný selektor, jinak
					// form action začínající na #, jinak
					// href začínající na #
					// jinak false (bere se jako ajax)
					this.$target = (target ? O2util.queryPath($elm, target) : O2util.localTarget($elm));
					this.isFragment = false;
				}
			},

			render: function() {

				var $target = this.$target,
				    $elm    = this.$elm;

				if ($target && $target.length) {
					this.originalTargetClass = $target[0].className;
					$target.addClass('mfp-hide');
					this.markRelatedElements($target, 'js-modal-content');
				}

				if (this.options.open)
					this.openModal();
				else if (this.isFragment)
					this.openModalFragment();
			},

			unrender: function() {
				var origClass = this.originalTargetClass,
					$target = this.$target;
				if ('undefined' != typeof origClass && $target && $target.length) {
					$target.className = origClass;
				}
			},

			configure: function(baseConfig) {

				var config = $.extend({}, baseConfig, {
					showCloseBtn: this.showCloseBtn,
					closeOnBgClick: this.bgClick,
					mainClass: this.options.mainClass,
					fixedContentPos: true,
					fixedBgPos: true,
					enableEscapeKey: this.options.enableEscapeKey,
					removalDelay: this.options.removalDelay
				});

				if (this.options.closeMarkup) // Pokud je false, ponechá se default z magnificu.
					config.closeMarkup = this.options.closeMarkup;

				var closeUrl = this.options.closeUrl,
					closeMethod = this.options.closeMethod;

				if (closeUrl) {
					config.callbacks = { close: function() {
						$.ajax({
							url: closeUrl,
							method: closeMethod
						});
					} };
				}

				return config;
			},

			openModal: function(evt, args) {

				if (evt) {
					evt.preventDefault();
				}

				// Zabrání otevření dalšího modálu, pokud se o to snaží autorun.
				if (args && args.isAutorun && $.magnificPopup.instance.isOpen)
					return;

				if (this.$target)
					this.openModalStatic();
				else
					this.openModalAjax(evt);
			},

			openModalStatic: function() {
				var $target = this.$target;

				// Fallback pro již existující sticky modály: (@TODO: zajistit refaktoring obrazovek a odstranit tento fallback)
				if($target.hasClass("o2-modal--sticky") && this.profile !== "sticky") {
					this.profile = "sticky";
					$.extend(this.options, this.profileOptions.sticky);
				}

				var popupCfg = this.configure({ items: { src: '#' + $target.attr('id'), type: 'inline' } });

				$.magnificPopup.open(popupCfg);
				this.pullBinding($target);

				$target.trigger('shown.o2util');
				$target.data('modal-opener', this);
				this.$contents = $target;
			},

			openModalAjax: function(evt) {
				var me = this,
					$elm = this.$elm,
					$target = $('<div style="display:none;"></div>').appendTo('body'),
					overwrite = {
						target: $target,
						append: true,
						replace: false
					};

				// Pro modál vytvoříme dočasný target, který po zavření modálu odstraníme
				O2ajax.asyncUpdate(this, evt, $elm, overwrite, function(isError) {
					if (isError)
						return;
					$target = $target.children();

					// Fallback pro již existující sticky modály: (@TODO: zajistit refaktoring obrazovek a odstranit tento fallback)
					if($target.hasClass("o2-modal--sticky") && me.profile !== "sticky") {
						me.profile = "sticky";
						$.extend(me.options, me.profileOptions.sticky);
					}

					var popupCfg = me.configure({
						items: { src: $target, type: 'inline' },
						callbacks: {
							afterClose: function() {
								$target = $target.parent();
								$target.trigger("contentgone.o2util");
								$target.remove();
								$target = null;
							}
						}
					});

					$.magnificPopup.open(popupCfg);
					me.pullBinding($target);

					$target.trigger('shown.o2util');
					me.markRelatedElements($target, 'js-modal-content');
					$target.data('modal-opener', me);
					me.$contents = $target;
				});
			},

			openModalFragment: function() {
				var modalFragment = this.$elm.data("modalFragmentState");
				var $target = modalFragment.$content;

				// Fallback pro již existující sticky modály: (@TODO: zajistit refaktoring obrazovek a odstranit tento fallback)
				if($target.hasClass("o2-modal--sticky") && this.profile !== "sticky") {
					this.profile = "sticky";
					$.extend(this.options, this.profileOptions.sticky);
				}

				var popupCfg = this.configure({
					items: { src: $target, type: 'inline' },
					callbacks: {
						afterClose: function() {
							modalFragment.$container.trigger("contentgone.o2util");
							modalFragment.$container.remove();
							modalFragment.$container = null;
						}
					}
				});

				$.magnificPopup.open(popupCfg);
				this.pullBinding($target);

				$target.trigger('shown.o2util');
				$target.data('modal-opener', this);
				this.$contents = $target;
			},

			pullBinding: function($modal) {

				var binding = this.controls && this.controls.binding,
					$elm = this.$elm;

				if (!binding) {
					return;
				}

				for (var dlgElm in binding) {
					var pageElm = binding[dlgElm],
						$dlgElm = O2util.queryPath($elm, dlgElm),
						$pageElm = O2util.queryPath($modal, pageElm),
						pageVal;

					if ($pageElm.is('input, select, textarea, button'))
						pageVal = $pageElm.val();
					else
						pageVal = $pageElm.html();

					if ($dlgElm.is('input, select, textarea, button')) {
						$dlgElm.val(pageVal);
						$dlgElm.trigger('change');
					} else {
						$dlgElm.html(pageVal);
					}
				}
			},

			pushBinding: function($modal, pushValue) {

				var binding = this.controls && this.controls.binding,
					push = this.controls && this.controls.push,
					$elm = this.$elm;

				if (binding) {
					for (var dlgElm in binding) {
						var pageElm = binding[dlgElm],
							$dlgElm = O2util.queryPath($elm, dlgElm),
							$pageElm = O2util.queryPath($modal, pageElm),
							dialogVal;

						if ($dlgElm.is('input, select, textarea, button'))
							dialogVal = $dlgElm.val();
						else
							dialogVal = $dlgElm.html();

						if ($pageElm.is('input, select, textarea, button')) {
							$pageElm.val(dialogVal);
							$pageElm.trigger('change');
						} else {
							$pageElm.html(dialogVal);
						}
					}
				}

				if (push) {
					var $push = O2util.queryPath(this.$elm, push);

					if ($push.is('input,select,textarea')) {
						$push.val(pushValue);
						$push.trigger('change');
					} else {
						$push.html(pushValue);
					}
				}
			},

			confirmSourceEvent: function(evt) {

				var $elm = this.$elm,
					elm = $elm[0];

				evt.preventDefault();

				this.confirmedBy = true;

				if ($elm.is('form')) {
					elm.submit();
				} else {
					elm.click();
				}
			}
		}
	);

})(jQuery);
(function($) {

	O2widget.createClass(

		'lightbox',

		function(elm, options) {
			this.init(elm, options);
		},

		{
			// no static methods
		},

		{
			defaultOptions: {},
			scanDom: function() {},

			bind: function() {
				this.$elm.magnificPopup({
					type: 'image',
					closeOnContentClick: true,
					closeMarkup: '<div class="o2-modal__close o2-modal__close--lightbox"><button class="o2-btn o2-btn--transparent o2-btn--icon" onclick="$.magnificPopup.instance.close();"><span class="o2-icon o2-icon--cross"></span></button></div>',
					mainClass: 'o2-modal-wrapper',
					showCloseBtn: true
				});
			},
			unbind: function() {
				this.$elm.off('click.magnificPopup');
			},
			render: function() {},
			unrender: function() {}
		}
	);

})(jQuery);

(function($) {
	O2widget.createClass(

		'popover',

		function(elm, options) {
			this.init(elm, options, [
				'open',
				'target',
				'arrow',
				'container',
				'activeClass',
				'topClass',
				'bottomClass',
				'leftClass',
				'rightClass',
				'viewportPad',
				'elmPad',
				'align',
				'url',
				'media',
				'permanent'
			]);
		},

		{
			delegate: function() {
				var c = this;
				this.handle('click',  '.js-popover',   'handleClick');

				$(document)
					.on('click', function(evt) {
						var t = evt.target;
						if (!c.$targets.is(t) && !c.$targets.has(t).length) {
							c.each(function() {
								if (!this.disabled && this.open && !this.permanent) {
									this.close();
								}
							});
						}
					});
				$(window)	//pri resize okna zavre vsechny popovery, ktere zavrit jdou
					.on('resize', $.throttle(200, function(evt) {
						c.each(function() {
							if (!this.disabled && this.open && !this.permanent) {
								this.close();
							}
						});
					}));
			},

			$targets: $()
		},

		{
			defaultOptions: {
				arrow:        '.o2-popover__arrow',
				container:    '.o2-popover__container',
				body:         '.o2-popover__body',
				topClass:     'o2-popover--bottom',
				bottomClass:  'o2-popover--top',
				leftClass:    'o2-popover--right',
				rightClass:   'o2-popover--left',
				viewportPad:  10,
				elmPad:       5,
				speed:        100,
				align:        'start',
				method:       'get',
				loadOnce:     false,
				alwaysBottom: undefined
			},

			profileOptions: {
				hmore: {
					target: "next::ul",
					activeClass: "o2-header__link--active",
					elmPad: -20
				}
			},

			loaded: false,

			scanDom: function() {
				var $elm = this.$elm,
				    target = (this.target || $elm.attr('href')),
				    $target = this.$target = (target ? O2util.queryPath($elm, target) : $elm.next()),
				    indicator  = this.options.indicator;

				$elm.data('click-captured', true);

				if (!this.options.indicator)
					this.options.indicator = $target;

				this.$arrow = (this.arrow ? $target.find(this.arrow) : $());
				this.$container = $target.find(this.container);
				this.$indicator  = (indicator ? O2util.queryPath($elm, indicator) : $elm);

				this.markRelatedElements($target);
				this.prepareSet();

				this.posClasses = this.topClass + ' ' + this.bottomClass + ' ' + this.leftClass + ' ' + this.rightClass;
				this.widgetClass.$targets = this.widgetClass.$targets.add($target);
			},

			render: function() {
				if (!!this.open)
					this.renderOpen(0);
				else
					this.renderClosed(0);
			},

			position: function() {
				var $elm         = this.$elm,
				    elmOffset    = $elm.offset(),
				    elmWinOffset = O2util.getViewportOffset($elm),
				    elmH         = $elm.outerHeight(),
				    elmW         = $elm.outerWidth(),
				    $target      = this.$target,
				    $op          = $target.offsetParent(),
				    opOffset     = $op.offset(),
				    innerH       = this.$container.prop("scrollHeight"),
				    innerW       = this.$container.prop("scrollWidth"),
				    outerH       = this.$container.outerHeight(),
				    outerW       = this.$container.outerWidth(),
				    $win         = $(window),
				    winH         = $win.height(),
				    winW         = $win.width(),
				    $arrow       = this.$arrow,
				    arrowW       = $arrow.length && $arrow.outerWidth(),
				    arrowH       = $arrow.length && $arrow.outerHeight(),
				    pad          = this.viewportPad,
				    elmPad       = this.elmPad,
				    alignEnd     = (this.align == 'end'),
				    targetCss    = { position: 'absolute' },
				    arrowCss     = {},
				    pos          = this.options.alwaysBottom ? "bottom" : undefined;

				if (typeof pos === "undefined") {
					switch (true) {
					case elmWinOffset.top + elmH + elmPad + outerH + pad <= winH:
						pos = 'bottom';
						targetCss.top = elmOffset.top - opOffset.top + elmH + elmPad;
						break;
					case elmWinOffset.top >= elmPad + outerH + pad:
						pos = 'top';
						targetCss.top = elmOffset.top - opOffset.top - outerH - elmPad;
						break;
					case elmWinOffset.left + elmW + elmPad + outerW + pad <= winW:
						pos = 'right';
						targetCss.left = elmOffset.left - opOffset.left + elmW + elmPad;
						break;
					default:
						pos = 'left';
						targetCss.left = elmOffset.left - opOffset.left - outerW - elmPad;
						break;
					}
				}

				switch (pos) {
				case 'left':
				case 'right':
					var bottomOver = elmWinOffset.top + outerH + pad - winH,
						top = elmOffset.top - opOffset.top,
						arrowTop = Math.floor((elmH < innerH ? elmH : innerH) / 2 - arrowH / 2);
					if (alignEnd) {
						top = elmOffset.top - opOffset.top + elmH - outerH;
						bottomOver = 0;
					}
					if (bottomOver <= 0) {
						targetCss.top = top;
						arrowCss = {
							top: arrowTop
						};
					} else {
						targetCss.top = top - bottomOver;
						arrowCss = {
							top: arrowTop + bottomOver
						};
					}
					break;
				default:
					var rightOver = elmWinOffset.left + outerW + pad - winW,
						left = elmOffset.left - opOffset.left,
						arrowLeft = Math.floor((elmW < innerW ? elmW : innerW) / 2 - arrowW / 2);
					if (alignEnd) {
						left = elmOffset.left - opOffset.left + elmW - outerW;
						rightOver = 0;
					}
					if (rightOver <= 0) {
						targetCss.left = left;
						arrowCss = {
							left: arrowLeft
						};
					} else {
						targetCss.left = left - rightOver;
						arrowCss = {
							left: arrowLeft + rightOver
						};
					}
					break;
				}

				$target
					.css(targetCss)
					.removeClass(this.posClasses)
					.addClass(this[pos + 'Class']);
				$arrow
					.attr('style', '')
					.css(arrowCss);
			},

			unrender: function() {
				this.$target.show();
				this.$elm.removeClass(this.activeClass);
			},

			renderOpen: function(speed, evt, trigger) {
				this.$elm.addClass(this.activeClass);

				if (speed) {
					this.$target.slideDown(speed);
				} else {
					this.$target.show();
				}

				this.position();
			},

			close: function(speed) {
				if (this.open) {
					this.open = false;
					this.renderClosed(speed);
				}
			},

			renderClosed: function(speed) {

				this.$elm.removeClass(this.activeClass);

				if (speed) {
					this.$target.slideUp(speed);
				} else {
					this.$target.hide();
				}
				if (this.closedText) {
					this.$textTarget.text(this.closedText);
				}
			},

			handleClick: function(evt, trigger) {

				if (this.disabled) {
					return;
				}

				var $target = this.$target,
				    $elm = this.$elm,
						me = this;

				if ($target.length != 1) {
					this.reportError(
						'console',
						"Wrong target element amount: " + $target.length + "."
					);
					return;
				}

				evt.preventDefault();
				evt.stopImmediatePropagation();

				// Invert the status:
				var open = this.open = !this.open; // sic!

				if (open) {
					if (this.options.url && !this.loaded) {
						var $ajaxTarget = this.$target.find(this.options.body);
						var overwrite = {
							target: $ajaxTarget,
							indicator: this.$indicator // Pokud není zadaný, bere se jako indicator $target.
						};

						O2ajax.asyncUpdate(this, evt, trigger, overwrite, function() {
							me.loaded = true;
							me.renderOpen(me.options.speed, evt, trigger);
							me.closeOthers();
						});
					} else {
						this.renderOpen(this.options.speed, evt, trigger);
						this.closeOthers();
					}

				} else {
					this.renderClosed(this.options.speed);
				}
			},

			closeOthers: function() {
				// close all others
				var me = this;
				this.widgetClass.each(function() {
					if (me !== this && !this.disabled && this.open && !this.permanent) {
						this.close(this.options.speed);
					}
				});

				switch (this.options.scroll) {
				case 'target':
					O2util.scrollTo($target);
				case 'control':
					O2util.scrollTo($elm);
				case true:
					O2util.scrollTo($elm.add($target));
				}
			}
		}
	);
})(jQuery);

/**
 * POZOR! KOMPONENTA JE DEPRECATED, duplikuje totiž js-update
 */
(function($) {

	O2widget.createClass(

		'autosave',

		function(elm, options) {
			this.init(elm, options);
		},

		{
			delegate: function() {
				this.handleRelated('change', '.js-autosave-trigger', 'handleChange');
			}
		},

		{
			defaultOptions: {
				interval: 1000,
				submit: 'form'
			},

			profileOptions: {
			},

			scanDom: function() {

				var $elm = this.$elm,
					$ctrls = $elm.find('input,select,textarea'),
					$p = $elm.find('.js-autosave-protected');

				// Exclude those in protected areas:
				$ctrls = $ctrls.filter(function() {
					return !($p.has(this).length);
				});

				this.markRelatedElements($ctrls, 'js-autosave-trigger');
			},

			handleChange: function(evt, trigger, data) {

				if (this.suspended) {
					return;
				}

				var me = this,
					o = this.options;

				if (!o.target) {
					o.target = o.update;
				}

				this.suspended = true;

				window.setTimeout(function() {
					O2ajax.asyncUpdate(me, evt, trigger, {}, function() {
						me.scanDom();
						me.suspended = false;
					});
				}, o.interval);
			}
		}
	);

})(jQuery);
(function($) {

	var $w = $(window);

	O2widget.createClass(

		'lazylist',

		function(elm, options) {
			this.init(elm, options, [
				'media',
				'proximity',
				'loadOnStart'
			]);
		},

		{
			delegate: function() {
				this.handleGlobal('mediachange.o2util', 'handleScroll');
			}
		},

		{
			defaultOptions: {
				proximity: 200,
				method: 'get'
			},

			profileOptions: {
				table: {
					indicator: 'closest-next::.js-lazylist-loader',
					indicatorClass: 'o2-loader--lazytable'
				}
			},

			render: function() {
				$('.js-lazylist-redundant').hide();

				if (this.loadOnStart && !this.disabled && !this.suspended) {
					this.loadNext();
				}
			},

			bind: function() {
				var me = this;
				this.$scrollParent = this.$elm.scrollParent();
				if (this.$scrollParent.is(document))
					this.$scrollParent = $(window);

				this.$scrollParent.on('scroll.' + this.uuid, $.throttle(200, $.proxy(this.handleScroll, me)));
				this.handleScroll();
			},

			handleScroll: function() {
				var $edge = this.$elm.find('.js-lazylist-edge').last();
				if (O2util.scrolledToElement($edge, this.proximity, this.$scrollParent) && !this.suspended) {
					this.loadNext();
				}
			},

			unrender: function() {
				// TODO: Nepočítá s více instancemi na stránce!
				$('.js-lazylist-redundant').show();
				this.$scrollParent.off('scroll.' + this.uuid, this.handleScroll);
				this.disabled = true;
			},

			/**
			 * Return true, if scrolling downwards has revealed the bottom edge of the element
			 * in the viewport or is going to reveal it after at most `proximity` pixels of
			 * scrolling.
			 */
			atBottom: function() {

				var $elm = this.$elm,
					bottom = $elm.offset().top + $elm.height();

				return (bottom < (this.widgetClass.wBottom + this.proximity));
			},

			/**
			 * Load the next subset. Then initiate the AJAX request.
			 */
			loadNext: function() {
				this.suspended = true;

				var $elm = this.$elm,
					options = this.options,
					$edge = $elm.find('.js-lazylist-edge').last(),
					next = $edge.data('lazylist-next');

				if (next) {

					// prevent reuse of the same edge element
					$edge.attr('data-lazylist-next', 'false');
					$edge.data('lazylist-next', false);

					var me = this,
					    overwrite = {
							url: next,
							append: true
						};

					O2ajax.asyncUpdate(this, undefined, undefined, overwrite, function() {
						me.suspended = false;
						me.handleScroll();
					});

				} else {
					this.disabled = true;
				}
			}
		}
	);
})(jQuery);
(function($) {

	var $window   = $(window),
	    windowTop = 0;

	O2widget.createClass(

		'fixed',

		function(elm, options) {
			this.init(elm, options, [
				'posClass',
				'topOffset',
				'setCss',
				'media',
				'preserveWidth'
			]);
		},

		{
			delegate: function() {

				var that = this;

				$(document)
					.on('contentready.o2util mediachange.o2util shown.o2util hidden.o2util', function(){
						windowTop = $window.scrollTop();
						that.each(that.prototype.render, true);
					});

				$window
					.scroll(function() {
						windowTop = $window.scrollTop();
						that.checkAll();
					})
					.on('load', function(){
						windowTop = $window.scrollTop();
						that.each(that.prototype.render, true);
					});
			},

			checkAll: function() {
				this.each(this.prototype.checkPosition, true);
			},

			anchorDelta: function() {
				var instances = this.instances,
					delta = 0;
				if (instances && instances.length) {
					for (var i = 0, instance; instance = instances[i++]; ) {
						if (!instance.disabled && instance.options.adjustAnchor) {
							var $elm = instance.$elm,
								height = instance.topOffset + $elm.outerHeight();
							if (height > delta) {
								delta = height;
							}
						}
					}
				}
				return delta;
			}
		},

		{
			defaultOptions: {
				container: 'closest::.js-fixed-container',
				media: ['lg', 'xl', 'hg'],
				topOffset: 0,
				setCss: false,
				stopAboveOffset: 0,
				stopUnderOffset: 0,
				fullscreen: false,
				bottomOffset: 52
			},

			profileOptions: {

				// Profile for the sidebar elements - tested for sidebars with .o2-nav-vertical

				side: {
					stopAbove: '.footer',
					stopAboveOffset: 20,
					topOffset: 20,
					setCss: true,
					preserveWidth: true,
					deriveTopOffset: '.o2-internal-header'
				},

				// Internal header profile

				internalHeader: {
					media: false,
					adjustAnchor: true,
					setCss: true,
					deriveTopOffset: '.control-menu-level-1'
				},

				mobileMenu: {
					media: ['xs', 'sm'],
					setCss: true,
					deriveTopOffset: '.o2-internal-header'
				}
			},

			scanDom: function() {

				var $elm = this.$elm,
					options = this.options,
					deriveTopOffset = options.deriveTopOffset;

				this.$container = O2util.queryPath($elm, options.container);

				if (deriveTopOffset) {
					this.$deriveTopOffset = O2util.queryPath($elm, deriveTopOffset);
				}

				// There might be an element with which the fixed element
				// cannot overlap, although it is in the fixed position.
				// Now we scan for such elements.

				if (options.stopAbove) {
					this.$stopAbove = O2util.queryPath($elm, options.stopAbove);
				}
				if (options.stopUnder) {
					this.$stopUnder = O2util.queryPath($elm, options.stopUnder);
				}
			},

			render: function() {

				var $elm = this.$elm;

				// Reset rendering:

				$elm
					.removeClass(this.posClass)
					.css('position', '')
					.css('top', '');

				if (this.preserveWidth) {
					$elm.css('width', '');
				}

				if (this.$container && this.$container.length) {
					this.$container.css('min-height', 0);
				}

				// Read the static rendering properties
				// and original values:

				var elmH = this.elmH = $elm.outerHeight();

				this.originalOffset = $elm.offset().top;

				if (this.$stopAbove && this.$stopAbove.length) {
					this.bottomEdge = this.$stopAbove.offset().top;
					this.bottomEdge -= this.options.stopAboveOffset;
				}

				if (this.$stopUnder && this.$stopUnder.length) {
					this.topEdge = this.$stopUnder.offset().top + this.$stopUnder.outerHeight();
				}

				this.originalPosition = $elm.css('position') || 'static';
				this.originalTop = $elm.css('top') || 0;

				// Expand the container so that it takes the same
				// amount of space as the original element when it is
				// taken out of it:

				if (this.$container && this.$container.length) {
					this.$container.css('min-height', elmH);
				}

				// Set explicitly the width of the element to match its current
				// (computed) width:

				if (this.preserveWidth) {
					$elm.css({ width: $elm.width() });
				}

				// Check the position for the first time:
				this.checkPosition();
			},

			unrender: function() {

				var $elm = this.$elm;

				$elm
					.removeClass(this.posClass)
					.css('position', '')
					.css('top', '');

				if (this.preserveWidth) {
					$elm.css('width', '');
				}

				if (this.options.full)
					$elm.css("bottom", "");

				if (this.$container && this.$container.length) {
					this.$container.css('min-height', 0);
				}
			},

			checkPosition: function() {
				if (this.options.fullscreen)
					this.checkPositionFull();
				else
					this.checkPositionNormal();
			},

			getTopOffset: function() {
				var top,
				    $deriveTopOffset = this.$deriveTopOffset;

				if ($deriveTopOffset.css('position') == 'fixed') {
					top = $deriveTopOffset.css('top');
					if (top)
						top = parseInt(top, 10);
				} else {
					top = $deriveTopOffset.offset().top;
				}

				return top + $deriveTopOffset.outerHeight();
			},

			checkPositionFull: function() {
				var $elm = this.$elm,
					cls = this.posClass,
					$container = this.$container,
					topEdge = this.topEdge,
					$deriveTopOffset = this.$deriveTopOffset,
					topOffset = this.topOffset,
					originalOffset;

				if ($deriveTopOffset && $deriveTopOffset.length) {
					topOffset += this.getTopOffset();
				}

				if ($container && $container.length) {
					originalOffset = $container.offset().top;
				} else {
					originalOffset = this.originalOffset;
				}

				// Has to be fixed:

				this.isFixed = true;

				$elm.addClass(cls);
				if (this.setCss) {
					if (topEdge) {

						// Calculate, how many pixels would the fixed element overlap
						// with the 'stop under' element.

						var delta = topEdge - windowTop;

						if (delta > topOffset)
							topOffset = delta;
					}
					$elm.css({
						position: 'fixed',
						top: topOffset,
						bottom: this.options.bottomOffset
					});
				}
			},

			checkPositionNormal: function() {

				var $elm = this.$elm,
					cls = this.posClass,
					$container = this.$container,
					bottomEdge = this.bottomEdge,
					$deriveTopOffset = this.$deriveTopOffset,
					topOffset = this.topOffset,
					originalOffset;

				if ($deriveTopOffset && $deriveTopOffset.length) {
					topOffset += this.getTopOffset();
				}

				if ($container && $container.length) {
					originalOffset = $container.offset().top;
				} else {
					originalOffset = this.originalOffset;
				}

				if (originalOffset < windowTop + topOffset) {

					// Has to be fixed:

					this.isFixed = true;

					$elm.addClass(cls);
					if (this.setCss) {
						if (bottomEdge) {

							// Calculate, how many pixels would the fixed element overlap
							// with the 'stop above' element.

							var delta = windowTop + this.elmH + topOffset - bottomEdge;

							if (delta > 0) {
								topOffset -= delta;
							}
						}
						$elm.css({
							position: 'fixed',
							top: topOffset
						});
					}
				} else {

					// Use the original rendering:

					this.isFixed = false;

					$elm
						.removeClass(cls)
						.css('position', '')
						.css('top', '');
				}
			}
		}
	);

})(jQuery);

// TODO: předělat isScrolling na .on/.off event handleru scroll
(function($) {
	O2widget.createClass(

		'scrollspy',

		function(elm, options) {
			this.init(elm, options, [
				'media',
				'indicator',
				'activeClass',
				'posOffset'
			]);
		},

		{
			delegate: function() {
				var c = this;
				$(window).on('scroll shown.o2util', function() {
					c.each(function() {
						if (!this.disabled) {
							this.update();
						}
					});
				});

				$(document).on('shown.o2util hidden.o2util', function(evt) {
					c.each(function() {
						if (!this.disabled && this.$elm.has(evt.target).length)
							this.scanDom();
					});
				});

				this.handleRelated('click', 'a[href^="#"]', 'onItemClick');
			}
		},

		{
			defaultOptions: {
				posOffset: 10,
				indicator: 'closest::.o2-nav-vertical__item',
				activeClass: 'o2-nav-vertical__item--active',
				media: ['lg', 'xl', 'hg']
			},

			isScrolling: false,

			scanDom: function() {
				var $menuItems = this.$menuItems = this.$elm.find('a[href*="#"]:visible');
				$menuItems.data('click-captured', true);
				this.$scrollItems = $menuItems
					.filter(function() {
						var anchor = $(this).attr("href");
						if ($(anchor).length === 0) {
							console.log('Nenalezena kotva s názvem ' + anchor);
							return false;
						} else
							return true;
					})
					.map(function(){
						return $($(this).attr("href"));
					});
				this.markRelatedElements(this.$menuItems);
			},

			render: function() {
				this.update();
			},

			unrender: function() {
				O2util.queryPath(this.$menuItems, this.indicator).removeClass(this.activeClass);
			},

			onItemClick: function(trigger, elm) {
				this.isScrolling = true;
				var $scrollToElm = $($(elm).attr('href'));
				var that = this;

				if ($scrollToElm.length === 0)
					return false;

				O2util.queryPath(this.$menuItems, this.indicator).removeClass(this.activeClass);
				O2util.queryPath($(elm), this.indicator).addClass(this.activeClass);

				var fixed = O2widget && O2widget.classes && O2widget.classes.fixed;
				var offset = -this.posOffset;
				if (fixed) {
					offset -= fixed.anchorDelta();
				}

				$('html, body').stop().animate({
					scrollTop: $scrollToElm.offset().top + offset
				}, 300, 'swing', function(){
					setTimeout(function(){
						that.isScrolling = false;
					}, 50); // Bez 50ms timeoutu se callback volá příliš brzy. WTF
				});
			},

			update: function() {
				if (this.isScrolling)
					return;

				var fromTop = $(window).scrollTop();
				var offs = this.posOffset;

				if (O2widget.classes.fixed) {
					offs += O2widget.classes.fixed.anchorDelta();
				}

				var cur = this.$scrollItems.map(function(){
					if ($(this).offset().top < fromTop + offs)
						return this;
					});
				cur = cur[cur.length-1];
				var id = cur && cur.length ? cur[0].id : "";

				if (!this.lastId || this.lastId !== id) {
					this.lastId = id;
					O2util.queryPath(this.$menuItems, this.indicator).removeClass(this.activeClass);
					O2util.queryPath(this.$menuItems.filter("[href='#" + id + "']"), this.indicator).addClass(this.activeClass);
				}
			}
		}
	);
})(jQuery);

(function($) {

	$.fn.matchHeight._throttle = 150;
	$.fn.matchHeight._maintainScroll = true;

	O2widget.createClass(

		'match',

		function(elm, options) {
			this.init(elm, options, ['set']);
		},

		{
			matchHeightTimeout: false,

			delegate: function() {
				var widget = this;
				this
					.handleGlobal('contentready.o2util shown.o2util hidden.o2util', 'update');

				window.setTimeout(function() { // První spuštění je zpožděné, aby se stihly iniciovat všechny instance.
					widget.update();
				}, $.fn.matchHeight._throttle);
			},

			update: function() {
				var sets = this.sets,
					sorted = [],
					unsorted = [];
				for (var k in sets) {
					var n = parseInt(k, 10);
					if (n) {
						sorted.push(sets[k]);
					} else {
						unsorted.push(sets[k]);
					}
				}
				sorted.sort(function(a, b) {
					return a.setName - b.setName;
				});
				for (var i = 0, set; set = sorted[i++]; ) {
					this.rebindSet(set);
				}
				for (var i = 0, set; set = unsorted[i++]; ) {
					this.rebindSet(set);
				}
			},

			rebindSet: function(set) {
				var $jq = set.$_jq;
				if ($jq) {
					$jq.matchHeight({ remove: true });
				}
				$jq = $();
				for (var i = 0, instance; instance = set[i++]; ) {
					if (!instance.disabled) {
						var $elm = instance.$elm;
						if (!$elm.is(':hidden')) {
							$jq = $jq.add($elm);
						}
					}
				}
				if ($jq.length) {
					set.$_jq = $jq;
					$jq.matchHeight();
				} else {
					set.$_jq = false;
				}
			}
		},

		{
			scanDom: function() {
				this.prepareSet();
			}
		}
	);
})(jQuery);

(function($) {
	O2widget.createClass(

		'hfit',

		function(elm, options) {
			this.init(elm, options, ['media']);
		},

		{
			hfitTimeout: false,

			minInterval: 100,

			delegate: function() {
				var c = this;
				$(document).on('contentready.o2util mediachange.o2util', function(evt) {
					c.update();
				});
				$(window).on('load', function(evt) {
					c.update();
				});
			},

			update: function() {
				this.each(function() {
					this.calcVisibility();
				}, true);
			}
		},

		{
			defaultOptions: {
				media: ['md', 'lg', 'xl', 'hg'],
				items: 'descendant::li:not(.js-hfit-more,.js-hfit-fixed)',
				fixed: 'descendant::.js-hfit-fixed',
				more: 'descendant::.js-hfit-more',
				dump: 'descendant::.js-hfit-more > ul',
				bumper: 'closest-prev::.js-hfit-bumper',
				starter: 'closest-prev::.js-hfit-starter',
				pad: 0
			},

			scanDom: function() {

				var $elm = this.$elm,
					options = this.options;

				this.$items = O2util.queryPath($elm, options.items);
				this.$fixed = O2util.queryPath($elm, options.fixed);
				this.$more = O2util.queryPath($elm, options.more);
				this.$dump = O2util.queryPath($elm, options.dump);
				this.$bumper = O2util.queryPath($elm, options.bumper);
				this.$starter = O2util.queryPath($elm, options.starter);
			},

			extendDom: function() {
				var $dumped = this.$dumped = this.$items.clone();
				this.$dump.append($dumped);
			},

			cleanupDom: function() {
				this.$dump.empty();
				this.$dumped = $();
			},

			calcVisibility: function() {

				var $elm = this.$elm,
					$items = this.$items,
					len = $items.length,
					$more = this.$more,
					$dumped = this.$dumped,
					iw = [],
					fw = 0,
					mw,
					consumed,
					fitsWithMore = 0,
					fits = 0,
					$starter = this.$starter,
					pad = this.options.pad,
					available;

				if (!$dumped) {
					return;
				}

				if ($starter.length) {
					available = this.$bumper.offset().left - $starter.offset().left - $starter.outerWidth(true) - pad;
				} else {
					available = this.$bumper.offset().left - $elm.offset().left - pad;
				}

				$elm.css({ visibility: 'hidden' });

				$items
					.show()
					.each(function(i) {
						iw[i] = $(this).outerWidth();
					});

				$more.show();
				mw = $more.outerWidth();
				this.$fixed.filter(':visible').each(function() {
					fw += $(this).outerWidth();
				});

				consumed = fw;
				for (var i = 0; i < len; i++) {
					consumed += iw[i];
					if ((fitsWithMore == i) && consumed + mw <= available) {
						fitsWithMore++;
					}
					if ((fits == i) && consumed <= available) {
						fits++;
					}
				}

				if (fits == len) {
					$more.hide();
					this.$dumped.hide();
				} else {
					/*
					 * S. Krofta nechce:
					 *
					if (fitsWithMore > len - 2) {
						fitsWithMore = len - 2;
					}
					 */
					$more.show();
					if (fitsWithMore <= 0) {
						$items.hide();
						$dumped.show();
					} else {
						$items.slice(fitsWithMore).hide();
						$dumped.hide().slice(fitsWithMore).show();
					}
				}

				$elm.css({ visibility: 'visible' });
			},

			resetVisibility: function() {

				// this.$items.show();
				// Finer algorithm to avoid block / inline-block collisions on responsive:
				this.$items.each(function() {
					$(this).css('display', '');
				});

				this.$more.hide();
			},

			render: function() {
				this.extendDom();
				this.calcVisibility();
			},

			unrender: function() {
				this.resetVisibility();
				this.cleanupDom();
			}
		}
	);
})(jQuery);
(function($) {
	O2widget.createClass(

		'multisubmit',

		function(elm, options) {
			this.init(elm, options, []);
		},

		{
			delegate: function() {
				this.handle('submit',       'form.js-multisubmit',    '_onSubmit');
				this.handleRelated('click', '.js-multisubmit-submit', '_onClick');
			}
		},

		{
			defaultOptions: {
				submits: 'descendant::button[type="submit"]'
			},
			_canSubmit: false, // zda je povolen submit event formuláře
			_defaultUrl: null,

			scanDom: function() {
				this._defaultUrl = this.$elm.attr('action');
				this.$altSubmits = O2util.queryPath(this.$elm, this.options.submits);
				this.markRelatedElements(this.$altSubmits, 'js-multisubmit-submit');
			},

			bind: function() {},
			render: function() {},
			unrender: function() {},

			// Při kliknutí na submit button změníme action, takže až eventa probublá na form, bude mít již nový action
			_onClick: function(evt, trigger) {
				var $trigger = $(trigger),
				    action   = $trigger.data(this.widgetName + '-action'),
				    form     = this.$elm;

				if (typeof action == 'string') // je-li definovaná URL pro action
					form.attr('action', action);
				else if (form.attr('action') != this._defaultUrl)
					form.attr('action', this._defaultUrl); // vrátí originální URL formuláře do action
			}

		}
	);

})(jQuery);
(function($) {
	var Autorun = O2widget.createClass(

		'autorun',

		function(elm, options) {
			this.init(elm, options, [
				'node',
				'event'
			]);
		},

		{
			winLoadInstances: [],
			domReadyInstances: [],

			isWinLoad: false,
			isDomReady: false,

			onWinLoad: function() {
				this.isWinLoad = true;
				for (var i = 0; i < this.winLoadInstances.length; i++) {
					var instance = this.winLoadInstances[i];
					if (!instance.disabled) {
						instance.prepare();
					}
				}
			},

			onDomReady: function() {
				this.isDomReady = true;
				for (var i = 0; i < this.domReadyInstances.length; i++) {
					var instance = this.domReadyInstances[i];
					if (!instance.disabled) {
						instance.prepare();
					}
				}
			}
		},

		{
			defaultOptions: {
				node: 'window',
				event: 'load',
				straggled: true,
				repeat: false,
				timeout: 30000,
				exec: function($elm) { // TODO: v budoucnu lze rozšířit
					$elm.trigger('click', {'isAutorun': true}); // Vrací isAutorun pro použití v dalších widgetech.
				}
			},

			profileOptions: {},

			scanDom: function() {
				var node = this.node,
				    event = this.event;

				if (node == 'window' && event == 'load')
					this.registerWinLoad();
				else if (node == 'document' && event == 'ready')
					this.registerDomReady();
				else {
					this.$node = (
						node == 'document'
						? $(document)
						: O2util.queryPath(this.$elm, node)
					);
				}
			},

			render: function() {},

			bind: function() {
				var $node = this.$node;
				if ($node && $node.length) {
					if (this.options.repeat) {
						$node.on(this.event, $.proxy(this.prepare, this));
					} else {
						$node.one(this.event, $.proxy(this.prepare, this));
					}
				}
			},

			registerWinLoad: function() {
				if (this.widgetClass.isWinLoad) {
					if (!this.disabled && this.options.straggled) {
						this.prepare();
					}
				} else {
					this.widgetClass.winLoadInstances.push(this);
				}
			},

			registerDomReady: function() {
				if (this.widgetClass.isDomReady) {
					if (!this.disabled && this.options.straggled) {
						this.prepare();
					}
				} else {
					this.widgetClass.domReadyInstances.push(this);
				}
			},

			prepare: function(event, data) {
				var timeout = this.options.timeout;
				if (timeout) {
					var me = this;
					this.t = window.setTimeout(function() {
						me.run(event, data);
						me.t = false;
					}, timeout);
				} else {
					this.run(event, data);
				}
			},

			run: function(event, data) {
				this.options.exec(this.$elm, event, data);
			}
		}
	);

	$(window).on('load', $.proxy(Autorun.onWinLoad, Autorun));
	$($.proxy(Autorun.onDomReady, Autorun));

})(jQuery);
(function($) {

	O2widget.createClass(

		'clipboard',

		function(elm, options) {
			this.init(elm, options, [
				'source'
			]);
		},

		{
			delegate: function() {
				this.handle('click', '.js-clipboard', '_onClick');
			}
		},

		{
			defaultOptions: {
				source: null,
				custom: null,
				message: "Obsah byl zkopírován do schránky."
			},

			$source: null,

			scanDom: function() {
				var $elm = this.$elm;
				this.$source = O2util.queryPath($elm, this.source);
			},

			render: function() {},
			unrender: function() {},

			bind: function() {
				var clipboardOptions = {};

				if (this.$source.length > 0) { // Pokud je zadaný target, nastavíme ho.
					var $source = this.$source[0];
					clipboardOptions.target = function() { return $source; };
				} else if (this.options.custom) { // Pokud není target, ale je text, nasavíme text.
					var text = this.options.custom;
					clipboardOptions.text = function() { return text; };
				} else { // Pokud není ani jedno, vyhodíme skytou chybu do konzole.
					clipboardOptions.text = function() { return ""; };
					this.reportError(
						'console',
						"Nothing to copy to clipboard."
					);
				}

				this.clipboard = new ClipboardJS(this.$elm[0], clipboardOptions);
				this.clipboard.on("success", $.proxy(this.onSuccessMessage, this));
				this.clipboard.on("error", this.onErrorMessage);
			},

			unbind: function() {
				this.clipboard.destroy();
			},

			onErrorMessage: function() {
				window.O2widget.classes.sysmsg.showMessage([
					{
						"text": "Text nelze zkopírovat do schránky.",
						"textInternal": "",
						"severity": "danger",
						"isInternal": false,
						"closeBtn": true,
						"autoClose": 10000,
						"messageId": "dsClipboard"
					}
				]);
			},

			onSuccessMessage: function() {
				window.O2widget.classes.sysmsg.showMessage([
					{
						"text": this.options.message,
						"textInternal": "",
						"severity": "success",
						"isInternal": false,
						"closeBtn": true,
						"autoClose": 10000,
						"messageId": "dsClipboard"
					}
				]);
			}
		}
	);

})(jQuery);
(function($) {

	// Globální proměná pro sysmsg. Je zajištěno, že se naplní daty pouze jednou (při prvním použití sysmsg) a následně ji už nelze měnit.
	// Prvním použitím sysmsg se rozumí buď první inicializace instance widgetu, nebo prvním zavoláním statické metody showMessage.
	var sysmsgGlobal = {
		// Mapuje severitu na přislušnou ikonku z themy
		iconSeverityMap: {
			"internal": "checkmark",
			"success":  "checkmark",
			"warning":  "info-fill",
			"danger":   "exclamation-mark-fill"
		},

		mustacheItem: O2config.templates.sysmsg.mustacheItem,
		mustacheModal: O2config.templates.sysmsg.mustacheModal,

		// Defaultní target class.
		targetClass: '#o2-popup-message-main',

		// Target jde vyhledat pouze jednou a pak už musí zůstat stejný.
		$target: $(),

		// Vrátí element s targetem zpráv, nebo ho vytvoří, pokud neexistuje a vrátí nově vytvořený.
		resolveTarget: function($elm, targetID) {
			var $targetElm = O2util.queryPath($elm, targetID).first();
			if (!$targetElm.length) { // pokud target neexistuje, vytvoří ho na konci body
				$targetElm = $('<div class="o2-popup-message" id="' + targetID.replace('#', '') + '"></div>').appendTo('body');
			}
			return $targetElm;
		},

		// Z ajaxové response namapuje data definovaná dle SeSp_ONEPORTAL_GetInfoMessages_v1.2.docx na data javascriptu
		responseDataMap: function(response) {
			return {
				"severity":        response.severity,
				"icon":            sysmsgGlobal.iconSeverityMap[response.severity] || 'success',
				"content":         response.text,
				"contentInternal": response.textInternal,
				"timeoutMs":       response.autoClose,
				"isInternal":      response.isInternal,
				"showClose":       response.closeBtn
			};
		},

		// Pro ajaxový request namapuje data z javascriptu na objekt definovaný v SeSp_ONEPORTAL_GetInfoMessages_v1.2.docx
		requestDataMap: function(data) {
			return {
				"infoMessageIds":     data.msgid,
				"timestamp":          data.timestamp,
				"sourceApplication":  data.sourceid,
				"exceptionParamMaps": data.exceptParams,
				"scopeGroupId":       data.scopeid,
				"language":           data.language
			};
		},

		renderHTML: function(data) {
			var rendered = "";
			for (var i = 0; i < data.length; i++) {
				var item = data[i];

				if (!item.isInternal && !item.text) // Prázdná message znamená negenerovat žádnou zprávu. SeSp_ONEPORTAL_GetInfoMessages_v1.3.docx
					continue;

				var tplPartials = {};
				var tplData = sysmsgGlobal.responseDataMap(item);


				if (data.stacktrace) {
					var stacktraceHash = ((Math.random() + 1) * 1e16).toString(16);

					tplData.contentInternal    += '\n<a href="#' + stacktraceHash + '" class="o2-typo__link o2-typo__link--reverted js-modal">' + O2config.lang.sysmsgErrorLink + '</a>';
					tplData.stacktraceHash      = stacktraceHash;
					tplData.stacktrace          = O2util.decodeBase64(data.stacktrace);
					tplData.lang                = O2config.lang;
					tplPartials.stacktraceModal = sysmsgGlobal.mustacheModal;
				}

				rendered += Mustache.render(sysmsgGlobal.mustacheItem, tplData, tplPartials);

				// Informace do Omniture dle OneCRM-specifikace-AdobeAnalytics_1.2.pdf (DSOC-31188)
				if (typeof window.adobeDataLayer === "object" && (item.severity === "success" || item.severity === "danger")) {
					adobeDataLayer.push({
						event: "popupMessage",
						eventData: {
							messageType: item.severity === "danger" ? "error" : "success", // Dle specifiakce Romana Gazárka: danger => error, success => success
							messageId: item.id || "???",
							messageDescription: item.text
						}
					});
				}
			}

			sysmsgGlobal.$target.append(rendered);
			sysmsgGlobal.$target.trigger("contentready.o2util");
		},

		kahl: function(url, data) {
			var credentials = O2config.getInformationMessagesCreds    || "",
			    scopeId     = O2config.getInformationMessagesScopeId  || 0,
			    language    = O2config.getInformationMessagesLanguage || "cs";

			$.ajax({
				type: "POST",
				dataType: "json",
				url: url,
				data: sysmsgGlobal.requestDataMap({
					msgid: data.msgid,
					timestamp: data.timestamp,
					sourceid: data.sourceid,
					exceptParams: data.exceptParams,
					scopeid: scopeId,
					language: language
				}),
				statusCode: {
					400: function() {
						console.error(O2config.lang.sysmsg400Error);
					},
					404: function() {
						console.error(O2config.lang.sysmsg404Error);
					},
					500: function() {
						O2util.reportError(
							"user",
							O2config.lang.appErrorMsg
						);
					}
				},
				success: function(response) {
					response.stacktrace = data.stacktrace; // Ručně doplníme stacktrace, protože, ten se v ajaxu nezpracovává.
					sysmsgGlobal.renderHTML(response);
				},
				xhrFields: {
					withCredentials: true
				},
				beforeSend: function(jqXHR) {
					jqXHR.setRequestHeader("Authorization", "Basic " + credentials);
				}
			});
		}
	};

	O2widget.createClass(

		"sysmsg",

		function(elm, options) {
			this.init(elm, options, [
				'target',
				'msgid',
				'timestamp',
				'sourceid',
				'exceptParams',
				'scopeid',
				'url',
				'stacktrace'
			]);
		},

		{
			showMessage: function(data) {
				if (!sysmsgGlobal.$target.length)
					sysmsgGlobal.$target = sysmsgGlobal.resolveTarget('body', sysmsgGlobal.targetClass);

				if (!Array.isArray(data))
					data = [data];

				// vyrenderuje HTML hlášky
				sysmsgGlobal.renderHTML(data);
			},

			kahl: function(url, data) {
				if (!sysmsgGlobal.$target.length)
					sysmsgGlobal.$target = sysmsgGlobal.resolveTarget("body", sysmsgGlobal.targetClass);

				sysmsgGlobal.kahl(url, data);
			}
		},

		{
			defaultOptions: {
				target:       sysmsgGlobal.targetClass,
				htmlItem:     sysmsgGlobal.mustacheItem,
				htmlCloseBtn: sysmsgGlobal.mustacheCloseBtn,
				htmlInternal: sysmsgGlobal.mustacheInternal,
				htmlTimeout:  sysmsgGlobal.mustacheTimeout
			},

			$target: null,

			scanDom: function() {
				$elm = this.$elm;

				// Pouze při první inicializaci instance lze nastavit mustache šablony a target
				if (!sysmsgGlobal.$target.length) {
					sysmsgGlobal.targetClass      = this.target;
					sysmsgGlobal.mustacheItem     = this.options.htmlItem;
					sysmsgGlobal.mustacheCloseBtn = this.options.htmlCloseBtn;
					sysmsgGlobal.mustacheInternal = this.options.htmlInternal;
					sysmsgGlobal.mustacheTimeout  = this.options.htmlTimeout;
					sysmsgGlobal.$target          = sysmsgGlobal.resolveTarget($elm, this.target);
				}
			},

			render: function() {
				var url = this.url || O2config.getInformationMessagesURL || '';

				sysmsgGlobal.kahl(url, {
					msgid: this.msgid,
					timestamp: this.timestamp,
					sourceid: this.sourceid,
					exceptParams: this.exceptParams,
					scopeid: this.scopeid,
					stacktrace: this.stacktrace
				});
				this.$elm.remove(); // Vždy nakonec celý element odebere, protože již není potřeba.
			},
			unrender: function() {},
			bind: function() {},
			unbind: function() {}
		}
	);
})(jQuery);

(function($) {
	O2widget.createClass(

		'autofocus',

		function(elm, options) {
			this.init(elm, options);
		},

		{
			delegate: function() {
				var c = this;
				//reakce na event shown
				$(document).on('shown.o2util', function(evt) {
					var $content = $(evt.target),
						$felems = $content.find('.js-autofocus');
					if ($felems.length) {
						$felems[0].focus();
					}
				});
			}
		},

		{
			render: function() {
				//prvotni fokus aby se nemusel nastavovat atribut autofocus
				this.$elm.focus();
			}
		}
	);
})(jQuery);
(function($) {

	O2widget.createClass(

		'analytics',

		function(elm, options) {
			this.init(elm, options, [
				'type',
				'data'
			]);
		},

		{
			send: function(type, data) {
				// TODO: Příprava pro statickou metodu odeslání dat k analytice.
			}
		},

		{
			defaultOptions: {
				type: null
			},

			scanDom: function() {},

			render: function() {
				try {
					var data = $.parseJSON(O2util.decodeBase64(this.data));
				} catch(err) {
					console.error('Chyba při zpracování dat pro ' + this.type + ' analytics.');
					this.$elm.remove();
					return false;
				}

				if (this.type == 'omniture')
					this.sendOmniture(data);

				this.$elm.remove(); // Vždy nakonec celý element odebere, protože již není potřeba.
			},

			sendOmniture: function(data) {
				if (typeof adobeDataLayer != "undefined") {
					adobeDataLayer.push(data);
				} else {
					console.warn("Není definována proměnná adobeDataLayer pro Adobe DTM.");
				}
			},

			unrender: function() {},
			bind: function() {},
			unbind: function() {}
		}
	);
})(jQuery);
(function($) {
	O2widget.createClass(

		'field',

		function(elm, options) {
			this.init(elm, options, [
				'activeClass',
				'inactiveClass',
				'editContent',
				'viewContent',
				'textTarget',
				'classTarget',
				'editText',
				'viewText',
				'autofocus',
				'singleActive',
				'allActive',
				'set',
				'keepInput',
				'editMode'
			]);
		},

		{
			delegate: function() {
				this
					.handleRelated('click',  '.js-field-edit',   'renderEdit')
					.handleRelated('click',  '.js-field-cancel', 'renderView')
					.handleRelated('click',  'a.js-field-confirm,button.js-field-confirm', 'saveAndExit')
					.handleRelated('click',  'a.js-field-update,button.js-field-update',   'save')
					.handleRelated('click',  'a.js-field-remove,button.js-field-remove',   'remove')
					.handleRelated('click',  'a.js-field-add,button.js-field-add',         'add')
					.handleRelated('change', 'input.js-field-confirm,select.js-field-confirm,textarea.js-field-confirm', 'saveAndExit')
					.handleRelated('change', 'input.js-field-update,select.js-field-update,textarea.js-field-update',    'save');
			}
		},

		{
			defaultOptions: {
				activeClass: 'o2-field--active',
				inactiveClass: false,
				classTarget: 'self::*',
				editContent: false,
				viewContent: false,
				textTarget: false,
				autofocus: true,
				singleActive: true,
				autoselect: false,
				restoreOnCancel: true,
				restoreOnSave: false,
				keepInput: false,
				watchContent: true
			},

			profileOptions: {
				editlist: {
					activeClass: 'o2-list--active',
					inactiveClass: false,
					replace: true,
					target: 'descendant::.o2-list__items',
					submit: 'self',
					emptyUpdated: 'descendant::input[type="file"]'
				},
				edittpls: {
					replace: true,
					target: 'descendant::.js-field-target',
					submit: 'self'
				},
				addtpl: {
					previewTemplate: O2config.templates.field.addtplPreview,
					previewAppendTo: 'descendant::.js-field-target',
					previewConstant: 'Načítám šablonu'
				},
				delitem: {
					indicator: "descendant::.o2-list__items",
					submit: "trigger"
				},
				addfile: {
					previewTemplate: O2config.templates.field.addfilePreview,
					previewAppendTo: 'descendant::.o2-list__items',
					previewConstant: 'Nahrávám soubor'
				},
				simplelist: {
					activeClass: 'o2-list--active',
					inactiveClass: false,
					emptyAdded: 'descendant::*[name="simpleListVal"]',
					addTemplate: O2config.templates.field.simplelistAdd,
					addAppendTo: 'descendant::.o2-list__items',
					addRequire: '*[name="simpleListVal"]',
					joiner: ' | ',
					removeTarget: 'closest::.o2-list__item',
					submit: 'self'
				},
				dialogSimplelist: {
					emptyAdded: 'descendant::*[name="simpleListVal"]',
					addTemplate: O2config.templates.field.dialogSimplelistAdd,
					addAppendTo: 'descendant::.o2-list__items',
					addRequire: 'input[name="simpleListVal"]',
					joiner: ' | ',
					removeTarget: 'closest::.o2-list__item',
					submit: 'self'
				},
				subheader: { // DEPRECATED
					activeClass: 'o2-subheader__title--active',
					target: 'descendant::.o2-subheader__title',
					submit: 'self',
					replace: true
				}
			},

			scanDom: function() {
				this.scanElems();
				this.prepareSet();
			},

			scanElems: function() {

				var $elm = this.$elm,
					textTarget = this.textTarget,
					classTarget = this.classTarget,
					editContent = this.editContent,
					viewContent = this.viewContent,
					autofocus = this.autofocus;

				this.$textTarget  = (textTarget  ? O2util.queryPath($elm, textTarget)  : $());
				this.$editContent = (editContent ? O2util.queryPath($elm, editContent) : $());
				this.$viewContent = (viewContent ? O2util.queryPath($elm, viewContent) : $());
				this.$classTarget = (classTarget ? O2util.queryPath($elm, classTarget) : $elm),
				this.$autofocus   = (
					autofocus === true ?
					$elm.find('input,textarea,select').eq(0) :
					(autofocus ? $elm.find(autofocus) : $())
				);

				this.markRelatedElements($elm.find('.js-field-edit,.js-field-confirm,.js-field-update,.js-field-cancel,.js-field-add,.js-field-remove'));
			},

			render: function() {
				$('.js-field-redundant').hide();

				// Fix deprecated classy "o2-list--editing", bez toho by nefungoval fileuplaod a další
				// již hotové obrazovky, které se spoléhají na starou metodu práce s view/edit módy o2-list.
				if (this.$classTarget.hasClass('o2-list--editing'))
					this.$classTarget.removeClass('o2-list--editing').addClass('o2-list--active');

				// Fix deprecated classy "o2-field--editable-active", bez toho by nefungovaly žádné fieldy,
				// které se spoléhají na starou metodu práce s view/edit módy o2-field.
				if (this.$classTarget.hasClass('o2-field--editable-active'))
					this.$classTarget.removeClass('o2-field--editable-active').addClass('o2-field--active');

				if (this.editMode || this.$classTarget.hasClass(this.activeClass)) {
					this.$editContent.show();
					this.$viewContent.hide();
					this.$classTarget.addClass(this.activeClass);
					this.$classTarget.removeClass(this.inactiveClass);
				} else {
					this.$viewContent.show();
					this.$editContent.hide();
					this.$classTarget.addClass(this.inactiveClass);
					this.$classTarget.removeClass(this.activeClass);
				}
			},

			renderEdit: function(evt) {

				this.editMode = true;

				if (this.options.restoreOnCancel || this.options.restoreOnSave) {
					this.storeVals();
				}

				if (this.inactiveClass) {
					this.$classTarget.removeClass(this.inactiveClass);
				}
				if (this.activeClass) {
					this.$classTarget.addClass(this.activeClass);
				}
				if (this.editText) {
					this.$textTarget.text(this.editText);
				}
				this.$viewContent.hide();
				this.$editContent.show();

				if (this.$autofocus.length) {
					this.$autofocus[0].focus();
				}
				if (this.singleActive && this.set) {
					this.othersInSet(this.renderView);
				}
				if (this.allActive && this.set) {
					this.othersInSet(this.renderEdit);
				}
				if (this.options.autoselect) {
					this.$autofocus.select();
				}
				this.$elm.trigger('shown.o2util');

				if (evt) {
					evt.preventDefault();
					evt.stopImmediatePropagation();
				}
			},

			renderView: function(evt) {

				this.editMode = false;

				if (this.options.restoreOnCancel || this.options.restoreOnSave) {
					this.restoreVals();
				}

				if (this.activeClass) {
					this.$classTarget.removeClass(this.activeClass);
				}
				if (this.inactiveClass) {
					this.$classTarget.addClass(this.inactiveClass);
				}
				if (this.viewText) {
					this.$textTarget.text(this.viewText);
				}
				this.$editContent.hide();
				this.$viewContent.show();

				if (this.allActive && this.set) {
					this.othersInSet(this.renderView);
				}

				this.$elm.trigger('shown.o2util');

				if (evt) {
					evt.preventDefault();
					evt.stopImmediatePropagation();
				}
			},

			add: function(evt, trigger) {

				var tpl        = this.addTemplate,
				    $appendTo  = O2util.queryPath(this.$elm, this.options.addAppendTo),
				    addRequire = this.options.addRequire,
				    $form      = $(trigger).closest('form');

				evt.preventDefault();

				if (addRequire) {
					var $reqiredFields = (this.options.submit == 'self' ? this.$elm : $form).find(addRequire);

					// Provede validaci, pokud je js-validation, nepusí dál, dokud není zvalidováno
					if (O2widget && O2widget.classes && O2widget.classes.validation) { // existuje widget js-validation?
						var $validatedFields = $reqiredFields.filter(O2widget.resolveWidgetSelector('validation')); // vyfiltruj pole s validací
						var hasError = false;
						$validatedFields.each(function(){
							var validation = O2widget.getInstance('validation', this);
							if (validation.validateField() === 'error') // validuj errory
								hasError = true;

						});

						if (hasError)
							return false;
					}

					if ($reqiredFields.filter(function() { return !$(this).val(); }).length) {
						return;
					}
				}

				if (!tpl) {
					tpl = this.addTemplate = this.options.addTemplate;
					Mustache.parse(tpl);
				}

				var data = {},
					formData = (
						this.options.submit == 'self' ?
						this.$elm.find('input,textarea,select').serializeArray():
						$form.serializeArray()
					),
					arrays = {};

				data.arrays = arrays;

				for (var i = 0, item; item = formData[i++]; ) {
					data[item.name] = item.value;
					if ('undefined' == typeof arrays[item.name]) {
						arrays[item.name] = [];
					}
					arrays[item.name].push(new String(item.value));
				}

				for (var k in arrays) {
					var a = arrays[k];
					a[a.length - 1].last = true;
				}

				data.options = this.options;
				var $c = $(Mustache.render(tpl, data));

				$c.appendTo($appendTo);
				this.markRelatedElements($c.find('.js-field-edit,.js-field-confirm,.js-field-update,.js-field-cancel,.js-field-add,.js-field-remove'));

				if (this.options.emptyAdded && !this.options.keepInput) {  //vymaze vstupni pole
					var $elementsToEmpty = O2util.queryPath(this.$elm, this.options.emptyAdded);
					$elementsToEmpty.filter(':not(select)').val('').trigger('change', { isFieldEmptying: true });
					$elementsToEmpty.filter('select').prop('selectedIndex', 0).trigger('change', { isFieldEmptying: true });
				}
			},

			inputCleanup: function() {
				if (this.options.emptyUpdated && !this.options.keepInput) { //vymaze vstupni pole
					var $elementsToEmpty = O2util.queryPath(this.$elm, this.options.emptyUpdated);
					$elementsToEmpty.filter(':not(select)').val('').trigger('change', { isFieldEmptying: true });
					$elementsToEmpty.filter('select').prop('selectedIndex', 0).trigger('change', { isFieldEmptying: true });
				}
			},

			remove: function(evt, trigger) {
				var o = $.extend({}, this.options),
					$trigger = $(trigger),
					profile = $trigger.data(this.widgetName + '-profile');

				if (profile) {
					o = $.extend(o, this.profileOptions[profile]);
				}
				evt.preventDefault();

				var $t = O2util.queryPath($trigger, o.removeTarget);
				$t.remove();
			},

			storeVals: function() {
				this.hasStoredVals = true;
				this.$elm.find('input,select,textarea').each(function() {
					var $e = $(this),
						v;
					if ($e.is('input[type="checkbox"],input[type="radio"]')) {
						v = $e.prop('checked');
					} else {
						v = $e.val();
					}
					$e.data('field-stored-val', v);
				});
			},

			restoreVals: function() {
				if (!this.hasStoredVals) {
					return;
				}
				this.hasStoredVals = false;
				this.$elm.find('input,select,textarea').each(function() {
					var $e = $(this),
						v = $e.data('field-stored-val');
					if ($e.is('input[type="checkbox"],input[type="radio"]')) {
						if ($e.prop('checked') != v)
							$e.prop('checked', v).trigger('change');
					} else {
						if ($e.val() != v)
							$e.val(v).trigger('change');
					}
				});
			},

			resetVals: function() {
				this.hasStoredVals = false;
			},

			save: function(evt, trigger, data) {
				evt.preventDefault();
				if (data && data.isFieldEmptying) // Change byl odpálen vyprázdněním polí po předchozím updatu.
					return;

				var me = this;
				this.prepareToSave(trigger);

				O2ajax.asyncUpdate(this, evt, trigger, {}, function() {
					me.scanElems();
					me.inputCleanup();
				});
			},

			saveAndExit: function(evt, trigger, data) {
				evt.preventDefault();
				if (data && data.isFieldEmptying) // Change byl odpálen vyprázdněním polí po předchozím updatu.
					return;

				var me = this;
				this.prepareToSave(trigger);

				O2ajax.asyncUpdate(this, evt, trigger, {}, function() {
					me.scanElems();
					me.inputCleanup();
					me.renderView();
				});
			},

			prepareToSave: function(trigger) {
				var $trigger = $(trigger),
				    profile  = $trigger.data(this.widgetName + '-profile');

				if (profile === 'addfile') // Pokud je triggerem změněný profil.
					this.isFileUpload = true; // Říká o2ajaxu, že jde o fileUpload widget.

				if (!this.options.restoreOnSave)
					this.resetVals();
			}
		}
	);
})(jQuery);

(function($) {
	O2widget.createClass(

		'update',

		function(elm, options) {
			this.init(elm, options, [
				'watchChange',
				'watchKeyup',
				'keyPause',
				'clickable',
				'enterable',
				'loadOnStart',
				'period'
			]);
		},

		{
			delegate: function() {
				this
					.handle('submit', 'form.js-update', 'handleUpdate')
					.handle('change', 'input.js-update,textarea.js-update,select.js-update', 'handleChange')
					.handle('keyup', 'input.js-update-keyup,textarea.js-update-keyup,select.js-update-keyup', 'handleKeyup')
					.handle('click', 'a.js-update,button.js-update', 'handleUpdate')
					.handleRelated('keydown', 'input.js-update-keydown', 'handleKeydown')
					.handleRelated('submit', 'form.js-update-form', 'checkSubmit')
					.handleRelated('click', 'a.js-update-trigger,button.js-update-trigger', 'handleUpdate')
					.handleRelated('change', 'input.js-update-trigger,textarea.js-update-trigger,select.js-update-trigger', 'handleChange')
					.handleRelated('keyup', 'input.js-update-keyup-trigger,textarea.js-update-keyup-trigger,select.js-update-keyup-trigger', 'handleKeyup');
			}
		},

		{
			defaultOptions: {
				submit: 'self',
				replace: true,
				watchContent: true,
				keyPause: 500,
				waitForSubmit: 50,
				watchChange: false,
				watchKeyup: false,
				clickable: false,
				enterable: false,
				loadOnStart: false,
				loadOnView: false,
				period: 0,
				viewOffset: 250
			},

			profileOptions: {
				pseudoform: {
					submit: "self",
					clickable: "descendant::button",
					enterable: "descendant::input",
					method: "POST"
				},

				cart: {
					target: "self::*",
					indicator: "self::*",
					replace: true,
					submit: "trigger",
					watchChange: true,
					clickable: "descendant::.js-update-cart-close"
				},

				autoupdate: {
					target: 'self::*',
					indicator: 'self::*',
					replace: false,
					loadOnStart: true
				},

				keepUpToDate: {
					target: 'self::*',
					submit: 'trigger',
					replace: true,
					watchContent: true,
					watchContentPath: 'closest:::not(a)',
					period: 5000
				},

				tableOrdering: {
					target: 'closest::.js-update-table-ordering',
					indicator: 'closest::.js-update-table-ordering',
					indicatorClass: 'o2-loader--overlay-table',
					submit: 'trigger',
					replace: true,
					method: 'GET'
				},

				tableOrderingMobile: {
					target: 'closest::.js-update-table-ordering',
					indicator: 'closest::.js-update-table-ordering',
					indicatorClass: 'o2-loader--overlay-table',
					submit: 'self',
					replace: true,
					method: 'GET',
					watchChange: true
				},

				responseDriven: {
					target: 'empty::*',
					replace: true,
					method: 'POST'
				}
			},

			keyTimeout: null,
			periodInterval: null,
			$parentForm: null,

			scanDom: function() {

				var $elm = this.$elm;

				if (this.watchChange) {

					var $protected = $elm.find('.js-update-protected'),
						$omitted = $protected.find('input,select,textarea'),
						$ls = $elm.find('input,select,textarea').not($protected).not($omitted);

					this.markRelatedElements($ls, 'js-update-trigger');
				}

				if (this.watchKeyup) {
					if ($elm.is('input,select,textarea')) {
						$elm.addClass('js-update-keyup');
					} else {
						this.markRelatedElements($elm.find('input,select,textarea'), 'js-update-keyup-trigger');
					}
				}

				if (this.clickable) {
					var $clickableElements = O2util.queryPath($elm, this.clickable);
					this.markRelatedElements($clickableElements, 'js-update-trigger');
					$clickableElements.each(function(){
						$(this).data('update-last-value', $(this).val());
					});
				}

				if (this.enterable) {
					var $enterableElements = O2util.queryPath($elm, this.enterable);
					this.markRelatedElements(O2util.queryPath($elm, this.enterable), 'js-update-keydown');
					$enterableElements.each(function(){
						$(this).data('update-last-value', $(this).val());
					});
				}

				// Pokud má widget nadřazený form, označíme ho, abychom měli kontrolu nad běžným submitem.
				var $maybeForm = $elm.closest('form');
				if ($maybeForm.length === 1) {
					this.markRelatedElements($maybeForm, 'js-update-form');
					this.$parentForm = $maybeForm;
				}
			},

			bind: function() {
				if (this.options.loadOnView) {
					var me = this;
					this.$scrollParent = this.$elm.scrollParent();
					if (this.$scrollParent.is(document))
						this.$scrollParent = $(window);

					this.$scrollParent.on('scroll.' + this.uuid, $.throttle(200, $.proxy(this.loadOnViewHandler, me)));
					this.loadOnViewHandler();
				}
			},

			unbind: function() {
				if (this.options.loadOnView) {
					this.$scrollParent.off('scroll.' + this.uuid);
				}
			},

			render: function() {
				if (this.loadOnStart) {
					this.handleUpdate();
				}

				$('.js-update-redundant').hide();

				if (this.period > 0) {
					if (this.periodInterval) {
						window.clearInterval(this.periodInterval);
					}
					var me = this;
					this.periodInterval = window.setInterval(function() {
						me.handleUpdate();
					}, this.period);
				}
			},

			unrender: function() {
				if (this.period && this.periodInterval) {
					window.clearInterval(this.periodInterval);
					this.periodInterval = false;
				}
				return true;
			},

			handleUpdate: function(evt, trigger, data) {
				if (this.$parentForm && this.$parentForm.data('update-submit-in-progress'))
					return;

				// Má-li navázaný konfirmační modál, prověří, zda už byla akce potvrzena v modálu.
				if (trigger && O2widget.getInstance("modal", $(trigger))) {
					var modalInstance = O2widget.getInstance("modal", $(trigger));

					console.log(modalInstance.$elm.data("modalConfirmState"));
					if (!modalInstance.disabled && modalInstance.$elm.data("modalConfirmState") !== true)
						return;
				}

				var $maybeForm = $(trigger && (trigger.form || trigger)),
					me = this,
					waitForSubmit = this.options.waitForSubmit;

				// Jde-li o submit formu, můžeme zpozdit provedení ajaxu.
				if ($maybeForm.is('form') && waitForSubmit) {
					evt.preventDefault();
					window.setTimeout(function() {
						if (!evt.validationError) { // set in validation.js
							me.execUpdate(evt, trigger, data);
						} else
							me.$elm.data('update-submit-in-progress', false);
					}, waitForSubmit);
				} else {
					this.execUpdate(evt, trigger, data);
				}
			},

			execUpdate: function(evt, trigger, data) {
				var me = this;
				O2ajax.asyncUpdate(this, evt, trigger, {}, function(isError){
					if (isError) { // Pokud je chyba v ajaxu, zrušíme period, aby nenaskákala miliarda chyb.
						me.options.period = false;
						window.clearInterval(me.periodInterval);
					}
					if (me.$elm.is('form'))
						me.$elm.data('update-submit-in-progress', false);

					var modalInstance = O2widget.getInstance("modal", me.$elm);
					if (modalInstance && !modalInstance.disabled) {
						modalInstance.$elm.data("modalConfirmState", false);
					}
				});
				if (this.options.modalContinue) {
					$.magnificPopup.close();
				}
			},

			// Zabraňuje, během probíhajícího submitu, dalším ajaxovým voláním uvnitř formu.
			checkSubmit: function(evt, trigger, data) {
				this.$parentForm.data('update-submit-in-progress', true);
			},

			handleChange: function(evt, trigger, data) {
				if (this.$parentForm && this.$parentForm.data('update-submit-in-progress'))
					return;

				var $trigger = (trigger && $(trigger)),
				    currentValue = $trigger.val(),
					lastValue = $trigger.data('update-last-value');

				if (!$trigger.is(':checkbox, :radio') && (currentValue == lastValue)) {
					return;
				}
				$trigger.data('update-last-value', currentValue);

				this.handleUpdate(evt, trigger, data);
			},

			handleKeydown: function(evt, trigger, data) {
				if (evt.which == 13) { // Enter key
					evt.preventDefault();
					this.handleUpdate(evt, trigger, data);
				}
			},

			handleKeyup: function(evt, trigger, data) {
				var $trigger = $(trigger),
					minlen = $trigger.data('update-minlen') || 3,
					value = $trigger.val() || '',
					me = this;

				if (minlen == 0 || (value.length && value.length >= minlen)) {
					if (this.keyTimeout) {
						window.clearTimeout(this.keyTimeout);
					}
					this.keyTimeout = window.setTimeout(function() {
						me.keyTimeout = null;
						$trigger.data('update-last-value', value);
						me.handleUpdate(evt, trigger, data);
					}, this.keyPause);
				}
			},

			loadOnViewHandler: function() {
				if (O2util.scrolledToElement(this.$elm, this.options.viewOffset, this.$scrollParent)) {
					this.$scrollParent.off('scroll.' + this.uuid);
					this.handleUpdate();
				}
			}
		}
	);
})(jQuery);


(function($) {
	O2widget.createClass(

		'coupled',

		function(elm, options) {
			this.init(elm, options, [
				'target',
				'master'
			]);
		},

		{
			delegate: function() {
				this
					.handle('change keyup', '.js-coupled', 'handlePush')
					.handleRelated('change keyup', '.js-coupled-target', 'handlePull');
			}
		},

		{
			defaultOptions: {
				master: 'last',
				submit: 'form',
				round: 0,
				ignoreFocus: false
			},

			profileOptions: {
				"jsonInput": {
					master: "me",
					ajax: "json",
					method: "get",
					validationClass: { "warning": "o2-control__validation--warning", "error": "o2-control__validation--error" },
					msgPath: "closest-next::.o2-control__validation"
				}
			},

			scanDom: function() {

				var targets = this.target.split('|'),
					$targets = this.$targets = [],
					$targetsFlat = $(),
					$elm = this.$elm,
					options = this.options;

				for (var i = 0, t; t = targets[i++]; ) {
					var $t = O2util.queryPath($elm, t);
					$targets.push($t);
					$targetsFlat = $targetsFlat.add($t);
				}
				this.$targetsFlat = $targetsFlat;

				this.op = 'copy';
				for (var ops = [
					'multiplyBy',
					'ajax'
				], i = 0, op; op = ops[i++]; ) {
					if (options[op]) {
						this.op = op;
						break;
					}
				}

				this.allowKeyup = options.allowKeyup || (this.op != 'ajax');
				this.initSync = (('undefined' == typeof options.initSync) ? this.op != 'ajax' : options.initSync);
			},

			render: function() {

				var $elm = this.$elm;
				if ($elm.data('coupled-keep-initial') || $elm.data('coupled-keep')) {
					$elm.data('coupled-initial', $elm.attr('value'));
				}

				for (var i = 0, $t; $t = this.$targets[i++]; ) {
					if ($t.data('coupled-keep-initial') || $t.data('coupled-keep')) {
						$t.data('coupled-initial', $t.attr('value'));
					}
					this.markRelatedElements($t, 'js-coupled-target');
				}

				if (this.initSync) {
					if (this.master == 'target') {
						this.pullValue();
					} else { // 'me' and 'last'
						this.pushValue();
					}
				}
			},

			/**
			 * Applies a numeric operation to the value. The value is represented by a string,
			 * so the input must be parsed first and the output must be rounded at the end.
			 *
			 * @param numStr    string representation of the input number
			 * @param operation single argument function accepting a number and returning a number
			 * @param round     number of decimal points required for the output
			 * @param $tgt      element to set the value to
			 */
			applyNumericOperation: function(numStr, operation, round, $tgt) {

				var num,
				    val,
				    valStr;

				if (numStr) {
					try {
						num = parseFloat(numStr);
						val = operation(num);
						switch (true) {
						case round == 0:
							valStr = Math.round(val) + '';
							break;
						case round < 0:
							var f = Math.pow(10, -round);
							valStr = Math.round(val / f) * f + '';
							break;
						case round > 0:
							var f = Math.pow(10, round);
							val = val / f;
							valStr = val.toFixed(round);
							break;
						}
						this.changeIfAllowed($tgt, valStr);
					} catch(e) {
						this.changeIfAllowed($tgt, '');
					}
				} else {
					this.changeIfAllowed($tgt, '');
				}
			},

			/**
			 * Use AJAX to get an related values. All related inputs are updated.
			 */
			ajax: function(algorithm, trigger) {

				var form = this.$elm[0].form,
					$form = $(form),
					options = this.options,
					url = options.url || $form.attr('action'),
					method = (options.method || $form.attr('method') || 'GET').toUpperCase(),
					me = this,
					data = {};

				switch (options.submit) {
				case 'form':
					data = $form.serialize();
					break;
				case 'self':
					data = this.$targetsFlat.add(this.$elm).serialize();
					break;
				case 'trigger':
					data = $(trigger).serialize();
					break;
				}

				$.ajax({
					url: url,
					method: method,
					data: data,
					success: function(response) {
						switch (algorithm) {
						case 'html':
							me.updateFromHtml($(response), trigger);
							break;
						case 'json':
							me.updateFromJson(response, trigger);
							break;
						}
					}
				});
			},

			/**
			 * Utility method: updates all related elements from an HTML snippet.
			 *
			 * @param $snippet HTML fragment (typically: AJAX response) containing the
			 *                 form representation
			 */
			updateFromHtml: function($snippet, preserve) {

				var $ls = this.$targets;
				$ls.push(this.$elm);

				for (var i = 0, $t; $t = $ls[i++]; ) {
					var isFocus = true;
					if (this.options.ignoreFocus == false)
						isFocus = (!$t.is(':focus') || !$t.val());

					if (isFocus && $t[0] !== preserve) {
						var name = $t.attr('name');
						if (!name) {
							continue;
						}
						var $r = $snippet.find('[name="' + name + '"]');
						if (!$r.length) {
							continue;
						}
						this.changeIfAllowed($t, $r.val());
					}
				}
			},

			/**
			 * Utility method: updates all related elements from a JSON.
			 */
			updateFromJson: function(data, preserve) {

				var $ls = this.$targets;
				$ls.push(this.$elm);
				try {
					data = JSON.parse(data);
				} catch (e) {
					console.log(e);
				}

				for (var i = 0, $t; $t = $ls[i++]; ) {
					var isFocus = true;
					if (this.options.ignoreFocus == false)
						isFocus = (!$t.is(':focus') || !$t.val());

					if (isFocus && $t[0] !== preserve) {
						var name = $t.data('coupled-alias') || $t.attr('name');
						if (!name) {
							continue;
						}
						if ('undefined' == typeof data[name]) {
							continue;
						}
						var v = data[name];
						this.changeIfAllowed($t, v);
					}
				}

				var error;
				if ('undefined' == typeof data._error) {
					error = {};
				} else {
					error = data._error;
				}

				this.updateValidations(error);
			},

			/**
			 * Utility method: updates validation messages from an error object.
			 */
			updateValidations: function(error) {

				var $ls = this.$targets;
					$ls.push(this.$elm),
					errArray = $.isArray(error);

				for (var i = 0, $t; $t = $ls[i++]; ) {

					var name = $t.data('coupled-alias') || $t.attr('name'),
						validationClass = $t.data('coupled-validation-class') || this.options.validationClass,
						c,
						$msg;

					if (!name) {
						continue;
					}
					$msg = O2util.queryPath($t, this.options.msgPath);
					for (var k in validationClass) {
						c = validationClass[k];
						$t.removeClass(c);
						$msg.removeClass(c);
					}
					if ($msg && $msg.length) {
						$msg.empty();
					}
					if (errArray || 'undefined' == typeof error[name]) {
						continue;
					}

					var e = error[name];
					if (e) {
						if (e.status && (c = validationClass[e.status])) {
							$t.addClass(c);
							$msg.addClass(c);
						}
						if (e.message) {
							$msg.text(e.message);
						}
					}
				}

				if (errArray) {
					for (var i = 0, l = error.length; i < l; i++) {
						var e = error[i],
							$t = $('#' + e.field),
							validationClass = $t.data('coupled-validation-class') || this.options.validationClass,
							c,
							$msg = O2util.queryPath($t, this.options.msgPath);

						if (e.status && (c = validationClass[e.status])) {
							$t.addClass(c);
							$msg.addClass(c);
						}
						if (e.message) {
							$msg.text(e.message);
						}
					}
				}
			},

			/**
			 * Propagates the value from the source element to the target element(s).
			 */
			pushValue: function(trigger) {

				var options = this.options,
					$elm = this.$elm;

				switch (this.op) {
				case 'multiplyBy':
					for (var i = 0, $target; $target = this.$targets[i++]; ) {
						this.applyNumericOperation($elm.val(), function(x) {
							return x * Math.pow(10, options.round) * options.multiplyBy;
						}, options.round, $target);
					}
					break;
				case 'ajax':
					this.ajax(options.ajax, trigger);
					break;
				default:
					for (var i = 0, $target; $target = this.$targets[i++]; ) {
						this.changeIfAllowed($target, $elm.val());
					}
				}
			},

			/**
			 * Propagates the value from the target element(s) back to the source element.
			 * In case the action was triggered by a target, this target is source of the value;
			 * otherwise the first target element is the source of the value.
			 */
			pullValue: function(trigger) {

				var options = this.options,
					$target = (trigger ? $(trigger) : this.$targets[0]),
					$elm = this.$elm;

				switch (this.op) {
				case 'multiplyBy':
					this.applyNumericOperation($target.val(), function(x) {
						return x * Math.pow(10, options.round) / options.multiplyBy;
					}, options.round, $elm);
					break;
				case 'ajax':
					this.ajax(options.ajax, trigger);
					break;
				default:
					this.changeIfAllowed($elm, $target.val());
				}
			},

			/**
			 * Utility method to change the value of an input. The change might be prevented by the
			 * `keepChanged` or `keepInitial` options.
			 * The change is executed only if the new value does not equal the current value.
			 * Triggers the change event in case the value has been modified.
			 *
			 * @param $tgt the input element
			 * @param val  the new value to be set
			 */
			changeIfAllowed: function($tgt, val) {

				var origVal = $tgt.val();

				// If initial value has to be kept and the current value equals initial
				// value do nothing:

				if ($tgt.data('coupled-initial') == origVal) {
					return;
				}

				// If the value changed manually by user has to be kept and it has been
				// changed do nothing:

				if ($tgt.data('coupled-changed')) {
					return;
				}

				// I the current value would not be changed do nothing:

				if (origVal == val) {
					return;
				}

				$tgt.val(val);
				$tgt.trigger('change', {
					sourceUuid: this.uuid,
					widgetName: this.widgetName,
					ignoreSubsequent: this.options.ignoreSubsequent || false
				});
			},

			/**
			 * Handles possible push events.
			 *
			 * @param evt     jQuery event object
			 * @param trigger trigger element
			 * @param data    event data
			 */
			handlePush: function(evt, trigger, data) {
				if (data && data.ignoreSubsequent) { // coupled byl spuštěn předchozím coupled a chceme tedy tento další ignorovat
					return;
				}

				if (this.isRecursion(data)) {
					return;
				}
				if (!data || !data.sourceUuid) {
					var $this = $(trigger);
					if ($this.data('coupled-keep-changed') || $this.data('coupled-keep')) {
						$this.data('coupled-changed', true);
					}
				}
				if (
					(evt.type != 'keyup' || this.allowKeyup) &&
					this.master != 'target' // 'me' and 'last'
				) {
					this.pushValue(trigger);
				}
			},

			/**
			 * Handles possible pull events.
			 *
			 * @param evt     jQuery event object
			 * @param trigger trigger element
			 * @param data    event data
			 */
			handlePull: function(evt, trigger, data) {
				if (this.isRecursion(data)) {
					return;
				}
				if (!data || !data.sourceUuid) {
					var $this = $(trigger);
					if ($this.data('coupled-keep-changed') || $this.data('coupled-keep')) {
						$this.data('coupled-changed', true);
					}
				}
				if (
					(evt.type != 'keyup' || this.allowKeyup) &&
					this.master != 'me' // 'target' and 'last'
				) {
					this.pullValue(trigger);
				}
			}
		}
	);
})(jQuery);

(function($) {

	var storeDefault = function() {
		var $this = $(this);
		$this.data('disable-default', $this.prop(this.type));
	};

	var restoreDefault = function() {
		var $this = $(this);
		$this.prop(this.type, $this.data('disable-default'));
	};

	O2widget.createClass(

		'disable',

		function(elm, options) {
			this.init(elm, options, [
				'onActive',
				'onInactive'
			]);
		},

		{
			delegate: function() {
				this.handle('change', 'input[type="checkbox"].js-disable, input[type="radio"].js-disable', 'handleChange');
				this.handle('input', 'input.js-disable, textarea.js-disable', 'handleInput');
			}
		},

		{
			defaultOptions: {
				onActive: undefined,
				onInactive: undefined,
				type: "disabled"
			},

			$onActive: $(),   // všechny elementy, které se mají disablovat, pokud je element "aktivní"
			$onInactive: $(), // všechny elementy, které se mají disablovat, pokud je element "neaktivní"

			scanDom: function() {
				var $elm = this.$elm,
					onActive = this.onActive,
					onInactive = this.onInactive;

				if (onActive) {
					this.$onActive = O2util.queryPath($elm, onActive);
				}
				if (onInactive) {
					this.$onInactive = O2util.queryPath($elm, onInactive);
				}
			},

			render: function() {
				if (this.options.type !== "disabled" || this.options.type !== "readonly")
					this.type = "disabled";
				else
					this.type = this.options.type;

				this.$onActive.each(storeDefault);
				this.$onInactive.each(storeDefault);

				if (this.$elm.prop('tagName') == "INPUT") {
					if (this.$elm.prop('type') == "checkbox" || this.$elm.prop('type') == "radio")
						this.handleChange();
					else // type=text|number|email|time|...
						this.handleInput();
				} else // textarea
					this.handleInput();
			},

			unrender: function() {
				this.$onInactive.each(restoreDefault);
				this.$onActive.each(restoreDefault);
			},

			// Při změně checkboxu, radiobuttonu
			handleChange: function() {
				var active = this.$elm.is(':checked');
				this.$onActive.prop(this.type, active);
				this.$onInactive.prop(this.type, !active);

			},

			// Při změně hodnoty inputu, textarea
			handleInput: function() {
				var empty = this.$elm.val().length === 0;
				this.$onActive.prop(this.type, !empty);
				this.$onInactive.prop(this.type, empty);
			}
		}
	);

})(jQuery);

(function($) {
	O2widget.createClass(

		'notify',

		function(elm, options) {
			this.init(elm, options, [
				'url',
				'method',
				'indicator',
				'indicatorText',
				'message',
				'messageAutoclose',
				'messageSeverity',
				'control',
				'timespan',
				'speed'
			]);
		},

		{
			delegate: function() {
				this
					.handle('submit', 'form.js-notify', 'handleSubmit')
					.handle('click',  'a.js-notify',    'handleSubmit');
			}
		},

		{
			defaultOptions: {
				messageSeverity: 'success',
				messageAutoclose: 0,
				timespan: false,
				speed: 0
			},

			scanDom: function() {
				var $elm = this.$elm,
					indicator = this.indicator,
					control = this.control;

				this.$indicator = O2util.queryPath($elm, indicator) || $();
				this.$control = control ? (O2util.queryPath($elm, control) || $()) : $elm;
				this.method = this.method || O2util.deriveMethod($elm);
				this.url = this.url || O2util.deriveUrl($elm);
			},

			render: function() {
				$('.js-notify-redundant').hide();
				this.$indicator.hide();
			},

			handleSubmit: function(evt) {

				var data = O2util.collectData(this.$elm, evt),
					me = this,
					speed = this.speed;

				evt.preventDefault();

				$.ajax({
					method: this.method,
					url: this.url,
					data: data,
					error: function(jqXHR, textStatus, errorThrown) {
						// timeout a parse error se nereportuje
						if (textStatus && (textStatus == "error" || textStatus == "abort")) {
							if (O2config.getInformationMessagesURL) {
								window.O2widget.classes.sysmsg.kahl(O2config.getInformationMessagesURL, {
									msgid: "ID0941",
									timestamp: Date.now(),
									sourceid: "Theme - o2notify.js",
									exceptParams: ""
								});
							} else
								me.reportError('user', 'V aplikaci došlo k chybě. Vyzkoušejte zopakovat akci později.');
						}
					}
				});

				if (this.indicatorText) {
					this.$indicator.text(this.indicatorText);
				}
				this.$indicator.show(speed);
				this.$control.hide(speed);

				if (this.timespan) {
					window.setTimeout(function() {
						me.$indicator.hide(speed);
						me.$control.show(speed);
					}, this.timespan);
				}

				if (this.message)
					window.O2widget.classes.sysmsg.showMessage([
						{
							"text": this.message,
							"textInternal": "",
							"severity": this.messageSeverity,
							"isInternal": false,
							"closeBtn": true,
							"autoClose": this.messageAutoclose,
							"messageId": "dsNotify"
						}
					]);
			}
		}
	);
})(jQuery);


(function($) {
	O2widget.createClass(

		'filter',

		function(elm, options) {
			this.init(elm, options, [
				'partial',
				'replace',
				'url',
				'method',
				'history',
				'interval',
				'keyPause',
				'target',
				'indicator',
				'loadOnStart',
				'waitForReset'
			]);
		},

		{
			delegate: function() {
				this
					.handle('change', 'form.js-filter', 'handleChange')
					.handle('submit', 'form.js-filter', 'handleSubmit')
					.handleRelated('keyup', 'input.js-filter-keyup,textarea.js-filter-keyup', 'handleKeyup')
					.handleRelated('click', '.js-filter-reset', 'handleReset');
			}
		},

		{
			defaultOptions: {
				interval: 1000,
				keyPause: 500,
				allowOverwriteAjax: true
			},

			scanDom: function() {

				var $elm = this.$elm,
					me = this;

				if (!this.options.indicator)
					this.options.indicator = this.options.target;

				var $keyup = $elm.find('.js-filter-keyup');
				this.markRelatedElements($keyup);
				$keyup.each(function() {
					var $k = $(this),
						resetPath = $k.data('filter-reset');
					if (resetPath) {
						var $reset = O2util.queryPath($k, resetPath);
						if ($reset && $reset.length) {
							me.markRelatedElements($reset, 'js-filter-reset');
							$reset.data('filter-reset-target', $k);
							$reset.hide();
							me.inputHiding($k, $reset);
						}
					}
				});
			},

			render: function() {

				$('.js-filter-redundant').hide();

				if (this.loadOnStart) {
					this.handleChange();
				}
			},

			keyTimeout: null,
			lastData: null,

			handleChange: function(evt, trigger) {
				if (trigger) {
					var $trigger = $(trigger);
					if ($trigger.hasClass('js-filter-protected') || $trigger.closest('.js-filter-protected').length > 0)
						return; // Nic nedělá, pokud je trigger (input) uvnitř protected.
				}

				var data = O2util.collectData(this.$elm, evt);
				if (data == this.lastData) // TODO: tohle porovnání se mi nějak nezdá, potenciální bug.
					return;
				else
					this.lastData = data;

				if (this.history && window.history && history.pushState) {
					var historyUrl = O2util.joinUrl(this.url, data);
					history.pushState({}, document.title, historyUrl);
				}

				O2ajax.asyncUpdate(this, evt, trigger);
			},

			handleSubmit: function(evt, trigger) {
				evt.preventDefault();
				this.handleChange(evt, trigger);
			},

			handleReset: function(evt, trigger) {
				evt.preventDefault();
				evt.stopPropagation();
				var $trigger = trigger && $(trigger);

				if ($trigger && $trigger.length) {
					var $input = $trigger.data('filter-reset-target');
					if ($input && $input.length) {
						$input.val('');
						$trigger.hide();
						$input.trigger("change");
					}
				}
			},

			handleKeyup: function(evt, trigger) {
				var $input = $(trigger),
					minlen = $input.data('filter-minlen'),
					v = $input.val() || '',
					me = this;

				if ('undefined' == typeof minlen) {
					minlen = 3;
				}

				if (minlen == 0 || (v.length && v.length >= minlen)) {
					if (this.keyTimeout) {
						window.clearTimeout(this.keyTimeout);
					}
					this.keyTimeout = window.setTimeout(function() {
						me.keyTimeout = null;
						me.handleChange(evt, trigger);
					}, this.keyPause);
				}
			},

			inputHiding: function($input, $button) {
				$input.on('input', function(){ // při změně inputu schová/zobrazí reset tlačítko
					if ($input.val() == '')
						$button.hide();
					else
						$button.show();
				});
			}
		}
	);
})(jQuery);

(function($) {
	O2widget.createClass(

		'checkboxgroup',

		function(elm, options) {
			this.init(elm, options, [
				'masterSwitch',
				'semiClass',
				'semiChecked'
			]);
		},

		{
			delegate: function() {
				this.handle('input change', 'input[type="checkbox"].js-checkboxgroup', 'handleMasterChange');
				this.handleRelated('input change', 'input[type="checkbox"].js-checkboxgroup-related', 'handleSlaveChange');
			}
		},

		{
			defaultOptions: {
				masterSwitch: true,
				semiClass: 'o2-control__custom-checkbox--square',
				semiTarget: 'closest::.o2-control__custom-checkbox',
				semiChecked: true,
				serialize: false
			},

			scanDom: function() {

				var $elm = this.$elm,
				    semiTarget = this.options.semiTarget,
				    slaves = this.options.slaves;

				if (semiTarget) {
					this.$semiTarget = O2util.queryPath($elm, semiTarget);
				}

				if (this.options.serialize)
					this.$serialize = O2util.queryPath($elm, this.options.serialize);

				this.$slaves = $('input[data-checkboxgroup-id="' + slaves + '"]');

				this.markRelatedElements(this.$slaves, 'js-checkboxgroup-related');
			},

			render: function() {
				this.updateMaster();
				if (this.$serialize)
					this.serializeChecked();
			},

			/**
			 * Event handler for change event on the master element.
			 */
			handleMasterChange: function(evt, trigger, data) {
				if (!this.isRecursion(data)) {

					var direction = data && data.checkboxgroupDirection;
					if (this.masterSwitch) {
						this.updateSlaves(direction);
						if (this.$serialize)
							this.serializeChecked();
					}

					// Direct click on master or one of its ancestors - this must
					// result in either fully checked or fully unchecked state.

					if (!direction || direction == 'downwards') {
						this.$elm.removeClass('js-checkboxgroup-semi');
						if (this.$semiTarget) {
							this.$semiTarget.removeClass(this.semiClass);
						}
					}
				}
			},

			/**
			 * Event handler for change event on a slave element.
			 */
			handleSlaveChange: function(evt, trigger, data) {

				if (!this.isRecursion(data)) {
					this.updateMaster(data && data.checkboxgroupDirection);
					if (this.$serialize)
						this.serializeChecked();
				}
			},

			/**
			 * Calculates state of the master based on the slaves. Channels the direction of
			 * change event chain to the master update method to decide on event propagation.
			 */
			updateMaster: function(direction) {

				var $slaves = this.$slaves;

				if ($slaves.length == 0) // Pokud jsou slaves definovány, ale žádní neexistují, nebudeme dál nijak stav měnit.
					return;

				var checked   = $slaves.filter(':checked').not('.js-checkboxgroup-semi').length,
				    unchecked = $slaves.not(':checked').not('.js-checkboxgroup-semi').length,
				    semi      = $slaves.filter('.js-checkboxgroup-semi').length;

				if (semi || (checked && unchecked)) {
					this.semiMaster(!direction || direction == 'upwards');
				} else if (checked) {
					this.checkMaster(!direction || direction == 'upwards');
				} else {
					this.uncheckMaster(!direction || direction == 'upwards');
				}
			},

			/**
			 * Copies state from the master to the slave elements. Channels the direction
			 * of change event chain to the slave update method to decide on event propagation.
			 */
			updateSlaves: function(direction) {

				if (this.$elm.prop('checked')) {
					this.checkSlaves(!direction || direction == 'downwards');
				} else {
					this.uncheckSlaves(!direction || direction == 'downwards');
				}
			},

			/**
			 * Set master state to "checked"
			 */
			checkMaster: function(propagate) {

				var $elm = this.$elm,
					changing = $elm.is(':not(:checked),.js-checkboxgroup-semi');

				this.$elm
					.removeClass('js-checkboxgroup-semi')
					.prop('checked', true);

				if (this.$semiTarget) {
					this.$semiTarget.removeClass(this.semiClass);
				}

				if (changing && propagate) {
					this.propagateUpwards();
				}
			},

			/**
			 * Set master state to "not checked"
			 */
			uncheckMaster: function(propagate) {

				var $elm = this.$elm,
					changing = $elm.is(':checked,.js-checkboxgroup-semi');

				this.$elm
					.removeClass('js-checkboxgroup-semi')
					.prop('checked', false);

				if (this.$semiTarget) {
					this.$semiTarget.removeClass(this.semiClass);
				}

				if (changing && propagate) {
					this.propagateUpwards();
				}
			},

			/**
			 * Set master state to "semi-checked"
			 */
			semiMaster: function(propagate) {

				var $elm = this.$elm,
					changing = !$elm.hasClass('js-checkboxgroup-semi');

				this.$elm
					.addClass('js-checkboxgroup-semi')
					.prop('checked', this.semiChecked);

				if (this.$semiTarget) {
					this.$semiTarget.addClass(this.semiClass);
				}

				if (changing && propagate) {
					this.propagateUpwards();
				}
			},

			/**
			 * Trigger change event on the master.
			 */
			propagateUpwards: function() {
				this.$elm.trigger('change', { sourceUuid: this.uuid, checkboxgroupDirection: 'upwards' });
			},

			/**
			 * Check all slave checkboxes in the group.
			 */
			checkSlaves: function(propagate) {

				var $slaves = this.$slaves,
					$changing = $slaves.filter(':not(:checked),.js-checkboxgroup-semi');

				$slaves.prop("checked", true);
				if (propagate) {
					$changing.trigger('change', { sourceUuid: this.uuid, checkboxgroupDirection: 'downwards' });
				}
			},

			/**
			 * Uncheck all slave checkboxes in the group.
			 */
			uncheckSlaves: function(propagate) {

				var $slaves = this.$slaves,
					$changing = $slaves.filter(':checked,.js-checkboxgroup-semi');

				$slaves.prop("checked", false);
				if (propagate) {
					$changing.trigger('change', { sourceUuid: this.uuid, checkboxgroupDirection: 'downwards' });
				}
			},

			serializeChecked: function() {
				var serialized = [];

				this.$slaves.each(function(){
					var $slave = $(this);
					if ($slave.is(':checked') && $slave.attr('name'))
						serialized.push({
							name: $slave.attr('name'),
							value: $slave.val()
						});
				});

				serialized = JSON.stringify(serialized);
				this.$serialize.val(serialized);
			}
 		}
	);
})(jQuery);

(function($) {

	var cssSelectors = { // názvy css selektorů
		wrapper: '.js-counter',
		input:   '.js-counter-input',
		minus:   '.js-counter-minus',
		plus:    '.js-counter-plus'
	};

	O2widget.createClass(

		'counter',

		function(elm, options) {
			this.init(elm, options, [
				'base',
				'step',
				'min',
				'max'
			]);
		},

		{
			delegate: function() {
				this
					.handleRelated('click', cssSelectors.plus,  '_onPlusClick')
					.handleRelated('click', cssSelectors.minus, '_onMinusClick');
			}
		},

		{
			defaultOptions: {

				base: 0,
				step: 1,
				min: 1,
				max: Infinity,

				input: 'descendant::' + cssSelectors.input,
				plus:  'descendant::' + cssSelectors.plus,
				minus: 'descendant::' + cssSelectors.minus
			},

			scanDom: function() {

				var $elm = this.$elm,
					o = this.options;

				this.$input = (o.input ? O2util.queryPath($elm, o.input) : $());
				this.$plus  = (o.plus  ? O2util.queryPath($elm, o.plus)  : $());
				this.$minus = (o.minus ? O2util.queryPath($elm, o.minus) : $());

				this.markRelatedElements(this.$plus);
				this.markRelatedElements(this.$minus);
			},

			_onMinusClick: function() {
				this._changeNum(-this.step);
			},

			_onPlusClick: function() {
				this._changeNum(this.step);
			},

			_changeNum: function(valToAdd) {

				var number = this.base,
				    value = this.$input.val(),
				    p = parseInt(value, 10);

				if (!isNaN(p)) {
					number = p; // přiřadíme hodnotu, pokud je integer
				}
				number += valToAdd;

				if (number < this.min) {
					number = this.min;
				}
				if (number > this.max) {
					number = this.max;
				}

				this.$input.val(number);
				this.$input.trigger('change');
			}
		}
	);
})(jQuery);

(function($) {

O2widget.createClass(

		'charcounter',

		function(elm, options) {
			this.init(elm, options, [
				'limit',
				'message',
				'messageClass',
				'messageContainer',
				'current',
				'currentContainer'
			]);
		},

		{
			delegate: function() {
				this.handle('input change', '.js-charcounter', 'refreshCount');
			}
		},

		{
			defaultOptions: {
				limit: 600,
				messageClass: 'o2-control__validation--warning',
				messageContainer: 'closest-next::.o2-control__validation',
				current: 'Zbývá znaků: $1',
				currentContainer: 'closest-next::.o2-control__note',
				eolLength: 1
			},

			scanDom: function() {
				var $elm = this.$elm;
				this.$messageContainer = O2util.queryPath($elm, this.messageContainer);
				this.$currentContainer = O2util.queryPath($elm, this.currentContainer);
				this.options.eolLength = parseInt(this.options.eolLength);
				this.options.limit = parseInt(this.options.limit);
			},

			render: function() {
				this.refreshCount();
			},

			limitExceeded: function() {
				return this.charsLeft >= 0;
			},

			charsLeft: function() {
				var value = this.$elm.val(),
					count = value.length,
					eols  = value.match(/\r(?!\n)|\n(?!\r)/g),
					left  = this.options.limit - count;

				eols = (eols === null) ? 0 : eols.length;
				if (this.options.eolLength === 0)
					left += eols;
				else if (this.options.eolLength > 1)
					left -= (eols * this.options.eolLength) - eols;

				return left;
			},

			refreshCount: function (evt) {
				var left = this.charsLeft();

				this.$currentContainer.html(this.options.current.replace('$1', left < 0 ? 0 : left));
				if (left < 0) {
					this.showWarning();
					if (this.$currentContainer.length > 0)
						this.$currentContainer.hide();
				}
				else {
					this.hideWarning();
					if (this.$currentContainer.length > 0)
						this.$currentContainer.show();
				}
			},

			showWarning: function () {
				this.$elm.addClass(this.messageClass);
				this.originalMessage = this.$messageContainer.html(); // uchová původní obsah chybové zprávy
				this.$messageContainer
					.html(this.message)
					.addClass(this.messageClass)
					.show();
			},

			hideWarning: function () {
				this.$elm.removeClass(this.messageClass);
				this.$messageContainer
					.html(this.originalMessage)
					.removeClass(this.messageClass)
					.hide();
			}
 		}

	);

})(jQuery);

(function($) {
	O2widget.createClass(

		'barWidth',

		function(elm, options) {
			this.init(elm, options, []);
		},

		{
			delegate: function() {}
		},

		{
			defaultOptions: {},
			profileOptions: {},
			render: function() {
				this.$elm.css('width', this.$elm.attr('data-bar-width') + '%');
			},
		}
	);
})(jQuery);
(function($) {
	O2widget.createClass(

		'bulkactions',

		function(elm, options) {
			this.init(elm, options);
		},

		{
			delegate: function() {
				this.handleRelated('input change', 'input[type="checkbox"].js-bulkactions-related', 'onChange');
			}
		},

		{
			defaultOptions: {
				slaves: 'bulk',
				controls: '', // element s ovládáním hromadných akcí
				controlsAutohide: true,
				controlsCounter: '', // element s číslem počtu vybraných checkboxů
				polling: 5, // ms
				noDisabled: false
			},

			scanDom: function() {
				var $elm = this.$elm;
				this.eventTimeout = null;
				this.$controls    = O2util.queryPath($elm, this.options.controls);
				this.$counter     = O2util.queryPath($elm, this.options.controlsCounter);
				this.$slaves      = $('input[data-bulkactions-id="' + this.options.slaves + '"]');
				this.markRelatedElements(this.$slaves, 'js-bulkactions-related');

				this.$hiddenSingle = this.$controls.find('.js-bulkactions-single');
				this.$hiddenMore   = this.$controls.find('.js-bulkactions-more');
			},

			render: function() {
				this.$controls.css('transform', 'translateY(100%)'); // nejprve posune fixed-pane mimo viewport
				this.$controls.show(); // pak ho zobrazí mimo viewport
				this.handleChange(); // spočítá zaškrtlé checkboxy
				this.$controls.css('transition', 'transform 200ms'); // nakonec nastaví transition
			},

			onChange: function() {
				// Pro přepočet zaškrtnutých checkboxů se používá polling.
				clearTimeout(this.eventTimeout);
				this.eventTimeout = setTimeout($.proxy(this.handleChange, this), this.options.polling);
			},

			handleChange: function() {
				var checked = this.$slaves.filter(':checked');
				checked = this.options.noDisabled ? checked.not(':disabled').length : checked.length;
				this.$counter.html(checked);

				if (this.options.controlsAutohide) {
					if (checked > 0) {
						this.$controls.css('transform', 'translateY(0)');
					}
					else {
						this.$controls.css('transform', 'translateY(100%)');
					}
				}

				if (checked == 1 && this.$hiddenSingle.length)
					this.$hiddenSingle.show();
				else
					this.$hiddenSingle.hide();

				if (checked > 1 && this.$hiddenMore.length)
					this.$hiddenMore.show();
				else
					this.$hiddenMore.hide();
			}
		}
	);
})(jQuery);
(function($) {
	O2widget.createClass(

		'fileinput',

		function(elm, options) {
			this.init(elm, options, [
				'fileLabel',
				'countZero',
				'countOne',
				'countTwo',
				'countFive'
			]);
		},

		{
			delegate: function() {
				var c = this;
				$(document)
					.on('input change', '.js-fileinput', function(evt) {
						var i = c.getInstance(this);
						if (i) {
							i.selectFile(evt);
						}
					})

					// FireFox input focus hack
					.on('focus', '.js-fileinput', function(evt) {
						$(this).addClass('has-focus');
					})
					.on('blur', '.js-fileinput', function(evt) {
						$(this).removeClass('has-focus');
					});
			}
		},

		{
			defaultOptions: {
				fileLabel:  'closest-next::.js-fileinput-label',
				countZero: 	'Žádný soubor',
				countOne: 	'{count} soubor',
				countTwo: 	'{count} soubory',
				countFive: 	'{count} souborů'
			},

			profileOptions: {
				editlist: {
					fileLabel: 'empty::'
				}
			},

			scanDom: function() {
				var fileLabel = this.fileLabel;
				this.$fileLabel = (fileLabel ? O2util.queryPath(this.$elm, this.fileLabel) : this.$elm.next('label'));
			},

			render: function() {
				// Zobrazi pocet nahranych suborov iba v pripade ze sa pouziva iny label
				this.fileLabel && this.changeLabel(this.$elm[0].files);
			},

			selectFile: function(evt) {
				var $elm = this.$elm,
					files = $elm[0].files;

				if (files) {
					this.changeLabel(files);
				}
			},

			changeLabel: function(files) {

				var labelText = '';

				if (!this.$fileLabel.length) {
					return;
				}

				switch (files.length) {
					case 0:
						labelText = this.countZero;
						break;
					case 1:
						labelText = files[0].name;
						break;
					case 2:
					case 3:
					case 4:
						labelText = this.countTwo.replace( '{count}', files.length );
						break;
					default:
						labelText = this.countFive.replace( '{count}', files.length );
				}

				this.$fileLabel.html( labelText );
			}
 		}

	);
})(jQuery);

(function($) {
	O2widget.createClass(

		'pwd',

		function(elm, options) {
			this.init(elm, options, [

				// URL to check dictionary matches:
				'dictionaryCheckUrl',

				// Text messages:
				'textTooShort',
				'textWeak',
				'textOk',
				'textStrong',
				'textGeek',
				'textDictionaryMatch',

				// Selectors / elements:
				'infoTarget',    // message output
				'displayTrigger' // "display characters" trigger checkbox(es)
			]);
		},

		{
			// no static methods
		},

		{
			scanDom: function() {
				this.$infoTarget = $(this.infoTarget);
				this.$displayTrigger = $(this.displayTrigger);
			},

			render: function() {
				if (this.$displayTrigger && this.$displayTrigger.length && this.$displayTrigger.prop('checked')) {
					this.$elm.attr('type', 'text');
				}
			},

			bind: function() { // TODO: šlo by refaktorovat na statickou metodu?
				var me = this;
				this.$elm.on('keyup', function() {
					me.checkLength();
					var url = me.dictionaryCheckUrl;
					if (url) {
						me.checkDictionary(url);
					}
				});
				this.$displayTrigger.on('click', function() {
					var checked = this.checked,
						$elm = me.$elm;
					$elm.attr('type', checked ? 'text' : 'password');
				});
			},

			checkDictionary: function(url) {

				var me = this;

				if (this.dictionaryCheckBlocked || this.dictionaryCheckInProgress) {

					window.setTimeout(function() {
						me.checkDictionary(url);
					}, 250);

				} else {

					this.dictionaryCheckBlocked = true;
					window.setTimeout(function() {
						me.dictionaryCheckBlocked = false;
					}, 1000);

					var val = this.$elm.val();
					this.checkInProgressVal = val;
					this.dictionaryCheckInProgress = $.post(url, { pass: val }, function(data) {
						if (me.$elm.val() == me.checkInProgressVal) {
							if (data.length) {
								me.$infoTarget.text(me.textDictionaryMatch);
							}
						}
						me.dictionaryCheckInProgress = false;
					});
				}
			},

			checkLength: function() {

				var val = this.$elm.val(),
					len = val.length,
					$infoTarget = this.$infoTarget,
					textOk = this.textOk;

				switch (true) {
				case len == 0:
					$infoTarget.text('');
					break;
				case len > 12:
					$infoTarget.text(this.textGeek || textOk);
					break;
				case len > 8:
					$infoTarget.text(this.textStrong || textOk);
					break;
				case len > 6:
					$infoTarget.text(textOk);
					break;
				case len > 4:
					$infoTarget.text(this.textWeak || textOk);
					break;
				default:
					$infoTarget.text(this.textTooShort);
				}
			}
		}
	);

})(jQuery);

/**
 * Boilerplate pro nový widget.
 */
(function($) {
	O2widget.createClass(

		'move',

		function(elm, options) {
			this.init(elm, options, [
				"target"
			]);
		},

		{
			delegate: function() {
				this.handle('eventName', 'cssSelector', 'callbackName');
			}
			// other static methods
		},

		{
			defaultOptions: {},
			profileOptions: {},
			moved: false,
			scanDom: function() {
				this.$target = O2util.queryPath(this.$elm, this.target);

				if (this.$target.length != 1) {
					this.reportError(
						'console',
						"Target shoud be one element. Found " + this.$target.length + " elements."
					);
					return;
				}
			},
			render: function() {
				if (this.moved) // Jakmile je jednou přesunuto, příště už nepřesouváme.
					return;

				var $elm = this.$elm;
				$elm.appendTo(this.$target);
				$elm.removeClass("js-move");
				this.moved = true;
				this.disabled = true;
			},
			bind: function() {},
			unrender: function() {},
			unbind: function() {}
		}
	);
})(jQuery);
(function($) {
	O2widget.createClass(

		'validation',

		function(elm, options) {
			this.init(elm, options, [
				'match',
				'regexp',
				'regexpFlags',
				'regexpMessage',
				'required',
				'requiredMessage',
				'messageType',
				'messageClass',
				'messageContainer',
				'parent',
				'set',
				'maxLength'
			]);
		},

		{
			delegate: function() {
				this
					.handle('focus', '.js-validation', 'resetField')
					.handle('blur forceValidation.js-validation',  '.js-validation', 'validateField')
					.handleRelated('submit', '.js-validation-form', 'validateForm')
					.handleRelated('change', '.js-validation-form', 'handleViewChange');
			}
		},

		{
			defaultOptions: {
				regexp:              false,
				maxLength:           false,
				match:               false, // regexp test result that should generate error
				required:            false,
				requiredMessage:     'Pole nesmí být prázdné.',
				maxlengthMessage:    'Vložený text je moc dlouhý.',
				regexpMessage:       'Chybná hodnota.',
				autocompleteMessage: 'Nebyla vybrána žádná hodnota.',
				messageType:         'error',
				regexpFlags:         'i',
				parent:              '.o2-control__wrapper',
				messageContainer:    'descendant::div.o2-control__validation',
				setPath:             'closest::.js-validation-form',
				showOnFocus:         true,
				messageClass:        false,
				autocomplete:        false
			},

			scanDom: function() {
				var $elm = this.$elm,
					$parent = this.$parent = $elm.closest(this.parent);

				// Look for defined messageContainer element, use the default
				// if it's not defined, and create it if it doesn't exist:
				this.$messageContainer = O2util.queryPath($parent, this.messageContainer);

				this.markRelatedElements(this.$elm.closest('form.js-validation-form'));
				this.prepareSet();
			},

			render: function() {
				if (this.regexp)
					this.expression =  new RegExp(this.regexp, this.regexpFlags);

				if (parseInt(this.maxLength))
					this.maxLength = parseInt(this.maxLength);

				if (!this.$messageContainer.length)
					this.$messageContainer = $('<div class="o2-control__validation" style="disply: none;"></div>').appendTo(this.$parent);

				// Message class override or message type definition
				if (!this.messageClass) {
					switch (this.messageType) {
					case 'success':
						this.messageClass = 'o2-control__validation--success';
						break;
					case 'warning':
						this.messageClass = 'o2-control__validation--warning';
						break;
					default:
						this.messageClass = 'o2-control__validation--error';
					}
				}

				var form = this.$elm.prop('form');
				if (form) {
					this.adjustFormSubmits(form);
				}
			},

			resetField: function (evt) {
				if (!this.options.showOnFocus)
					this.hideMessage();
			},

			validateField: function() {
				var value = this.$elm.val();

				if (this.required && (value.length < 1)) { // required field empty
					this.showError(this.requiredMessage);
					return this.messageType;

				} else if (value.length > 0 && this.regexp) { // regexp validation can be done
					return this.checkRegexp(value);

				} else if (this.maxLength && this.maxLength == 'charcounter') {
					var charcounterInstance = O2widget.getInstance('charcounter', this.$elm);
					if (charcounterInstance && charcounterInstance.charsLeft() < 0) {
						this.showError(this.options.maxlengthMessage);
						return this.messageType;
					}

				} else if (this.maxLength && value.length > this.maxLength) {
					this.showError(this.options.maxlengthMessage);
					return this.messageType;

				} else if (this.options.autocomplete) { // Provázání na js-autocomplete
					var autocompleteOptions = this.options.autocomplete.trim().replace(/ /g, '').split(','); // Pole s nevalidními hodnotami
					var autocompleteInstance = O2widget.getInstance('autocomplete', this.$elm);
					var validationState = autocompleteInstance && autocompleteInstance.$hidden.data('validationState'); // Aktuální stav autocomplete
					if (validationState) {
						var stateFound = autocompleteOptions.filter(function(value) { // Zjistí, zda některá nevalidní hodnota odpovídá aktuálnímu stavu.
							return value === validationState;
						}).length;

						if (stateFound) {
							this.showError(this.autocompleteMessage);
							return this.messageType;
						}
					}
				}

				this.hideMessage();
				return false;
			},

			handleViewChange: function(evt) {
				if (evt) {
					this.adjustFormSubmits(evt && evt.currentTarget);
					evt.stopImmediatePropagation();
				}
			},

			adjustFormSubmits: function(form) {
				if (!this.set) {
					return;
				}

				var $form = form && $(form);

				if ($form && $form.length) {
					var submits = $form.data('validation-submits'),
						$submits = submits && O2util.queryPath($form, submits);

					if ($submits && $submits.length) {
						var canSubmit = this.collectThruSet(
								function() {
									return (this.$elm.is(':visible') ? (this.validateField() !== 'error') : true);
								},
								true,
								function(a, b) {
									return a && b;
								}
							);
						$submits.prop('disabled', !canSubmit);
					}
				}
			},

			/**
			 * Stará se o všechny validace uvnitř formu. Jakmile jedna z validací selže, zastaví se submit formu.
			 */
			validateForm: function(evt, trigger) {
				var $trigger = $(trigger);

				if ($trigger.data('validation-visible')) {
					// Skip hidden inputs:
					if (!this.$elm.is(':visible')) {
						return;
					}
				}

				// Zvaliduje aktuální pole a pokud je vrácen error, zastaví další propagaci.
				if (this.validateField() === 'error') {
					evt.preventDefault();

					if (this.set && !evt.validationError) {
						// nascrolluje na první error

						var $scrollTo = this.collectThruSet(
							function() {
								return (this.$elm.hasClass(this.messageClass) ? this.$elm.add(this.$messageContainer) : null);
							},
							$(),
							function($a, $b) {
								return ($b && $b.length ? $a.add($b) : $a);
							}
						).filter(':visible');

						if ($scrollTo.length) {
							O2util.scrollTo($scrollTo.eq(0), 200, -50);
						}
					}
					evt.validationError = true; // to be checked in scripts handling submission
				}
			},

			checkRegexp: function(value) {
				var testResult = this.expression.test(value);

				if (this.match === testResult) {
					this.showError(this.regexpMessage);
					return this.messageType;
				} else {
					this.hideMessage();
					return false;
				}
			},

			showError: function(msg) {
				if (msg) {
					this.$messageContainer.html(msg);
				}
				this.$elm.addClass(this.messageClass);
				this.$messageContainer.addClass(this.messageClass).show();
			},

			hideMessage: function() {
				this.$elm.removeClass(this.messageClass);
				this.$messageContainer.removeClass(this.messageClass).hide();
			}
 		}

	);
})(jQuery);
O2widget
	.associate('tooltip',       '.js-tooltip,abbr[title]')
	.associate('clickable',     '.js-clickable')
	.associate('double',        '.js-double')
	.associate('modal',         '.js-modal') // Musí být před update
	.associate('lightbox',      '.js-lightbox')
	.associate('popover',       '.js-popover')
	.associate('toggle',        '.js-toggle, .o2-section--collapsible, .o2-pane--collapsible')
	.associate('remove',        '.js-remove')
	.associate('toggleval',     '.js-toggleval')
	.associate('focusedit',     '.js-focusedit')
	.associate('autocomplete',  '.js-autocomplete')
	.associate('more',          '.js-more')
	.associate('fixed',         '.js-fixed')
	.associate('scrollspy',     '.js-scrollspy')
	.associate('lazylist',      '.js-lazylist')
	.associate('submit',        '.js-submit-on-change')
	.associate('autosave',      '.js-autosave')
	.associate('autofocus',     '.js-autofocus')
	.associate('match',         '.js-match')
	.associate('hfit',          '.js-hfit')
	.associate('multisubmit',   '.js-multisubmit')
	.associate('autorun',       '.js-autorun')
	.associate('clipboard',     '.js-clipboard')
	.associate('sysmsg',        '.js-sysmsg')
	.associate('analytics',     '.js-analytics')
	.associate('checkboxgroup', '.js-checkboxgroup')
	.associate('coupled',       '.js-coupled')
	.associate('field',         '.js-field')
	.associate('filter',        '.js-filter')
	.associate('notify',        '.js-notify')
	.associate('update',        '.js-update') // Musí být po modal
	.associate('disable',       '.js-disable')
	.associate('counter',       '.js-counter')
	.associate('barWidth',      '.js-bar-width')
	.associate('fileinput',     '.js-fileinput')
	.associate('charcounter',   '.js-charcounter')
	.associate('bulkactions',   '.js-bulkactions')
	.associate('validation',    '.js-validation')
	.associate('pwd',           '.js-pwd')
	.associate('move',          '.js-move')
	.associate('select',        '.js-select',        'selects')
	.associate('date',          '.js-date',          'datetime')
	.associate('ask',           '.js-ask',           'form-exts')
	.associate('listcontrol',   '.js-listcontrol',   'form-exts')
	.associate('datatable',     '.js-datatable',     'datatable');

// Aktivuje widget pouze pokud není detekováno dotykové zařízení
if (!O2util.hasTouch()) {
	O2widget.associate('hover', '.js-hover');
}
(function($) {
	$window = $(window);
	$document = $(document);

	// Aktivuje/deaktivuje widgety na základě šířky viewportu.
	$window.on('resize', $.throttle(200, function() {
		O2widget.resolveMedia();
	}));

	// Vypne (unrender) widgety v daném místě DOM.
	$document.on('contentgone.o2util', function(evt) {
		O2widget.resolveDissociations($(evt.target));
	});

	// V případě, že je modifikovaný obsah DOM, aktualizuje DOM reference s watcherem.
	$document.on('modified.o2util', function(evt) {
		O2widget.resolveWatchers($(evt.target));
	});

	// See main.js for the contentready event
	$document.on('contentready.o2util', function(evt) {
		O2widget.resolveAssociations($(evt.target));
	});

	// Preload assetů
	$document.ready(function(){
		$('<div class="o2-preload"></div>').appendTo('body');

		// Zobrazí/schová obsah po načtení celé stránky.
		$('.js-onload').each(function() {
			var $elm  = $(this),
				$show = O2util.queryPath($document, $elm.data('onload-show')) || $(),
				$hide = O2util.queryPath($document, $elm.data('onload-hide')) || $();

			$show.show();
			$hide.hide();
		});
	});

	// Globální změna click eventu je shit, který tu nechceme.
	// Je třeba zvážit, čím to nahradit.
	$document.on('click', 'a[href^="#"]', function(evt) {
		if ($(this).data('click-captured')) { // Pokud click zachytil již nějaký předchozí widget, tak return.
			return;
		}
		var href = this.getAttribute('href'),
			$elm = (O2util.isValidSelector(href) ? $(href) : $());
		if ($elm.length == 1) {
			evt.preventDefault();
			if (history && history.pushState) {
				history.pushState({}, '', href);
			}
			O2util.scrollTo($elm);
			$elm.trigger('hashfor.o2util');
		}
	});

})(jQuery);
